## 회복 (Recovery) 

: `트랜잭션`을 수행하는 도중 `장애`가 발생해 DB가 손상되었을 때 `손상되기 이전`의 정상 상태로 `복구`하는 작업

### 장애의 유형 

- 트랜잭션 유형 : 트랜잭션 `내부`의 `비정상적인 상황`으로 인해 프로그램 실행이 `중지`되는 현상 
- 시스템 장애 : DB에 손상을 입지는 않았지만 HW 오동작, SW 손상 등에 의해 `모든 트랜잭션`의 `연속적인 수행`에 장애를 주는 현상
- 미디어 장애 : `저장장치`의 손상으로 인해 DB의 일부 또는 전부가 `물리적으로 손상`된 상태

### 회복 관리기 (Recovery Management) 

- 회복 관리기는 `DBMS`의 구성 요소 
- `트랜잭션 실행`이 성공적으로 완료되지 못하면 `DB`에서 생성했던 `모든 변화`를 `취소`하고 이전의 상태로 복구하는 역할을 한다.
- `메모리 덤프`, `로그`를 이용해서 회복을 수행

## 회복 기법 

### 1) 연기 갱신 기법 (Deferred Update) 

- 트랜잭션이 `성공적`으로 완료될 때까지 DB에 대한 `실질적인 갱신`을 `연기`하는 방법 

- `수행 중` 갱신되는 내용은 `Log`에 보관
- `부분 완료` 시점에는 `Log`에 보관한 `갱신 내용`을 실제 DB에 `기록`한다.
- `부분 완료 전`에 `장애`가 발생해서 트랜잭션이 RollBack 되면 실제 DB에 영향을 끼친 것은 없기 때문에 취소작업을 할 필요 없다.
- `Redo` 작업만 가능 

### 2) 즉각 갱신 기법 (Immediate Update) 

- 트랜잭션이 데이터를 `갱신`하면 트랜잭션이 부분 완료 전이더라도 즉시 `DB에 반영`하는 방법

- `장애`가 발생해 회복 작업을 대비해서 `갱신할 내용들`은 `Log`에 보관한다
- 회복 작업 시 `Redo`, `Undo` 모두 사용 가능

### 3) 그림자 페이지 대체 기법 (Shadow Paging) 

- 갱신 이전의 DB를 `일정 크기`의 페이지 단위로 구성해서 `각 페이지의 복사본`인 `그림자 페이지`를 별도로 보관한다.  
  `실제 페이지`를 대상으로 갱신 작업을 하다가 `장애가 발생`해서 트랜잭션 작업을 Rollback 하면  
  `갱신된 이후`의 `실제 페이지 부분`에 `그림자 페이지`를 `대체`해서 회복시키는 작업 
  
- 로그, undo, redo `안해도 됨`

### 4) 검사점 기법 (Check Point) 

트랜잭션 `실행 중` 특정 단계에서 `재실행`할 수 있도록 `갱신 내용`이나 `시스템 상황`에 대한 정보와 함께 `검사점`을 `로그`에 보관한다.  

`장애 발생` 시 트랜잭션 전체를 철회하지 않고 `검사점`부터 `회복 작업`을 해서 회복 시간을 `절약`하도록 하는 기법

## 병행제어 (Concurrency Control) 

: `다중 프로그램`의 이점을 활용해 `동시에 여러 개의 트랜잭션`을 병행수행 할 때  
  `DB의 일관성`이 파괴되지 않도록 `트랜잭션의 상호 작용`을 `제어`하는 것 

## 병행제어 기법의 종류 

### 1) 로킹 (Locking)

- `주요 데이터에 대한 접근`을 `상호 배타적`으로 하는 것 
- 트랜잭션들이 `액세스하기 전`에 `Lock(잠금)`을 요청해서 `Lock이 허락`되면 로깅 단위로 `액세스`할 수 있도록 하는 기법

★★ 로킹 단위 (Locking Granularity)  
  1) `병행제어`에서 한꺼번에 로킹할 수 있는 `객체의 크기`를 의미
  2) DB, 파일, 레코드, 필드 등이 `로킹 단위`가 될 수 있음
  3) 로킹 단위가 `크면` 로크의 개수가 `작아져서` 관리하기 `쉽다`. 하지만 병행성 수준이 `낮아진다`  
     로킹 단위가 `작으면` 로크의 개수가 `커져서` 관리하기 `어럽다`. 하지만 병행성 수준이 `높아진다`

### 2) 타임 스탬프 순서 (Time stamp Ordering)

- `직렬성 순서`를 결정하기 위해 트랜잭션 간의 `처리 순서`를 `미리 선택`하는 기법 중 가장 보편적인 방법 

- 트랜잭션 `실행 전`에 `시간표(Time stamp)`를 부여해 `부여된 시간`에 따라 트랜잭션 작업을 수행하는 기법 
- `교착상태 (Dead Lock)`이 발생하지 않음

### 3) 최적 병행 수행



### 4) 다중 버전 기법 

- 타임 스탬프의 개념을 이용한 기법. 

- 트랜잭션이 갱신될 때 마다 `버전을 부여`하고 관리한다.


## 병행 수행의 문제점 

1) 갱신 분실 : `2개 이상의 트랜잭션`이 `같은 자료`를 `공유`해서 `갱신`할 때 갱신 결과의 `일부`가 `없`어지는 현상
2) 비완료 의존성 : 하나의 트랜잭션 수행이 `실패`한 후 `회복되기 전`에 `다른 트랜잭션`이 `실패한 갱신 결과`를 참조하는 현상
3) 모순성 : 2개의 트랜잭션이 `병행수행`될 때 `원치 않는 자료`를 이요해서 발생하는 문제
4) 연쇄 복귀 : 병행수행되던 트랜잭션들 중 `어느 하나`가 문제가 생겨 `Rollback` 하는 경우 `다른 트랜잭션`도 함께 `Rollback`되는 현상 





















