## 디자인 패턴(Design Pattern) 의 개요 

: 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때  
참조할 수 있는 `전형적인 해결 방식 또는 예제`를 의미한다.

- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다.
- 개발 과정 중에 `문제가 발생`하면 문제에 해당하는 `디자인 패턴을 참고`해 `적용`하는 것이 `더 효율적`이다.

- 디자인 패턴은 한 패턴에 `변형`을 가하거나 `특정 요구사항`을 반영하면 `유사한 형태`의 `다른 패턴`으로 변화하는 특징이 있다.

- GoF에 의해 처음으로 고안되었다. 

- GoF 디자인 패턴 유형에 따라 `생성 패턴`, `구조 패턴`, `행위 패턴`으로 나뉜다.


## 디자인 패턴의 장/단점 

- 장점 
1) 범용적인 코딩 스타일 덕분에 구조 파악이 용이하다
2) 객체지향 설계 및 구현의 생산성을 높이는데 적합하다
3) 개발자 간의 원활한 의사소통이 가능하다. 
4) 설계 변경 요청에 대한 유연한 대처가 가능하다.

- 단점 
1) 디자인 패턴에 맞게 구현해야 하기 때문에 초기 비용이 많이 든다.
2) 객체지향을 기반으로 한 설계와 구현을 다뤄서 다른 기반의 애플리케이션 개발에는 적합하지 않다.

## 생성 패턴 (Creational Pattern)

: `객체의 생성과 참조` 과정을 `캡슐화`해 객체가 `생성`되거나 `변경`되어도 프로그램의 구조에 `영향`을 `크게 받지 않도록` 해 프로그램의 `유연성`을 더한다.

| 패턴 | 설명 | 
| --- | --- | 
| 추상 팩토리 (Abstract Factory) | 인터페이스를 통해 `서로 연관되는 객체들`의 `그룹`을 만들어서 추상적으로 표현 | 
| 빌더 (Builder) | `인스턴스들을 조합`해서 객체를 생성  | 
| 팩토리 메소드 (Factory Method) | 객체 생성을 `서브 클래스`에서 처리하도록 분리해 캡슐화한 패턴. `가상 생성자(Virtual Constructor)`라고도 함. | 
| 프로토타입 (Prototype) | 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴 | 
| 싱글톤 (Singleton) | `하나의 객체`를 생성하면 `생성된 객체`를 `어디서든` 참조할 수 있도록 한 패턴. (단, 여러 프로세스가 참조할 수는 없음) | 

## 구조 패턴 (Structural Pattern)

: 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.

| 패턴 | 설명 |
| --- | --- |
| 어댑터 (Adapter) | `호환성이 없는 클래스들`의 인터페이스를 `다른 클래스`가 `이용`할 수 있도록 변환하는 패턴  |
| 브리지 (Bridge) | 구현부에서 `추상층`을 분리해 서로가 `독립적으로` 확장할 수 있도록 구성한 패턴 |
| 컴포지트 (Composite) | 여러 객체를 가진 복합 객체와 단일 객체를 `구분 없이` 다루고자 할 때 사용하는 패턴 |
| 데코레이터 (Decorator) | `객체 간의 결합`을 통해 능동적으로 기능을 확장할 수 있는 패턴  |
| 퍼싸드 (Facade) | 복잡한 서브 클래스들을 피해 `더 상위에` 인터페이스를 구성해서 `서브 클래스들`의 기능을 `간편하게 사용`할 수 있도록 한 패턴 |
| 플라이웨이트 (Flyweight) | 인스턴스가 필요할 때 마다 가능한 `공유해서` 사용하도록 해서 `메모리를 절약`하는 패턴 |
| 프록시 (Proxy) | `접근이 어려운 객체`와 `그 객체와 연결하려는 객체` 사이에 `인터페이스` 역할을 수행하는 패턴 |

## 행위 패턴 (Behavior Pattern) 

: 객체들이 서로 `상호작용하는 방법`이나 `책임 분배 방법`을 정의하는 패턴 

: 하나의 객체로 수행할 수 없는 작업을 `여러 객체로 분배`하면서 `결합도를 최소화`할 수 있도록 한다.

| 패턴 | 설명 |
| --- | --- |
| 책임 연쇄 (Chain of Responsibility) | `요청을 처리할 객체`가 `2개 이상 존재`해 `한 객체`가 `처리하지 못`하면 다른 객체로 넘어가는 형태의 패턴 |
| 커맨드 (Command) | 요청을 `객체의 형태`로 캡슐화해 재사용하거나 취소할 수 있도록 요청에 필요한 정보를 `저장`하거나 `로그를 남기는` 패턴 |
| 인터프리터 (Interpreter) | 언어에 문법 표현을 정의하는 패턴  |
| 반복자 (Iterator) | 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴 |
| 중재자 (Mediator) | 수많은 객체들 간의 `복잡한 상호작용`을 `캡슐화`해 `객체로 정의`하는 패턴 |
| 메멘토 (Memento) | 특정 시점에서의 `객체 내부 상태`를 `객체화`해서 이후 요청에 따라 `객체`를 `해당 시점의 상태`로 `되돌릴 수 있는` 기능을 제공하는 패턴 |
| 옵서버 (Observer) | 한 객체의 상태가 `변하면` 객체에 `상속되어` 있는 `다른 객체들`에게 `변화된 상태`를 `전달`하는 패턴  |
| 상태 (State) | `객체의 상태`에 따라 `동일한 동작`을 `다르게 처리`해야 할 때 사용하는 패턴 |
| 전략 (Strategy) | `동일 계열의 알고리즘`을 개별적으로 `캡슐화`해 `상호 교환`할 수 있게 정의한 패턴 |
| 템플릿 메소드 (Template Method) | `상위 클래스`에서 `골격을 정의`하고 `하위 클래스`에서 `세부 처리`를 `구체화`하는 구조의 패턴 |
| 방문자 (Visitor) | 각 클래스들의 `데이터 구조`에서 `처리 기능`을 분리해 `별도의 클래스`를 구성하는 패턴  |














