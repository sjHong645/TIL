Paging 기법은 분명 장점이 있는 기법이지만 여전히 해결하지 못한 부분이 존재한다.

1) Performance 부분 ⇒ page table를 사용한다는 구조적인 한계가 있다. 이는 cpu가 메인 메모리에 접근하는 시스템의 문제이다.

2) utilization 부분에 있어서는 생각지 못한 부분에서 문제가 있다.

각각에 대해서 알아보도록 하겠다.

## 1. Performance 부분의 해결 

근본적인 구조적 문제는 물리 메모리에 접근하기 위해서 2번의 접근이 필요하다는 것(Two memory access problem)

![image](https://user-images.githubusercontent.com/64796257/147845656-5142048f-781c-47ce-b82c-6220d8683af6.png)

`logical memory`에서 페이지 테이블에 접근 ⇒ 해당 페이지를 저장할 `프레임 번호`를 알아냄 ⇒ `main memory`에 접근

이렇게 `page table에 접근`하고 `main memory에 접근`함으로써 메인 메모리에 `2번 접근`하게 된다. 

이러한 문제가 paging 방식에서 발생하는 performance 문제다.

이는 구조적인 문제에서 나타나는 것이기 때문에 SW적으로 해결하는 것은 어렵다. 

그래서 HW 적으로 해결한 방법이 바로 page table을 저장할 register를 배치하는 것이다.

이때 배치하는 하드웨어를 `associative memory`라고 한다. 하지만, register를 배치할 수 없다.  
그리고 이때 사용하는 개념을 TLB라 한다.

[관련 내용](https://www.youtube.com/watch?v=aCe8O9YiQWA&list=PLvr1gHQBhkJRZhE3-TaxDScIW8XddQayq&index=27)

### register를 배치할 수 없는 이유

일단 page table을 저장하기 위해서는 `page table`이 어느 정도의 크기를 가지고 있는지 파악해야 한다.  
어느 정도의 크기를 가지고 있을까??

`Logical Address Space`는 `4GB`를 제공한다. `page size = 4KB`인데 

그렇다면 Logical Address Space의 page의 개수는 `4GB/4KB = 4 × 2^30 / 4 × 2^10 = 2^20 = 1M (개)`가 된다.

즉, 페이지 테이블을 배열로 선언한다면, `pageTable[1024*1024]` 로 선언해야 한다.

그렇다면, `자료형`은 뭘로 지정해야 할까?? 

`frame 번호`를 `저장할 자료형`을 int형이라 하자. 

- 자료형이 `int형`이기 때문에 page table 자료 1개당 `2³²개`의 프레임을 표현할 수 있다.
- 페이지 1개당 `4KB = 2¹²B` 크기를 고정적으로 가짐

⇒ 페이지 테이블의 요소 개수와 상관없이 자료형이 `int`형이면 `2³²개 × 2¹²B = 2⁴⁴B = 2⁴ × 2^40B = 16TB`의 물리 메모리 표현가능

<그림 요약> 

![image](https://user-images.githubusercontent.com/64796257/147846360-48b89768-5b2b-4818-95d0-6ee7ea4d2bdb.png)

하지만 현재 대부분 사용하고 있는 물리메모리는 `최대 1TB` 정도의 크기만 가지고 있다. 번호가 많은 건 좋지만 너무 많다. 

그러면, 자료형을 `short 2B`로 `할당`한다면? 2Bytes = 16Bits니까 `2^16개`의 숫자를 표현할 수 있다.

프레임 번호의 개수가 2^16개라면 `2^16 × 2^12 = 2^8 × 2^20 = 2^28 = 256MB`만큼의 `물리 메모리`를 표현할 수 있다.

하지만, 이 크기는 너무 작다. 일반 노트북도 1GB는 기본적으로 메모리를 가지고 있기 때문이다.

### 프레임 번호를 어느정도로 표현할 수 있는게 적당할까 

ex) `1TB`의 `물리메모리`를 표현한다고 하자. 

1TB = 2^40을 표현할 수 있어야 하는데 프레임의 크기는 4KB = 2^12bytes이다. 

따라서, 프레임을 표현할 수 있는 숫자는 2^40 / 2^12 = 2^28 개 즉, `28bits`를 할당해주면 된다. 하지만, 이런 자료형은 존재하지 않는다.

그래서 결국에는 int 즉, 4Bytes 만큼의 크기를 할당하게 되는데...  
32bits를 다 쓰기에는 너무 많으니까 `28bits 만큼은 프레임 번호`를 표현하는데 사용 + `4bits는 추가적인 정보`를 나타내는데 사용한다. 

그렇게 페이지 넘버 + 추가적인 내용을 포함한 전체적인 페이지에 대한 정보를 `Page Table Entry(PTE)`라고 한다.

자. 이제 Page table의 크기를 구해보자. PTE는 4Bytes이다. 페이지의 개수는 앞서 구했듯이 1M이기 때문에 Page table의 크기는 4B × 1M = 4MB가 된다. 

따라서, 레지스터를 추가시키고 싶다면 그 크기가 4MB는 되야 하는데 이는 레지스터가 담기에는 너무나도 큰 용량이다.

따라서, Page table을 register를 통해서 구현하는 건 적절하지 않다. 

그래서 두 번 접근하는 문제를 해결하기 위해서 TLB라는 개념을 이용할 것 이다.

### TLB

![image](https://user-images.githubusercontent.com/64796257/147846534-bfe1d2d4-6809-4887-b208-c81250c23afd.png)

`논리 메모리`에서 `물리 메모리에 접근할 프레임 번호`를 알아내려고 할 때 내가 원하는 논리 메모리에 대한 데이터가 TLB에 존재하지 않는다면

`페이지 테이블`에서 그 데이터를 `가져옴` + `TLB`에 해당 데이터를 `업데이트` 해준다. 

만약에 데이터가 TLB에 있다면 그 내용을 가지고 곧바로 프레임 번호를 알아내는 방식이다. (TLB가 일종의 `cache 역할`을 한다고 보면 됨)

좀 더 구체적으로 말하면, 논리 메모리에서 TLB와 페이지 테이블을 동시에 접근한다.

만약에 TLB가 해당 데이터를 가지고 있다면(`TLB hits`) 그 페이지에 해당하는 프레임 번호를 이용하면 된다.  
	여기서 페이지 테이블에서 해당 데이터를 찾아서 가지고 온다면 그 요청은 무시하면 된다.
    
만약에 TLB가 해당 데이터를 가지고 있지 않는다면(`TLB Miss`) TLB가 아닌 `페이지 테이블`에서 데이터를 찾아서  
그 데이터를 활용하고 해당 데이터를 TLB에 업데이트 해주면 된다.

앞서 말했듯이 TLB는 cache와 비슷하게 `시간/공간 지역성`에 따라서 TLB에 데이터를 저장한다.

그렇다면, 이러한 TLB는 어떤 device로 구현할 수 있을까?? main memory 보다는 빠르고 register 보다는 싼 `associative memory`를 이용하면 된다.

associative memory는 TLB를 동시에 탐색할 수 있도록 한다. 

그래서 테이블에서 데이터를 찾는 시간이 O(n)에서 O(1)로 엄청나게 줄어든다는 걸 알 수 있다.

### Effective Access Time : 메모리에 접근할 때 평균적으로 소요되는 시간 = `TLB access time + Hit case + Miss case`

ex. Hit ratio α = 80%, t = 1ns , m = 100ns라고 했을 때 EAT는?

Hit ratio = TLB에 접근했을 때 원하는 데이터가 TLB에 있을 확률 

t = TLB에 접근하는데 걸리는 시간 / m = 메모리에 접근하는데 걸리는 시간

계산을 하면 다음과 같다. 1 + 0.8 * 100 + 0.2 * (100 + 100)

왜 이런 식을 세울 수 있냐면... 일단 TLB에 접근한다. 거기서 `1` 만큼의 시간이 소요된다.

그렇게 TLB에 접근하고 나서 Hit가 일어날 확률이 80% = 0.8이다.  
hit를 하면 곧바로 메인 메모리에 접근하기 때문에 `0.8 * 100` 이라는 시간이 소요된다.

TLB에 접근하는데 Miss가 일어날 수도 있다. Miss가 일어날 확률은 20% = 0.2다.  
miss를 하면 곧바로 메인 메모리에 접근하는 것이 아니라 페이지 테이블에 접근하고 나서 메인 메모리에 접근하다.

이때, 페이지 테이블은 메인 메모리에 존재한다. 

즉, miss가 일어날 때는 메인 메모리에 2번 접근하게 되므로 `0.2 * (100 + 100)`이라는 시간이 소요되는 것이다.

이를 토대로 식을 세워서 `1 + 0.8 * 100 + 0.2 * (100 + 100)`라는 식이 나온 것이다.

### Hierarchical Paging 

앞서 페이지 테이블의 크기는 4MB가 된다고 했다. 이는 메모리에 담기에는 너무나도 큰 용량이고 낭비가 심하게 된다. 왜 그런지 살펴보자.

![image](https://user-images.githubusercontent.com/64796257/147846675-1029cadb-cff2-47c2-896f-59a7852297b3.png)

![image](https://user-images.githubusercontent.com/64796257/147846684-4b2899ad-65d3-4eb9-a590-93de68ce9d79.png)

`text 부분`의 페이지 넘버는 `0x 0000 0` = 0번이여서 페이지 테이블의 `0번 인덱스`의 프레임을 할당받았고  
`data 부분`의 페이지 넘버는 `0x 0080 0` = 2048번이여서 페이지 테이블의 `2048번 인덱스`의 프레임을 할당받았고  
`stack 부분`의 페이지 넘버는 `0x 0A00 0` = 40960번이여서 페이지 테이블의 `40960번 인덱스`의 프레임을 할당받는다.  

그렇게 할당받은 프레임에 있는 값에 따라 물리 메모리에 데이터를 각각 저장했다.  
`text 부분`은 물리 메모리 주소 3000  
`data 부분`은 물리 메모리 주소 2000  
`stack 부분`은 물리 메모리 주소 4000  

그런데... `페이지 테이블`은 `물리 메모리`에 저장된다고 했다. 왜냐하면 4MB라는 큰 용량을 저장할 곳이 따로 없기 때문이다.  
(TLB가 associative memory에 저장된다)

저장하려고 하는 `프로세스 크기`는 `12KB`인데 `페이지 테이블은 4MB`를 차지한다. 배 보다 배꼽이 더 큰 상황이 연출되었다. 

이러한 상황을 해결하기 위해서 쓰는 방법이 `Hierarchical Paging` 기법이다.

![image](https://user-images.githubusercontent.com/64796257/185564859-22700ea6-b545-43e3-af0b-ddd0aa5d0b9e.png)

`1-level 페이지 테이블`은 `물리 메모리`에 `저장`되고 `크기`는 `프레임 하나` 크기다.

`2-level 페이지 테이블`은 `필요한 만큼의 프레임`만 있으면 된다. 그래서 3개의 프레임이 필요하다.

그러면 물리 메모리에서는 총 7개의 프레임을 사용했는데 그 중 3개가 프로세스 관련 내용이니까 

utilization 측면에서 보면 page table이 하나 있을 때보다는 훨씬 나아졌다는 걸 알 수 있다.

각 프로세스의 Logical Address Space의 주소값을 먼저 살펴보자.

![image](https://user-images.githubusercontent.com/64796257/147846733-82e0cff9-dbba-41a2-8ccf-0dac373d12d5.png)

`text 부분`의 `1-level index값 = 0000 0000 00 = 0`이다.
그래서 1-level 페이지 테이블의 index = 0으로 가보니 `5000`이라는 값이 있다. 

이는 `2-level 페이지 테이블`이 위치한 `물리 메모리 주소값`이다.  

정리 : 
1) 1-level 페이지 테이블에 5000이라는 값이 저장됨
2) 물리 메모리 주소 5000으로 이동
3) 이는 `2-level 페이지 테이블`에 `접근`하는 것

text 부분의 `2-level index값 = 00 0000 0000 = 0`이다. 

5000이라는 주소를 통해서 접근한 2-level 페이지 테이블의 페이지의 `0번째 값`에 `접근`한다는 뜻이다. 거기에 3000이라는 값이 저장되어 있다.

이 `3000`은 text 부분을 물리 메모리에 저장할 주소이다. 최종적으로 text 부분은 3000이라는 물리 메모리에 저장된다.

하나 더 해보자.

data 부분의 `1-level index 값 = 0000 0000 10 = 2`다.  
그래서 1-level 페이지 테이블의 index = 2로 가보니 5001이라는 값이 있다.

이는 `2-level 페이지 테이블`이 위치한 `물리 메모리 주소값`이다.  
 
정리 : 
1) 1-level 페이지 테이블에 5001이라는 값이 저장됨
2) 물리 메모리 주소 5001으로 이동
3) 이는 `2-level 페이지 테이블`에 `접근`하는 것

data 부분의 `2-level index 값 = 00 0000 0000 = 0`이다. 

5001이라는 주소를 통해서 접근한 `2-level 페이지 테이블의 페이지의 0번째 값`에 접근한다는 뜻이다. 

거기에 `2000`이라는 값이 저장되어 있다. 2000 = data 부분이 물리 메모리에 위치할 주소

따라서, data 부분은 2000이라는 물리 메모리에 저장된다.

이와 같이 테이블이 늘어났을 때 `effective access time(EAT)`을 살펴보자.

TLB에서 miss가 발생한다면, 2-level page table에서는 `1-level`, `2-level`, `데이터` 총 3번의 메모리 접근이 발생한다.

그래서 Hit ratio α = 80%, t = 1ns , m = 100ns라고 했을 때 

EAT = 1 + 0.8 * 100 + 0.2 * (100 + 100 + 100)이 된다.

즉, level을 늘리면 늘릴 수록 TLB miss의 risk가 커질 수 있다. 하지만, 이 부분은 걱정하지 않아도 된다.

왜냐하면 대부분의 HIt ratio는 99%에 근접한 값이 나온다. 

이를 통해 EAT를 계산해보면 1 + 0.99 * 200 + 0.01 * (100 + 100 + 100)이 된다.

즉, 대부분 miss가 일어날 비율이 매우 적기 때문에 risk가 늘어난다고 하지만 paging을 계층적으로 나눠서 쓸 가치가 충분한 것이다.

cf) Shared Pages

![image](https://user-images.githubusercontent.com/64796257/147846792-7b3d3218-1107-4bdf-a09b-ab56557cc86f.png)

3개의 프로세스가 ed 1, 2, 3이라는 3개의 페이지를 공유하고 싶다. 

그러기 위해서는 각 프로세스의 페이지 테이블의 값들을 똑같이 써주면 된다.

여기서 ed 1, 2, 3은 각각 물리 메모리에서 3, 4, 6으로 위치했으니까 똑같이 3, 4, 6을 써주면 된다.

이러한 방식으로 3개의 프로세스가 똑같은 데이터 3개를 공유할 수 있게 된다.


















