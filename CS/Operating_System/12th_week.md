### Main Memory

메모리를 관리하는 방법을 시간순으로 나열하면 다음과 같다.

1. 원시적인 방법(Contiguous and Multiple partition)
2. Segmentation
3. Paging ==> 여기에 virtual memory 개념을 추가하면 demand paging이라는 개념으로 확장된다.

### BackGround
- `프로세스`가 `동작`하기 위해서는 프로그램을 `Disk ⇒ memory`로 가져와야 한다.
- Main memory와 Register는 `CPU가 직접 접근`할 수 있는 `저장장치`다.
- Memory의 unit은 `address + read request`이거나 `address + data and write request`이다.
- 레지스터들은 일반적으로 CPU clock의 1 사이클 내에 접근 가능하다.
- `Cache`는 Main memory와 CPU 사이에 존재한다. ⇒ CPU가 메인 메모리에 접근할 때 상대적으로 더 많은 clock을 소요하게 되는데 이를 완화시켜주는 역할을 한다.
- 메모리의 보호는 올바른 동작을 위해서 필요하다.

`메모리`라는 디바이스의 특징은 매우 단순하다. 메모리는 원하는 주소에 `읽기(read)`, `쓰기(write)` 동작만 한다.  
그리고 주소를 읽을 때는 메모리의 시작 주소인 0번 부터 시작해서 `바이트(Byte)` 단위로 데이터를 읽는다.

⇒ 이 두 가지만 이용해서 메모리를 만드는 많은 회사들이 있는데 서로 교차해서 사용해도 될 만큼 동일하다.

### Logical Address Space & Physical Address Space

소스 파일(source file)이 있다.

그 소스 파일을 `컴파일러(complier)`를 통해서 각각의 코드에 대한 `Logical Address(논리 주소)`를 생성한다.  
이를 통해서 소스파일에 있는 code와 data에 대한 논리 주소를 배치한다.

그리고 나서 이러한 논리 주소와 대응되는 실제 메모리에서 취급하는 주소인 `Physical Address`로 바꾼다.

예전에는 프로세스를 하나씩 실행했기 때문에 이러한 과정에 전혀 문제가 없었다.

하지만, `멀티 프로세싱`이라는 개념이 생기면서 2개 이상의 프로세스를 실행하면서 문제가 발생한다.

예를 들어 A라는 소스파일에서 논리 주소 공간을 생성했는데 이때 필요한 공간이 3MB이고  
	  B라는 소스파일에서 논리 주소 공간을 생성했는데 이때 필요한 공간이 4MB이다.

A라는 논리 주소에서 1 이라는 주소값에 있는 데이터를 load 하려고 한다면... A의 논리 주소 공간에 있는 1에 있는 데이터를 load 한다는 뜻이다. B도 마찬가지다.

여기서 A의 논리 주소를 물리 주소로 바꾸려고 하는데 기존에 있던 물리 주소 공간은 비어있었기 때문에  
0부터 시작해서 3까지 A에 대한 데이터로 채워지게 된다. 

문제는 B를 메모리에 추가시키면서 생긴다. B를 물리 주소 공간으로 변환시키려고 하는데 기존에 A가 3까지 채워놨기 때문에 B는 3부터 시작해서 7까지 메모리를 채울 수 있다.

그런데, B의 코드에 1번 주소에 있는 데이터를 load 하려고 한다는 데이터가 있다면?  
이는 B가 논리주소에 있을 때는 괜찮다. 왜냐하면, B가 논리주소에 있을 때는 시작주소가 0이였기 때문이다.

그런데 B가 메모리로 즉, 물리 주소로 변환될 때 시작 주소가 바뀌면서 ‘1번 주소에 있는 데이터를 load’ 한다는 코드의 의미가 이상해져버렸다. 

메모리에서의 주소 1은 A가 위치한 곳이기 때문에 이 상태로 실행해버리면 segmentation fault가 발생한다.

이러한 문제를 해결하기 위해서 `가상 주소`를 `물리 주소`로 변환하는 작업을 해줄 장치가 필요한데  
그것이 바로 `메모리 관리 장치(Memory Management Unit, MMU)`가 되겠다.

이 방식은 runtime 때 하드웨어적으로 즉, CPU로 해결하는 방식이다. 

MMU를 아래와 같이 추가한다.

![image](https://user-images.githubusercontent.com/64796257/147843816-9107ec11-22a1-40a7-8c9b-09bc75184ae0.png)

- Relocation Register

만약에 논리 주소의 346에 접근하려 한다면 물리 주소에서 접근할 때는 MMU를 이용해서

접근하려는 주소에 14000을 더해 메모리에서는 14346 주소에 접근하도록 하는 방식이다. 

이때 쓰인 레지스터를 `재배치 레지스터(relocation register)`라고 한다.

- Limit Register

위에서 얘기한 대로 A가 3MB, B가 4MB라고 하자. 그런데 B가 load를 통해 접근하려는 주소가 6이라 하자. 

자신의 논리적 주소는 0 ~ 4까지 밖에 없는데  
6을 접근한다는 건 B라는 프로그램이 접근할 수 있는 범위를 넘어서게 된다. 이를 알려주는 게 limit register이다. 

![image](https://user-images.githubusercontent.com/64796257/147843842-ce132b24-685d-4af1-ae04-e6325d781b6b.png)

프로세스가 접근할 수 있는 범위를 넘어가게 되면 addressing error가 일어났다고 알려준다.

### Memory Management 

- Focus (★★)
1) `utilization` : 물리 메모리를 얼마나 아껴쓰는가? ⇒ 어떤 기법을 쓰냐에 따라서 물리 메모리를 쓰는 양이 달라짐  
⇒ 이를 `방해`하는 요인이 `fragmentation`

2) `performance` : 메모리 접근 속도가 얼마나 빠른가? ⇒ 어떤 기법을 쓰냐에 따라 속도가 달라짐  
⇒ 이를 `방해`하는 요인은 `Address translation`, `swapping`이 있다.

이 두 가지를 큰 틀로 잡고 4가지 방식을 살펴볼 것이다.
1) Contiguous allocation ⇒ 앞에서 다룬 방식이다. 원시적인 방식.
2) Segmentation ⇒ 이 방식은 현재 안 쓰는 방식이라고 한다. 그래서 굳이 여기서 정리하지는 않겠다.  
		 ⇒ 결정적인 단점은 프로그램을 `조각`내는 걸 `프로그래머에게 의존`하다보니 이 방식을 제대로 활용하지 않게 된다는 단점 때문에 이 방식을 사용하지 않게 되었다.
3) Paging
4) Demand paging 

#### 1. Contiguous Allocation 

위에서 다룬 원시적인 방법과 똑같다. Contiguous allocation 방식의 근본적인 문제는 다음과 같다.

#### 외부 단편화(External Fragmentation)

![image](https://user-images.githubusercontent.com/64796257/147843869-8d6bd14f-f23d-4412-8205-386cef23cf69.png)

1번 공간을 사용하고 있는 상황에서 크기가 10인 프로세스가 들어오려고 한다.

하지만, 2, 3번 공간이 각각 크기가 4와 6으로 쪼개져 있다 보니 10이라는 공간이 있음에도 프로세스를 저장할 수 없는 문제가 발생한다. 

이 점이 바로 contiguous 방식의 근본적인 문제점이다. 

⇒ 이렇게 조각이 여러 개로 나눠지면서 생기는 문제를 `외부 단편화(External Fragmentation)`라 한다.

#### 내부 단편화(Internal Fragmentation)

⇒ 메모리를 할당했지만 할당한 만큼 메모리를 사용하지 않았을 때 남는 공간이 생기는 문제를 `내부 단편화`라 한다.

이를 해결하기 위한 방법으로 swapping이라는 방법을 생각할 수도 있지만 바람직하지 못한 방법이다. 이유는 아래와 같다.

![image](https://user-images.githubusercontent.com/64796257/147843918-00dc2a7a-129b-4edd-b907-10aa51e15be0.png)

1과 3 부분이 채워진 상황에서 크기가 10인 프로세스를 넣으려고 한다.  
그러면 contiguous 방식에서는 3번에 채워진 프로세스를 2번의 일부로 자리를 옮기면 원래는 사용할 수 없었던 10의 공간을 사용할 수 있게 된다.

하지만, 이 방법은 CPU가 동작하는데 있어서 메모리에 접근하는 데 소요되는 시간은 상당히 크다.

그래서 cpu가 이러한 작업 때문에 오랫동안 할 일을 하지 못하게 되면서 비효율적인 상황이 만들어진다.

이러한 idea를 착안해서 메모리에 공간이 없을 때 메모리에 있는 프로세스를 storage로 옮겼다가 

다시 memory로 가져오는 방식을 `swapping`이라 한다. 

하지만, storage에 접근하면 memory에 접근하는 시간보다 더 많은 시간이 소요된다. 그래서 사실상 이 방식은 사용할 수 없는 방식이다.

정리: `contiguous 방식`은 내/외부 단편화 문제 때문에 utilization이 굉장히 떨어질 수 있다. 
하지만, address translation 방식은 굉장히 단순하기 때문에 performance는 빠르다고 할 수 있다.

### 2. Paging 

: `프레임(frame)` 이라 불리는 같은 크기의 블록을 나눠서 관리하는 방식이다.   
: segmentation은 블록을 나누는 크기가 임의로 정해진다는 점에서 차이점이 있다.

이때, 페이지의 크기는 4KB로 정했다. 

⇒ 이 기법은 `external fragmentation`을 해소할 수 있고 `internal fragmentation`도 최소화 할 수 있다.

하지만, performance 측면에서는 page table이라는 것을 두기 때문에 속도는 2배 가량 느리다.

- 기본적인 paging 방식 

![image](https://user-images.githubusercontent.com/64796257/147843978-59d8f598-9f84-4039-903c-092ed4b52425.png)

논리 메모리에 4 × 4 = 16KB 만큼의 메모리 공간을 할당했다. 

여기에서 물리 메모리에 16KB 만큼의 메모리를 할당해서 논리 메모리에 있던 페이지를 물리 메모리에 저장하려 한다.

이때 어떤 페이지를 어떤 프레임에 넣을지는 페이지 테이블을 통해서 정의해놨다.  
page table[0] = 1 ==> 0번 페이지는 1번 프레임에 저장  
page table[1] = 4 ==> 1번 페이지는 4번 프레임에 저장  
page table[2] = 3 ==> 2번 페이지는 3번 프레임에 저장  
page table[3] = 7 ==> 3번 페이지는 7번 프레임에 저장  

이렇게 정의한 페이지 테이블에 따라서 논리 메모리에서 물리 메모리로 데이터를 저장하면 되겠다.

여기서 페이지 테이블(page table)에서 각각의 페이지를 프레임에 저장하는 과정이 바로 `Address Translation`이 되겠다.

![image](https://user-images.githubusercontent.com/64796257/147844015-9f983095-d27e-4993-8605-72a594b8d630.png)

`페이지 오프셋`이란 페이지 안에서 어디에 위치할 것인지를 나타내는 값이다.  
ex) 오프셋 = 14 ⇒ 페이지 자체가 어디에 있더라도 `해당 페이지의 시작점`에서 `14번째`에 위치한다는 걸 나타낸다. 

그래서 페이지 오프셋은 `12Bits`만 있으면 된다. 왜냐하면, 페이지 크기를 `4KB`로 정하기로 했기 때문에 오프셋 값은 4KB를 전부 표현할 수 있어야 하기 때문이다.  
(4KB = 2²KB = 2² × $2^{10}$ B= 2¹²B)

그러면 페이지 넘버를 표시할 숫자는 20bits만 있으면 된다.

이때 `페이지 오프셋`은 변하지 않고 `페이지 넘버`만 바꾸면서 `address translation`이 이뤄진다.

마치 어떤 느낌이냐면... 7호관 503호가 있다. 이를 7503으로 표현할 수 있다.  
여기서 앞에 있는 숫자인 7을 9로 바꾼다면, 9503. 즉, 9호관 503호를 표현한다. 

만약에 논리 메모리에서 p = 1이고 d = 3라고 한다면...  
내가 접근하고자 하는 데이터가 논리 메모리에 있든 물리 메모리에 있든 

해당 데이터가 속한 페이지 또는 프레임의 시작 주소에서 3만큼 떨어져 있다는 것은 변함이 없다는 점을 이용한다.

논리 메모리에서 p = 1, d = 3는 페이지 1의 시작주소에서 3만큼 떨어진 곳에 위치한 데이터에 접근한다는 의미가 된다.

이때 페이지 1이 저장될 프레임이 5라고 하자. 그러면 실제 주소는 4 × 5 + 3 = 23이 된다.

![image](https://user-images.githubusercontent.com/64796257/147844049-09fe34d5-62a2-4d80-ae56-01b7b2f68853.png)

![image](https://user-images.githubusercontent.com/64796257/147844053-518ff6b5-5483-424f-b342-d09c7bb31baf.png)

ex) `logical memeory`의 맨 윗부분 (a, b, c, d가 있는 부분)  
- logical memory
1) a : 페이지 번호 0 / 오프셋 0  
2) b : 페이지 번호 0 / 오프셋 1   
3) c : 페이지 번호 0 / 오프셋 2  
4) d : 페이지 번호 0 / 오프셋 3  

`페이지 테이블`을 보면 `logical memory`의 `0번 페이지`는 `physical memory`의 `5번 페이지`와 연결했음 

- physical memory 
1) a : 페이지 번호 5 / 오프셋 0  
2) b : 페이지 번호 5 / 오프셋 1   
3) c : 페이지 번호 5 / 오프셋 2  
4) d : 페이지 번호 5 / 오프셋 3  

![image](https://user-images.githubusercontent.com/64796257/147844078-7964fba5-198d-466a-80a6-0fcbe9eb7204.png)

p, d = 0, 100 이면... 0번 페이지에 100번째 data에 접근한다는 의미이다. 

이때 0번 페이지가 어떤 프레임에 할당되었는지는 페이지 테이블을 통해서 확인할 수 있다.  
그렇게 확인한 f값(물리 메모리에서의 프레임 번호)을 가지고 물리 메모리에 접근하면 되겠다.

그래서 d의 값을 나타내는 `페이지 오프셋`이 4KB를 표현할 12bits가 필요한 거다. 

4KB = 2¹²Bytes 이기 때문에 데이터를 1Byte 단위로 저장한다면 저장할 수 있는 위치가 0부터 시작해서 2¹²-1까지 위치한 것이다. 

여기서 d의 값을 3 또는 100이라고 표현한 것도 비슷한 맥락에서 가정한거다. 

0비트 값부터 시작해서 3번째 위치하는 데이터이면 d가 3인거고 100번째 위치하는 데이터이면 d가 100이라는 걸 의미한다. 

- external frag : 해소된다. 논리 메모리와 물리 메모리를 똑같은 크기의 페이지와 프레임으로 나눠서 관리하기 때문에 
  각각의 페이지와 프레임은 페이지 테이블을 통해서 어떤 공간에 들어가야 할 지 다 정해지면서 external frag 문제는 해소가 된다.
  
- internal frag : 하나의 프레임을 4KB라고 했다. 최악의 경우는 전체 4KB에서 1byte만 쓰는 경우가 될 것이다. 그래서 4KB – 1Byte = 4,095Bytes가 남는 경우가 최악의 경우가 된다. 
        
	평균적으로는 frame의 절반 정도를 낭비한다고 한다. 그래서 평균적으로 1/2 frame size 만큼 internal frag가 일어난다고 할 수 있다. 
  
  ⇒ 이런 측면 때문에 utilization 측면에서는 가장 좋은 방식이다.

swapping도 어느 정도 좋아질 수 있다. 모든 메모리를 일정한 크기로 나누면서 정말 최소한의 필요한 프로세스에 대해서만 swapping을 실행하면 되기 때문이다.

■ paging을 설명하면서 놓친 부분 2가지

1) 

![image](https://user-images.githubusercontent.com/64796257/147844162-d6015970-08b9-4560-af8f-10ecd7bdd4a1.png)

물리 메모리에서 페이지를 쪼개놓고 아무 위치에다가 페이지를 배치해도 상관없다고 했다. 이는 `메인 메모리`라는 디바이스가 제공하는 특성 때문에 가능한 일이다.

메모리는 모든 프레임에서 동작하는 속도가 균일하다. 그리고 순서대로 읽을 때나 무작위로 골라서 읽을 때나 역시 똑같은 속도를 가진다. 

그래서 아무 위치에다가 배치해도 상관없다.

2) free frame

![image](https://user-images.githubusercontent.com/64796257/147844173-88fbc25e-6bf1-4dab-992d-3d8d9ef2512a.png)

물리 메모리에서 사용할 수 있는 프레임(free frame)은 `리스트`를 통해서 관리한다. 

앞서 말했듯이 메인 메모리는 모든 영역에서 균일한 기능을 제공하기 때문에 프레임을 사용한다면 리스트에 가장 앞에 있는  
프레임 번호를 사용해서 페이지를 배치하고

다 쓰고 나면 사용했던 프레임 번호를 리스트(free frame list)의 마지막에 집어넣어주면 된다. 이런 식으로 프레임을 관리하고 있다.



















