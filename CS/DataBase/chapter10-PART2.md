
## 03 병행 제어 

### 병행 수행과 병행 제어 

DBMS는 `여러 사용자`가 DB를 `동시에 공유`할 수 있도록 여러 개의 트랜잭션이 동시에 수행되는 `병행 수행(concurrency)`을 지원한다.  
`병행 수행`은 여러 트랜잭션이 `차례로 번갈아` 수행되는 `인터리빙(interleaving)` 방식으로 진행된다.

여기서 문제는 `동시에 같은 데이터`에 `접근`해서 변경연산을 실행하려고 할 때 예상치 못한 문제가 발생할 수 있다. 

그래서 병행 수행을 하더라도 각 트랜잭션이 다른 트랜잭션의 `방해`를 받지 않고 `정확한 수행 결과`를 얻을 수 있도록 `제어`해야 한다.  
이러한 제어를 `병행 제어(concurrency control)`라 한다. 

### 병행 수행의 문제점 

대표적으로 갱신 분실, 모순성, 연쇄 복귀가 있다. 

#### 1. 갱신 분실 

: `하나의 트랜잭션`이 수행한 데이터 변경 연산의 결과를 `다른 트랜잭션`이 `덮어쓰면서` 변경 연산이 무효화되는 것. 

ex) T₁ : 데이터 X에 1000을 더하는 트랜잭션 / T₂ : 데이터 X를 50% 감소시키는 트랜잭션 ⇒ 이 둘이 `병행 수행`되면서 `갱신 분실` 발생

![image](https://user-images.githubusercontent.com/64796257/189005391-c9ecb288-7ea5-48dd-8635-7ff60bd56000.png)

위 그림의 순서대로 따라가보자. 

1) `T₁`이 `X = 3000`을 읽어와서 T₁의 결과로 X는 4000이 되었다. 
2) `T₂`가 `X = 3000`을 읽어와서 T₂의 결과로 X는 1500이 되었다. 

3) T₁의 결과값을 DB에 저장하기 위해서 `write(X)`를 사용했다. 결과값이 4000이었기 때문에 DB에는 `X = 4000`으로 저장된다.
4) T₂의 결과값을 DB에 저장하기 위해서 `write(X)`를 사용했다. 결과값이 1500이었기 때문에 DB에는 `X = 1500`으로 저장된다.

결과적으로 DB에 저장된 X값은 `1500`이 되면서 트랜잭션 `T₁`의 값은 무시되었다. 즉, `트랜잭션 T₁`에 대해 `갱신 분실`이 발생했다. 

그렇다면 두 트랜잭션이 동시에 수행되지 않고 `순차적으로 수행`된다면 결과가 어떻게 달라질까? 

![image](https://user-images.githubusercontent.com/64796257/189006177-99a4b562-1cd2-427e-9b5b-575a49fd8853.png)

`트랜잭션 T₁`의 수행이 먼저 `완료`되고나서 `트랜잭션 T₂`를 수행하면 위 그림과 같이 DB에 있는 데이터 X값은 `2000`이 된다.

이 결과가 두 트랜잭션을 `모두 수행`함으로써 얻고자 했던 값이다. 

`정확한 병행 수행`은 두 트랜잭션을 `동시에 수행`하더라도 갱신 분실 문제가 발생하지 않고 `순차적으로 수행한 것`과 같은 결과값을 얻을 수 있어야 한다.

#### 2. 모순성 

: `하나의 트랜잭션`이 여러 개의 데이터 변경 연산을 실행할 때 `일관성 없는 상태`의 DB에서 데이터를 가져와 연산을 실행함으로써 `모순된 결과`가 발생하는 것이다. 

ex) T₁ : 데이터 X, Y값에 각각 1000을 더하는 트랜잭션 / T₂ : 데이터 X와 Y값을 각각 50%씩 감소시키는 트랜잭션 

![image](https://user-images.githubusercontent.com/64796257/189006615-6df6c4f8-a953-4a47-bf6a-d52ca0b95798.png)

위 그림을 보면 분명 `T₁`은 `데이터 X, Y값에 각각 1000을 더하는` 연산을 둘 다 한꺼번에 진행해야 하는데 

`T₂`로 인해서 `T₁`이 `X에 실행할 연산`과 `Y에 실행할 연산`이 나눠지면서 문제가 발생했다. 

올바르게 실행되려면 아래와 같은 결과가 나와야 한다.

![image](https://user-images.githubusercontent.com/64796257/189006885-2f5faac8-ae50-4d91-80fa-9e75b09dc338.png)

#### 3. 연쇄 복귀 

: A 트랜잭션이 `완료되기 전`에 `장애`가 발생해서 rollback 연산을 수행하면,   
  A 트랜잭션이 `장애 발생 전에 변경한 데이터`를 가져가 변경 연산을 실행한 B 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것

ex) T₁ : 데이터 X, Y값에 각각 1000을 더하는 트랜잭션 / T₂ : 데이터 X와 Y값을 각각 50%씩 감소시키는 트랜잭션 

![image](https://user-images.githubusercontent.com/64796257/189008214-01b638c9-0b40-42be-8c38-8fd1210b8bb2.png)

`T₁`의 일부를 다 실행했을 때 저장한 X값 4000을 `T₂`가 가져다 사용했다.  

이제 `T₁`의 나머지 트랜잭션 부분도 실행해야 하는데 실행 중에 `장애가 발생`했다. 

그래서 `T₁`에 다가 rollback 연산을 실행해야 하는데 `T₂`는 이미 모든 연산을 완료한 상태라서 rollback 연산을 실행할 수 없다. 이러한 문제를 `연쇄 복귀`라 한다. 

올바르게 실행되려면 아래와 같은 결과가 나와야 한다.

![image](https://user-images.githubusercontent.com/64796257/189008724-d5a9cb17-1ae2-4251-8c2d-af73c9bdf372.png)

### 트랜잭션 스케쥴 

- 직렬 스케쥴 

: 작업들이 왔다갔다 하지 않고(`인터리빙`하지 않고) 각 트랜잭션 별로 연산들을 순차적으로 실행시키는 것 

⇒ 직렬 스케쥴에 따라 여러 트랜잭션들을 수행하면 `정확한 결과`를 얻을 수는 있지만   
   결국에는 각 트랜잭션들을 `독립적으로 수행`하는 거라서 `병행 수행`이라 할 수 없다. 그래서 일반적으로는 잘 쓰이지 않는다. 

- 비직렬 스케쥴 

: 작업들이 왔다갔다 실행되면서 트랜잭션들을 `병행해서 수행`하는 것 

⇒ 하지만, 앞서 봤던 병행 수행의 문제점인 `갱신 분실`, `모순성`, `연쇄 복귀` 등의 문제가 발생할 수 있어서 최종 수행 결과의 정확성을 보장할 수 없다. 

- 직렬 가능 스케쥴 

: `직렬 스케쥴`에 따라 수행한 것과 같이 `정확한 결과`를 생성하는 `비직렬 스케쥴`이다. 

즉, `비직렬 스케쥴` 중에서도 `정확한 결과`를 생성해내는 비직렬 스케쥴을 `직렬 가능 스케쥴`이라 한다. 

하지만, 트랜잭션 스케쥴이 `직렬 가능 스케쥴`인지 판단하는 건 쉽지 않다.  
- 다수의 트랜잭션을 대상으로 `비직렬 스케쥴`을 찾아내는 것도 어렵고
- 하나씩 수행해보면서 `직렬 스케쥴`과 같은 결과가 나오는지 비교하는 것도 어렵기 때문이다. 

그래서 대부분의 DBMS는 직렬 가능 스케쥴인지 검사하기 보다는 `직렬 가능성`을 보장하는 `병행 제어 기법`을 사용한다. 

### 병행 제어 기법 

: 여러 `트랜잭션`들을 `병행 수행`하면서도 정확한 결과를 얻을 수 있는 `직렬 가능성`을 보장받기 위해 사용한다. 

병행 제어 기법의 기본 원리는 다음과 같다.
```
모든 트랜잭션이 따르면 직렬 가능성이 보장되는 나름의 규약을 정의 ⇒ 트랜잭션들이 이 규약을 따르도록 한다.
```

때문에 `트랜잭션 스케쥴`이 `직렬 가능 스케쥴`인지 검사할 필요가 없다.  
`스케쥴 내`의 `모든 트랜잭선`이 병행 제어 기법에서 정의한 규약을 따른다면 `해당 스케쥴`은 `직렬 가능성`을 보장할 수 있다. 

가장 많이 사용되는 방법인 `로킹 기법`을 중심으로 자세하게 살펴보자. 

#### 로킹 기법의 개념 

`로킹 기법`은 병행 수행되는 트랜잭션들이 `동일한 데이터`에 `동시에 접근하지 못하도록` lock과 unlock이라는 2개의 연산을 이용해 제어한다.

- 기본 원리  
```
한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지 
해당 데이터에 다른 트랜잭션이 접근하지 못하도록 "상호 배재(Mutual Exclusion)"하여 직렬 가능성을 보장
```

- lock 연산 : 트랜잭션이 사용할 `데이터에 대한 독점권`을 가지기 위해 사용
- unlock 연산 : 트랜잭션이 데이터에 대한 독점권을 `반납`하기 위해 사용

⇒ 이 두 연산을 이용해 다른 트랜잭션의 방해를 받지 않고 데이터에 `독접적으로 접근`할 수 있게 된다. 

- 기본 로킹 규약 

1) 로킹 기법을 사용해서 `트랜잭션`이 `DB`에 있는 `데이터에 접근하는 연산`을 실행할 때 먼저 `해당 데이터`에 대한 `lock 연산`을 실행해서 `독점권`을 획득한다.  
ex) read, write ⇒ 해당 연산을 실행하기 전에 `lock 연산`을 실행해야 한다. 

2) 트랜잭션이 `lock 연산`을 통해 `독점권을 획득한 데이터`에 대한 모든 연산을 수행하고 나서 `unlock 연산`을 이용해 `독점권을 반납`해야 한다. 

3) 그러면, 다른 트랜잭션이 해당 데이터에 접근할 수 있다. 

- 로킹 단위 : `lock 연산`을 실행하는 대상 데이터의 크기 

`전체 데이터베이스`에 `lock 연산`을 실행하면 `제어`가 간단하지만 DB에 `하나의 트랜잭션`만 수행되는 거라 병행 수행이라 할 수 없다.  
가장 작은 단위인 `속성`에 `lock 연산`을 실행하면 독점하는 범위가 좁아 `많은 수의 트랜잭션`이 `병행 수행`될 수 있지만 `제어`가 복잡하다는 단점이 있다.

| 로킹 단위 크기 | 상황 | 
| --- | --- | 
| 클 때 | `병행성`은 ↓, `제어`가 쉬움 | 
| 작을 때 |  `병행성`은 ↑, `제어`가 어려움 | 

트랜잭션이 데이터를 변경시키는 `write 연산`을 실행할 때는 다른 트랜잭션이 방해하지 못하도록 `독점권`을 가져야 한다.   
하지만, 단순히 데이터를 읽어오는 `read 연산`의 경우 다른 트랜잭션이 같은 데이터에 `동시에 read 연산`을 실행해도 문제가 생기지 않는다.

때문에 `read 연산`과 같이 `하나의 데이터`에 동시에 실행해도 문제가 되지 않은 연산은 `동시 실행을 허용`하도록 lock 연산을 구분할 수 있다. 

| 연산 | 설명 | 
| --- | --- | 
| 공용 lock | 데이터에 대한 사용권을 `여러 트랜잭션`이 함께 가질 수 있음 ex) read | 
| 전용 lock | 전용 lock 연산을 실행한 트랜잭션만 해당 데이터에 대한 `독점권`을 가질 수 있음 ex) write | 

물론 `기본 로킹 규약` 만으로는 트랜잭션의 `직렬 가능성`을 완벽히 `보장할 수는 없다`.

ex) T₁ : 데이터 X, Y값에 각각 1000을 더하는 트랜잭션 / T₂ : 데이터 X와 Y값을 각각 50%씩 감소시키는 트랜잭션 

![image](https://user-images.githubusercontent.com/64796257/189014424-cc425d7f-d18b-4666-9a84-401c7d79e6bb.png)

분명 `로킹 규약` 대로 `read`와 `write` 연산을 수행하기 전에 `lock 연산`을 실행하고  
`read`, `write` 연산 실행이 끝나면 `unlock 연산`을 실행해서 독점권을 반납했다. 

하지만, 위에서 보았듯이 직렬 스케쥴 방식대로 `T1`을 수행하고 `T2`를 수행했을 때 X와 Y의 결과값은 모두 2000이었고  
`T2`를 수행하고 `T1`을 수행했을 때 X와 Y의 결과값은 모두 2500이었다. 

두 개의 직렬 스케쥴의 결과와 같지 않기 때문에 위 스케쥴은 `직렬 가능성`이 없다. 

이러한 문제가 발생한 이유는... 

`트랜잭션 T₁`이 데이터 X에 대해 너무 빨리 `unlock 연산`을 실행해서 `트랜잭션 T₂`가 일관성 없는 데이터에 접근했기 때문이다. 

즉, `트랜잭션 T₂`가  
`트랜잭션 T₁`이 변경한 이후의 `데이터 X`에 접근하고  
`트랜잭션 T₁`이 변경하기 전의 `데이터 Y`에 접근하면서 `모순된 결과`가 생성된 것이다. 

따라서, 트랜잭션 스케쥴이 `직렬 가능성`을 보장하려면 기본 로킹 뿐만 아니라 lock과 unlock을 실행하는 시점에 대한 `새로운 규약`이 추가로 필요하다. 

#### 2단계 로킹 규약 (2PLP; 2 Phase Locking Protocol) 

트랜잭션 스케쥴의 모든 트랜잭션이 `2단계 로킹 규약`을 준수하면 해당 스케쥴은 `직렬 가능성`이 보장된다.  
2단계 로킹 규약을 따르려면 모든 트랜잭션이 `lock`과 `unlock` 연산을 다음과 같이 `2단계`로 나누어 실행해야 한다.

1) 확장단계 : 트랜잭션이 `lock 연산`만 `실행` & `unlock 연산`은 `실행 X`
2) 축소단계 : 트랜잭션이 `lock 연산`은 `실행 X` & `unlock 연산`만 `실행`

처음에는 `확장단계`로 들어가서 `lock 연산`만 실행 ⇒ unlock 연산을 실행하고 싶을 때 `축소 단계`로 들어가 `unlock 연산`만 실행 

ex) 트랜잭션 T1, T2가 `2단계 로킹 규약`을 준수해서 `직렬 가능성`을 보장함

![image](https://user-images.githubusercontent.com/64796257/189015992-3756f651-cf17-4752-8583-d585ffb8a1e9.png)

하지만, `교착 상태(deadlock)`에 빠질 수 있다. 

`교착 상태`란 트랜잭션들이 상대가 독점하고 있는 데이터에 `unlock 연산`이 실행되기를 서로 `대기`하면서 트랜잭선의 수행을 중단하고 있는 상태를 말한다.

교착 상태는 처음부터 발생하지 않도록 하거나 발생했을 때 빠르게 탐지하여 필요한 조치를 취해야 한다.


























