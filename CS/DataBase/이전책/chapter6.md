## 25강

![image](https://user-images.githubusercontent.com/64796257/148230181-0b0f268f-4414-4eb9-a921-c23ad746599a.png)

처음에는 데이터베이스가 당연히 비어있다. 여기에 테이블, 뷰, 인덱스, 프로시저 등의 데이터베이스 객체를 작성해서 데이터베이스를 구축한다.

이번 장에서는 데이터 베이스 객체를 작성하거나 삭제하는 등 관리 방법에 대해서 알아보려 한다.

### 1. 데이터베이스 객체 

데이터베이스 객체 : 테이블, 뷰, 인덱스 등 데이터베이스 내에서 정의하는 모든 것들

여기서의 `객체`는 Java나 C++에서 사용하는 `객체`와는 다른 용어다. 데이터베이스에서의 객체는 `데이터베이스 객체`를 의미한다.

객체는 데이터베이스 내에 실체를 가지는 어떤 것을 말한다. 객체의 종류에 띠리 데이터베이스에 저장되는 내용도 달라진다.

이 책의 앞장 에서 다룬 객체는 `테이블`이다. 테이블은 `행`과 `열`이 저장되어 있다.

반면, SELECT, INSERT 와 같은 명령어들은 실체가 없기 때문에 객체라고 할 수 없다.

![image](https://user-images.githubusercontent.com/64796257/148230903-7af19efb-2c6a-4273-93f9-22c05dfd0b04.png)

객체는 이름을 가지는데 데이터베이스 내에서는 이름이 서로 겹치면 안 된다. 

객체 말고도 테이블의 열, SELECT 명령에도 이름을 붙일 수 있지만 이들은 객체가 아니다. 

이름을 붙일 때는 다음과 같은 제약사항을 따른다.
- 기존 이름이나 예약어와 중복하지 않는다.
- 숫자로 시작할 수 없다
- 언더스코어(_) 이외의 기호는 사용하지 않는다.
- 한글을 사용할 때는 큰 따옴표(MySQL에서는 백 슬래시)를 사용한다.
- 시스템이 허용하는 길이를 초과하지 않는다.

### 2. 스키마 

데이터베이스 객체는 스키마라는 그릇 안에 만들어진다. 객체의 이름이 같아도 스키마가 서로 다르면 상관없다. 

![image](https://user-images.githubusercontent.com/64796257/148231666-fc7855d5-00ce-40c4-ae66-a2b81c443a54.png)

때문에 데이터베이스 객체는 `스키마 객체`라고 불리기도 한다.  
실제로 데이터베이스에 테이블을 작성해서 구축해나가는 작업을 `스키마 설계`라고 부른다.

이때 스키마는 SQL 명령의 DDL을 이용해서 정의한다.

MySQL에서는 CREATE DATABASE 명령으로 작성한 `데이터베이스`가 스키마가 된다. 

테이블과 스키마는 무엇인가를 담는 그릇 역할을 한다는 점에서 비슷한다.

테이블 안에는 `열(column)`을 정의할 수 있고 스키마 안에는 `테이블`을 정의할 수 있다.  
각각의 그릇 안에서는 중복하지 않도록 이름을 지정한다.

이처럼 이름이 충돌하지 않도록 기능하는 그릇을 `네임스페이스(namespace)`라고 부르기도 한다.

## 28강 인덱스 구조

인덱스는 데이터베이스 객체 중 하나이다. 인덱스란 무엇이고 그 역할과 구조는 어떻게 이루어졌는지 살펴보자.

![image](https://user-images.githubusercontent.com/64796257/148299859-5fdc5fb1-1317-4b0d-8a21-aedbd3037a67.png)

테이블에서 인덱스를 작성할 수 있는데 인덱스를 지정하면 어떤 점이 좋고 그러한 효과를 얻을 수 있는 이유에 대해서 살펴보자.

### 인덱스 

인덱스는 테이블이 붙여진 `색인`이다. 인덱스의 역할은 `검색 속도의 향상`이다. 

여기서 검색이란 SELECT 명령에 WHERE 구로 조건을 지정하고 그에 일치하는 행을 찾는 일련의 과정을 말한다. 검색은 탐색이라고도 불린다.

테이블에 인덱스가 지정되어 있다면 효율적으로 검색할 수 있어서 WHERE로 조건이 지정된 SELECT 명령의 처리 속도가 빨라진다.

책의 목차와 색인과 같이 인덱스의 구조도 마찬가지다.  
데이터베이스의 인덱스에는 검색을 위해 사용하는 키워드와 이에 대응하는 데이터 행(row)의 장소가 지정되어 있다.

![image](https://user-images.githubusercontent.com/64796257/148300411-25b0b3f7-2647-4d55-838f-97cdeee733d3.png)

인덱스는 테이블과는 별개로 독립된 데이터베이스 객체로 작성된다. 

하지만, 인덱스 자체로는 아무런 의미가 없다. 목차밖에 없는 책은 없듯이 인덱스는 테이블에 의존하는 객체라 할 수 있다. 

그래서 대부분의 DB에서는 테이블을 삭제하면 인덱스도 같이 삭제된다.

### 검색에 사용하는 알고리즘 

- full table scan : 인덱스가 지정되지 않은 테이블을 검색할 때는 이 방법을 사용한다. brute force를 생각하면 된다.  
그래서 데이터의 양이 많을 수록 처리 속도가 늦어진다.

- 이진 탐색(binary search) : 아는 내용이라 생략 

⇒ 이진 탐색은 대량의 데이터를 검색할 때 빠른 속도를 제공하지만 데이터가 정렬되어 있어야 사용할 수 있다는 한계점은 분명하다.

하지만, 테이블 내의 행을 언제나 정렬된 상태로 두는 것은 힘든 작업이다. 

일반적으로 테이블에 대해 인덱스를 작성하면 테이블 데이터와 별개로 인덱스용 데이터가 저장장치에 만들어진다.  
이때, `이진 트리(binary tree)` 라는 데이터 구조로 작성된다. - 이진 트리는 아는 내용이니까 생략

### 유일성

이진 트리에서는 중복된 값을 여러 개 만들 수 없다는 `키 값`에 대한 `유일성`이라는 특징이 있다. 

그렇기 때문에 같은 키가 여러 개 있는 경우에 대해서는 고려하지 않아도 된다.

## 29강 인덱스 작성과 삭제

그렇다면 인덱스를 실제로 어떻게 작성하는지에 대해서 살펴보도록 하자.

- 인덱스 작성과 삭제 

![image](https://user-images.githubusercontent.com/64796257/148302248-9f2930fc-84fe-4bdd-8aa9-a6db2cfc39fa.png)

인덱스는 DB의 객체 중 하나로 DDL(Data Definition Language; 데이터 정의 언어)을 사용해서 작성하거나 삭제한다.  
표준 SQL에는 CREATE INDEX 명령이 없다. 인덱스를 DB 제품에 의존하는 선택적인 항목으로 취급하기 때문이다.

하지만, 대표적인 DB 제품에는 모두 인덱스 구조가 도입되어 있고 비슷한 관리 방법으로 인덱스를 다루고 있다.

### 인덱스 작성 - CREATE INDEX

CREATE INDEX 명령으로 인덱스를 만든다.  
인덱스에 이름을 붙여 관리하는데 `DB의 객체`가 될지 `테이블의 열`처럼 취급될지는 DB제품에 따라 다르다.

Oracle이나 DB2에서는 인덱스를 `스키마 객체`로 취급한다. 그래서 스키마 내에서 이름이 중복되면 안된다.

SQL Server나 MySQL에서 인덱스는 `테이블 내 객체`로 취급된다. 그래서 테이블 내에서 이름이 중복되면 안된다.


인덱스를 작성할 때 해당 인덱스가 `어느 테이블`의 `어느 열`에 관한 것인지 지정할 필요가 있다. 이때 열은 복수로 지정할 수도 있다.  
인덱스의 namespace가 DB 제품마다 다르다는 것에 주의하면 문법은 그리 어렵지 않다.

- 문법 
``` MySQL 
  CREATE INDEX 인덱스이름 ON 테이블이름(열이름1, 열이름2, ...)
```

ex. sample62라는 테이블의 no 열에 isample65 라는 인덱스를 작성한다. 
``` MySQL 
  CREATE INDEX isample65 ON sample62(no);
```

인덱스를 작성한다는 건 저장장치에 탐색용 데이터가 만들어지는 것이기 때문에  
테이블의 행이 많으면 많을수록 시간도 많이걸리고 저장공간도 많이 소비하게 된다.

### 인덱스 삭제 - DROP INDEX 

인덱스는 DROP INDEX 명령으로 삭제한다. DROP 할 때는 다른 객체와 동일하게 인덱스 이름만 지정하면 된다. 

다만 테이블 내의 객체로서 작성한 경우에는 테이블 이름도 같이 지정해야 한다.(이때, 인덱스로 구성한 열을 지정할 필요는 없다)

- 문법 
``` MySQL 
  DROP INDEX 인덱스이름 
  
  # 스키마 객체인 경우
```

``` MySQL 
  DROP INDEX 인덱스이름 ON 테이블이름
  
  # 테이블 내 객체인 경우
```

인덱스는 테이블에 의존하는 객체이기 때문에 DROP TABLE로 테이블을 삭제하면 테이블에 작성된 인덱스도 같이 삭제된다.

ex) 위에서 작성한 인덱스를 삭제하겠다. 

⇒ 인덱스 isample65를 삭제한다. 그런데 MySQL은 인덱스를 테이블 내 객체로 취급하기 때문에 테이블 이름인 sample62도 같이 작성해야 한다.

``` MySQL
  DROP TABLE isample65 ON sample62;
```

이와 같이 인덱스를 작성하면 `검색`이 빨라진다. 

작성한 인덱스의 열을 WHERE 구로 조건을 지정해서 SELECT 명령으로 검색하면 처리속도가 향상된다. (물론, 인덱스가 모든 SELECT 명령에 적용되지는 않는다)

반면, INSERT 명령의 경우 인덱스를 update해야 하는 처리가 늘어나기 때문에 INSERT의 처리속도는 조금 떨어진다.

SELECT 명령 사용에 대해서 살펴보자.

- 상황 
``` MySQL
  CREATE INDEX isample65 ON sample62(a); 
  
  # isample65라는 인덱스를 생성. 
  # 해당 인덱스는 sampel62라는 테이블에 a 열에 지정한 것이다.
```

WHERE 구에 a 열에 대한 조건식을 지정한 경우 SELECT 명령은 인덱스를 사용해 빠르게 검색할 수 있다.
``` MySQL
  SELECT * FROM sample62 WHERE a='a'; 
  
  # sample62라는 테이블의 a열에서 'a'라는 데이터를 검색하고 싶다.
```

위와 같이 SELECT 명령어를 사용하면 된다.  
그런데 WHERE 구의 조건식에서 a 열이 사용되지 않는다면 SELECT 명령어는 isample65라는 인덱스를 이용할 수 없다.

### EXPLAIN

인덱스 작성을 통해 쿼리의 성능 향상을 기대할 수 있다. 이때 실제로 인덱스를 사용해 검색하는지 확인하기 위해서 `EXPLAIN 명령`을 사용한다.

- 문법 
``` MySQL
  EXPLAIN SQL명령
```

EXPLAIN 명령은 간단하다. EXPLAIN에 뒤이어 확인하고 싶은 SQL 명령을 지정하면 된다.  
다만, 여기서 지정한 SQL 명령은 실제로 실행되지는 않는다. 어떤 상태로 실행되는지 설명할 뿐이다. (MySQL의 경우에는 상황에 따라 SQL 명령의 일부분을 실제로 실행하는 경우도 있음)

EXPLAIN은 표준 SQL에는 존재하지 않는 DB 제품 의존형 명령이다. 하지만 어떤 DB 제품이라도 이와 비슷한 명령을 지원한다.

- 예제 

![image](https://user-images.githubusercontent.com/64796257/148311110-5b5fc0b4-cccf-4d83-b23c-57277d4ed8c9.png)

sample62라는 테이블에 a라는 열(column)이 있다. 그리고 isample65라는 인덱스가 작성되어 있다.

EXPLAIN의 뒤에서 작성된 SELECT 명령은 a 열의 값을 참조해서 검색하므로 isample65을 사용해서 검색한다.

여기서 possible_key는 사용할 수 있는 인덱스를 표시하고 key는 사용된 인덱스를 표시한다

즉, 여기서는 isample65라는 인덱스를 사용하고 있고 isample65라는 인덱스를 사용했다는 것을 나타낸다.

이번에는 WHERE 조건을 바꿔서 살펴보자. 

![image](https://user-images.githubusercontent.com/64796257/148311473-f678fda5-c7a3-4635-9ed8-a2882a996ae6.png)

인덱스로 사용한 a열을 사용하지 않았다.

그래서 possible_key 즉, 사용할 수 있는 인덱스는 없기 때문에 NULL이라고 표시되었고  
key 즉, 사용된 인덱스 역시 없기 때문에 NULL이라고 표시되었다.

### 최적화 

SELECT 명령을 실행할 때 인덱스의 사용 여부를 선택한다는 것을 알았다. 이는 DB 내부의 최적화에 의해 처리되는 부분이다.

내부 처리에서는 SELECT 명령을 실행하기에 앞서 실행계획을 세운다. 

실행계획에서는 `인덱스가 지정된 열이 WHERE 조건으로 지정되어 있으니 인덱스를 사용하자`와 같은 처리가 이뤄진다.  
EXPLAIN 명령은 이러한 실행계획을 확인하는 명령이다.

실행계획에서는 `인덱스의 유무`뿐만 아니라 `인덱스를 사용할 것인지 여부`에 대해서도 DB 내부의 최적화 처리를 통해 판단한다.  
이때 판단 기준으로 `인덱스의 품질`도 고려한다.

ex) '예', '아니오'라는 값만 가지는 열이 있다고 하자.

해당 열은 인덱스를 구성해도 이진트리로써 별로 좋은 구조를 가지지 못한다. 단순한 리스트와 별다른 차이가 없기 때문에 이진 트리의 효율성을 기대할 수 없다. 이러한 인덱스의 품질을 고려해서 실행계획이 세워진다.
