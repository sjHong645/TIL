## 34강 데이터베이스 설계

![image](https://user-images.githubusercontent.com/64796257/148313434-880f3f14-2dcb-4918-bb35-ffbc4acdc884.png)

설계도를 작성하는 건 굉장히 어렵다. 여기서는 DB 설계의 개념및 설계도를 읽는 방법 등에 관해서 알아보려 한다.

그리고 시스템 개발 현장에서 자주 사용되는 트랜잭션(transaction)에 대해서도 다뤄보자.

### 데이터베이스 설계

DB를 설계한다는 건 DB의 스키마 내에 테이블, 인덱스, 뷰 등의 DB 객체를 정의하는 것을 말한다. 스키마 내에서 정의한다는 뜻에서 `스키마 설계`라고 불리기도 한다. 

DB 설계의 주된 내용은 테이블의 이름이나 열, 자료형을 결정하는 것이다.

'이 테이블은 이 열을 이용해서 저쪽 테이블과 연결한다'와 같이 테이블 간의 관계를 생각하면서 여러 테이블을 정의하고 작성한다.

- 논리명과 물리명 

테이블을 설계할 때 테이블 정의서나 설계도 등의 문서를 작성하는 경우가 많다. 일반적으로 다음과 같은 양식을 사용한다.

![image](https://user-images.githubusercontent.com/64796257/148313972-7529db37-b615-4859-a5c8-2349fa15dbae.png)

DESC 명령에 따라 표시되는 결과를 그대로 옮겨적은 것이라 봐도 무방하다. 이외에 어느 열이 기본키 인지를 지정하는 경우도 있다.

테이블을 설계할 때 `테이블 이름`이나 `열 이름`을 지정하는데 하나의 테이블에 대해 `2개의 이름`을 지정할 수 있다.

- 물리명(Name) : DB에 사용될 이름  
⇒ DB 시스템 규칙에 따라 길이에 제한이 있거나 공백문자를 사용할 수 없는 등의 제약이 있다.  
⇒ 그래서 일상적인 단어로 이름을 짓는데 한계가 있다. 그리고 영어를 이용해서 이름을 지정한다.

- 논리명(Logical Name) : 테이블의 설계상 이름  
⇒ 물리명은 여러 제약이 있다보니 제대로 의미가 전달되지 않을 수 있다.
⇒ 이러한 부분을 보완하기 위해서 설계상의 이름으로 사용하는 것이 `논리명`이다. 

때문에 `물리명`과 `논리명`이 함께 기재된 설계도와 정의서가 있다.

![image](https://user-images.githubusercontent.com/64796257/148314538-c0801d76-8409-4ee4-8c42-a4edffb1ac2c.png)

### ER다이어그램 

테이블을 설계할 때 테이블 간의 관계를 명확히 하기 위해서 설계도를 작성하는 경우가 있다. ER다이어그램이 대표적이다.

ER의 E는 Entity / R은 Relationship을 뜻한다. ER 다이어그램은 개체(Entity)간의 관계(Relationship)를 표현한 것이다.  
이와 같은 ER다이어그램은 관계형 데이터베이스 외의 대상에 대해서도 사용된다.

엔티티(Entity)는 테이블 또는 뷰를 의미한다. ER다이어그램에서 개채는 사각형으로 표시한다. 사각형의 상단에는 이름을 적고 하단에는 객체의 속성을 표기한다.  
여기서 속성은 테이블의 열을 의미한다. 

![image](https://user-images.githubusercontent.com/64796257/148315995-ddcd0a90-f194-4242-8bdb-be2b4cd2c5ce.png)

개체와 개체가 서로 연결되는 경우에는 선으로 이어서 표현한다. 

![image](https://user-images.githubusercontent.com/64796257/148316069-4bb6db0d-7e46-47ad-8511-b575eb0c8914.png)

관계(Relationship)를 표시할 때 서로 몇 개의 데이터 행과 연관되는지, 즉 몇 대 몇의 관계를 가지는지를 숫자나 기호로 나타낸다.  
가장 기본적으로 `일대일(1:1)`, `일대다(1:多)`, `다대다(多:多)`가 있다.

ER다이어그램의 연계는 DB에서는 외부키 제약으로 지정되는 경우가 있다.

'설계상 이렇게 되어 있다'를 나타내는 것이 ER다이어그램의 역할이다.

## 35강 정규화 

정규화 : 테이블을 올바른 형태로 변경하고 분할하는 것 

![image](https://user-images.githubusercontent.com/64796257/148316498-34b72481-ba6d-476b-9a8b-ebe64c7e1439.png)

정규화란 DB의 테이블을 규정된 올바른 형태로 개선해나가는 것을 의미한다. 정규화는 DB의 설계단계에서 이뤄진다. 
경우에 따라서 기존 시스템을 재검토할 때 정규화하는 경우도 있다.

### 정규화 

예제를 통해서 정규화에 대해서 알아보자. 

쇼핑 사이트 주문처리 시스템을 구축했다. 이에 대한 주문 데이터를 작성하면 아래와 같다.

![image](https://user-images.githubusercontent.com/64796257/148316919-2d8acb4b-a029-466b-ac3f-d5af84ec9c41.png)

위 데이터를 정규화해서 다듬으려한다. 상품은 상품코드를 이용해서 다루기로 하자.

`0001 ○○ 1개`의 의미는 상품코드가 0001인 상품 ○○를 1개 주문했다는 뜻이다.

이렇게 대충 만들어진 데이터를 정규화해서 DB의 테이블로 만들어보자.

### 제1 정규형

#### 제1 정규화 - 1단계
관계형 데이터베이스의 테이블은 하나의 셀에 하나의 값만 저장할 수 있다는 제약이 있다.  

그래서 기존테이블의 주문상품에 있는 정보를 `상품코드`, `상품명`, `개수`를 담는 3개의 열로 나눠야 한다.

![image](https://user-images.githubusercontent.com/64796257/148317332-c94c4096-87c9-44b3-8c02-8d5117b290b2.png)

위와 같이 구분하면 하나의 셀에 하나의 값만 저장되면서 테이블화 될 수 있다. 테이블의 이름은 주문이라 하겠다.

주문상품 데이터를 상품코드와 개수로 분할함에 따라 열이 2개 추가되었고 행도 늘어났다. 

이와 같이 하나의 셀에 하나의 값만 저장할 수 있도록 하고  
반복되는 부분을 세로 방향(행 방향)으로 늘려나간것이 제1 정규화의 제1 단계이다.

#### 제1 정규화 - 2단계

제1 정규화에서는 `중복을 제거하는 테이블의 분할`도 이뤄진다.  
예를 들면 한 번의 주문으로 여러개의 상품을 주문할 때 주문번호, 날짜, 성명, 연락처가 동일한 값을 가지는 행이 여러 개 존재할 수 있다.

이때 동일한 값을 가지는 행이 여러 개 존재하지 않도록 하나로 정리하자.

![image](https://user-images.githubusercontent.com/64796257/148317786-876474a8-5ed1-4221-8ca4-68b8e7660e3d.png)

먼저 주문 테이블을 `주문 상품 테이블`과 `주문 테이블`로 나눈다. 

`주문 테이블`은 주문번호, 날짜, 성명, 연락처로 구성되어 있다.  
`주문상품 테이블`은 상품코드, 상품명, 개수로 구성되어 있다. 여기에 `주문 테이블`과 결합할 수 있도록 주문 번호 열을 추가했다.

이렇게 정리하면 반복되는 부분이 하나로 깔끔하게 정리되었다. 만약에 주문 데이터가 변경된다면 한 군데만 수정하면 된다.

이렇게 분할을 하고 나면 

`주문 테이블`에서는 주문번호가 중복되지 않기 때문에 `기본키`로 지정할 수 있다.  
`주문상품 테이블`에서는 주문번호와 상품코드를 한데 묶어 `기본키`로 지정할 수 있다.

이처럼 제1 정규화는 반복되는 부분을 찾아서 테이블을 분할하고 기본키가 될 열을 작성하는 과정이다.

### 제2 정규형

제2 정규화는 제1 정규화처럼 데이터가 중복되는 부분을 찾아서 테이블을 분할해 나간다.

이때 기본키에 의해 특정되는 열과 그렇지 않은 열로 나누는 것으로 정규화가 진행된다. 주문 상품 테이블을 다시 살펴보자.

![image](https://user-images.githubusercontent.com/64796257/148318930-fae10839-0f5b-4498-9108-0d966dc51315.png)

주문상품 테이블의 기본키는 주문번호와 상품코드의 2개의 열로 이뤄져있다. 

첫 번째 행을 보면 주문번호 1에 상품코드가 0001인 상품 주문량은 총 1개라는 것을 알 수 있다.  
즉, `개수`열은 기본키가 결정되고나면 특정할 수 있는 열이다. 

한편, `상품명`은 주문번호와 관계없이 상품코드만으로 특정할 수 있다. 상품코드는 기본키의 일부이지만 단독으로 기본키의 역할을 할 수는 없다.

그렇다면 다음과 같이 테이블을 분할할 수 있다. 이 테이블의 이름은 `상품`이라 하겠다.

![image](https://user-images.githubusercontent.com/64796257/148319324-1d883a17-5561-405f-97cf-966bdc2736ce.png)

`상품 테이블`은 상품코드만으로 기본키를 지정했다. 

이와 같이 부분 함수종속성을 찾아내서 테이블을 분할한 것이 제2 정규화이다. 

### 제3 정규형

제3 정규화 역시 중복된 부분을 찾아서 테이블을 분할하는 방법이다. 여기서는 기본키 이외에 부분에서 중복이 없는지를 조사한다.

![image](https://user-images.githubusercontent.com/64796257/148319489-644f1f11-2e79-467b-b0c8-00445987a21b.png)

분할하기 전의 `주문 테이블`을 보면 데이터가 중복되어 있다. 같은 사람이 여러 번 주문하는 경우가 있기 때문이다.

이때 `주문 테이블`에서 이름을 기준으로 연락처를 특정할 수 있다. (여기서 이름은 기본키와 관계가 없다)

그렇게 이름과 연락처를 묶어서 만든 테이블에 `고객`이라는 이름을 붙였다. 여기서는 이름을 기본키로 지정하면 동명이인이 있을 수 있기 때문에 고객번호를 기본키로 지정해서 `고객 테이블`을 작성했다.

정규화한 이후의 테이블을 보면 다음과 같다.

![image](https://user-images.githubusercontent.com/64796257/148319857-28ab5101-15cc-423c-9e15-cd5454158e5f.png)

이처럼 정규화를 통해 테이블을 분할해 나간다. 분할할 때는 서로 결합할 수 있도록 기본키를 추가해서 분할한다.

테이블간의 연계를 ER다이어그램으로 표현하면 아래와 같다. 

![image](https://user-images.githubusercontent.com/64796257/148319947-b40dbefc-3cca-4e0a-bd80-1f572f89c452.png)

선 : 테이블 간의 relationship을 의미한다. 

주문상품 테이블과 상품 테이블의 관계 : 주문상품 쪽이 多 / 주문상품 쪽이 1 로 다:1 로 표시되어 있다.

이는 `주문상품 테이블` 쪽의 데이터에서 `상품 테이블`을 보면  
`주문상품 테이블`의 주문번호와 상품코드를 가지고 `상품 테이블`의 상품코드 하나를 특정하기 때문이다.

반대로 `상품 테이블` 쪽에서 `주문상품 테이블`을 보면  
하나의 상품이 `주문상품 테이블`에서 여러 번 주문되어서 여러 개의 행이 존재하는 관계를 볼 수 있다.

FK = 외부키 

### 정규화의 목적 

정규화에서는 중복하거나 반복되는 부분을 찾아서 테이블을 분할하고 기본키를 작성해 사용하는 것을 기본 개념으로 삼는다.  
즉, **하나의 데이터는 한 곳에 있어야 한다**는 규칙에 근거한다.

하나의 데이터가 반드시 한 곳에서만 저장되어 있어야 데이터를 변경하더라도 한 곳만 변경하는 것으로 끝낼 수 있기 때문이다.

## 36강 트랜잭션(transaction)

![image](https://user-images.githubusercontent.com/64796257/148320765-90ff51d9-1ce0-41c0-a79b-e924ab08b652.png)

DB에서 트랜잭션이라는 기능을 제공하는데 사실 INSERT나 UPDATE 명령으로 데이터를 추가, 갱신할 때도 트랜잭션 기능을 사용했었다. 
이걸로 어떤 것을 할 수 있는지 알아보자.

### 트랜잭션 

정규화에 의해 분할된 `주문 테이블`과 `주문상품 테이블`의 관계를 살펴보자.

![image](https://user-images.githubusercontent.com/64796257/148321083-79a2d0bd-e8e5-48b9-8f3f-115522698a45.png)

`주문 테이블`과 `주문상품 테이블`은 서로 의존관계가 존재한다.  

`주문 테이블`에서 행이 존재한다면 `주문상품 테이블`에는 적어도 하나의 행이 존재해야 한다.  
그렇지 않으면 주문한 상품이 없는데 주문이 된 상태가 되기 때문이다.

- 주문처리 

주문이 발생했을 때 어떻게 처리되는지 생각해보자. 

먼저 주문번호를 지정해야 한다. 이때 기존 주문과 구분되는 주문번호를 발행하는 처리가 필요하다.

이를 위해 자동 증가를 사용해서 자동으로 번호를 부여하거나  
번호 중 가장 큰 값을 SELECT 명령으로 가져와서 그 값에 1을 더하는 처리를 해야 한다. 최댓값을 MAX()로 검색할 수 있다.

번호를 발행 받았다면 해당 번호를 key로 삼아서 INSERT가 이뤄진다. 

주문 테이블에서는 INSERT 한 번, 주문상품 테이블에서는 주문된 상품 수만큼 INSERT 명령이 실행된다.  
중요한 건 복수의 테이블에서 INSERT가 되기 때문에 실행되는 명령은 `최소 2번`이라는 것이다.

■ 주문처리
``` MySQL
  INSERT INTO 주문 VALUES(4, '2014-03-01', 1); # 주문번호 4 / 3월 1일에 1번 고객이 주문함
  INSERT INTO 주문상품 VALUES(4, '0003', 1);  # 주문번호 4 / 0003이라는 상품코드에 해당하는 상품을 1개 주문함
  INSERT INTO 주문상품 VALUES(4, '0004', 2);  # 주문번호 4 / 0004라는 상품코드에 해당하는 상품을 2개 주문함
```

이 상황에서 INSERT 명령이 어떤 원인으로 에러가 발생했다고 하자. 

트랜잭션 기능을 사용하지 않았다면 문제 없이 실행된 INSERT 명령을 실행 전으로 되돌릴 수 없으므로 DELETE 명령을 따로 실행해줘야 한다.  
이는 아주 번거로운 작업이다. 

### 롤백과 커밋

이처럼 여러 단계를 나누어 SQL 명령을 실행하는 경우에 트랜잭션을 자주 사용한다.

트랜잭션을 사용해서 데이터를 추가한다면 에러가 발생해도 트랜잭션을 롤백(rollback)해서 종료할 수 있다. 
롤백을 하면 트랜잭션 내에서 실행한 모든 변경사항을 없었던 것으로 할 수 있다.

아무런 에러가 발생하지 않는다면 변경사항을 적용하고 트랜잭션을 종료하는데 이때 커밋(commit)을 사용한다.

(마치, git에서 push와 commit의 느낌이다)

- 자동 커밋 

트랜잭션을 사용해서 데이터를 추가하려면 자동커밋을 꺼야 한다. MySQL 클라이언트에서 명령을 실행할 때는 자동커밋이 켜져있는 상황이다.

INSERT, UPDATE, DELETE가 처리될 때마다 트랜잭션은 암묵적으로 자동커밋 상태로 되어 있었다.

자동커밋을 끄기 위해서는 명시적으로 트랜잭션의 시작을 선언해줘야 한다. 이를 위해 START TRANACTION 이라는 명령을 사용한다.

``` MySQL
  START TRANACTION
```

커밋하려면 
``` MySQL
  COMMIT 
```
롤백하려면

``` MySQL
  ROLLBACK
```

트랜잭션 내에서 실행된 SQL 명령은 임시 데이터 영역에서 수행되다가 COMMIT 명령을 수행하면 임시 데이터 영역에서 정식 데이터 영역으로 변경이 적용된다. 

ROLLBACK 명령을 내리면 임시 데이터 영역에서의 처리는 버려진다.

![image](https://user-images.githubusercontent.com/64796257/148322685-0d6e4daf-3b6a-4b39-8a69-119729ece7ec.png)

ex) 
``` MySQL
  START TRANACTION;
  INSERT INTO 주문 VALUES(4, '2014-03-01', 1); 
  INSERT INTO 주문상품 VALUES(4, '0003', 1);  
  INSERT INTO 주문상품 VALUES(4, '0004', 2);  
  COMMIT 
```

이와 같이 트랜잭션을 사용해서 처리하는 것으로 간단하게 데이터를 관리할 수 있다.

### 트랜잭션 사용법 

세트로 실행하고 싶은 SQL 명령은 트랜잭션 내에서 실행하면 된다. 

그렇게 트랜잭션 내에서 SQL 명령을 실행하다가 에러가 발생하면 ROLLBACK을 실행하면 되는 거다.

에러 없이 잘 실행이 되었다면 COMMIT을 실행해주면 되는거다.

만약에 에러가 발생하더라도 COMMIT을 한다면 문제없이 실행된 SQL 명령의 변경사항은 DB에 그대로 반영된다.

MySQL에서는 트랜잭션을 시작하는 명령어로 START TRANACTION (또는 BEGIN TRANACTION) 이라고 하지만  
SQL Server나 PostgreSQLdptjsms BEGIN TRANACTION 명령을 사용한다. Oracle이나 DB2에서는 트랜잭션을 시작하는 명령이 따로 없다.

이는 표준화가 진행되지 않았기 때문이다.

자동커밋은 클라이언트 툴의 기능이다. 미들웨어도 DB에 접속할 때 대개 자동커밋을 하고 DB 서버에서는 언제나 트랜잭션을 걸 수 있는 상태로 SQL 명령을 실행한다. 

그래서 트랜잭션을 사용할 때는 접속형태, 클라이언트 툴의 자동커밋 여부, 트랜잭션 관련 기능을 파악해둘 필요가 있다.

DELETE 명령은 삭제여부에 관해 사용자에게 확인하지 않는다.  
이러한 DELETE 명령을 트랜잭션 내에서 실행하는 경우에는 ROLLBACK으로 삭제를 취소할 수 있다. 










