### 데이터 삽입

ex1) 고객 테이블에 고객아이디 strawberry, 고객이름은 최유정, 나이는 30세, 등급 vip, 직업 공무원, 적립금 100원인 새로운 고객 데이터 삽입
``` SQL
INSERT INTO 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금) 
       VALUES ('strawberry', '최유경', 30, 'vip', '공무원', 100);
```

- 확인 

![image](https://user-images.githubusercontent.com/64796257/188349744-64b39219-7e55-467a-adf5-9d2878222d29.png)

ex2) 고객 테이블에 고객아이디 tomato, 고객이름 정은심, 나이 36세, 등급 gold, 적립금 4000원, 직업은 아직 모르는 새 고객 데이터 삽입

``` sql
INSERT INTO 고객(고객아이디, 고객이름, 나이, 등급, 적립금) 
       VALUES ('tomato', '정은심', 36, 'gold', 4000);
```

![image](https://user-images.githubusercontent.com/64796257/188349920-13c5f06c-4833-4bd3-a822-19c76751b96d.png)

`직업` 부분을 입력하지 않았기 때문에 해당 값은 `null값`이 되었다.

### 데이터 수정 

ex1) 제품 테이블에서 제품번호가 `p03`인 제품의 제품명을 통큰파이로 수정
``` sql
UPDATE 제품 SET 제품명 = '통큰파이' 
            WHERE 제품번호 = 'p03';
```

ex2) 제품 테이블에 있는 모든 단가를 10% 인상 
``` sql
UPDATE 제품 SET 단가 = 단가 * 1.1; 
```


### 데이터 삭제

ex1) 주문 테이블에서 주문일자가 2019년 5월 22일인 주문내역 삭제

``` sql
DELETE FROM 주문 WHERE 주문일자 = DATE '2019-05-22';
```

ex2) 주문 테이블에 존재하는 모든 튜플 삭제. 

``` sql
DELETE FROM 주문;
```

⇒ 이 작업을 하면 테이블의 `튜플`만 삭제되지 `테이블 자체`가 삭제되는 건 아니다.  
⇒ 테이블 자체를 삭제하고 싶다면 `DROP TABLE` 을 사용해야 한다.

## 04 뷰(View) 

### 뷰의 개념 

뷰 : 다른 테이블을 기반으로 만들어진 `가상 테이블`.  
    논리적으로만 존재할 뿐 실제로 데이터를 저장하지 않는다.   
    때문에 `뷰`를 통해 `기존 테이블`의 내용을 `검색`할 수는 있지만 `삭제/수정` 작업은 제한적으로 이뤄진다.

### 뷰의 생성

ex1) 고객 테이블에서 등급이 vip인 고객의 고객아이디, 고객이름, 나이로 구성된 뷰를 우수고객이라는 이름으로 생성.  
     그런 다음에 우수고객 뷰의 모든 내용 검색.
     
``` sql
CREATE VIEW 우수고객(고객아이디, 고객이름, 나이)
        AS SELECT 고객아이디, 고객이름, 나이 FROM 고객 WHERE 등급 = 'vip' WITH CHECK OPTION;
```
WITH CHECK OPTION : 생성한 `뷰`의 `삽입`이나 `수정`연산을 할 때 `SELECT문`의 결과가 뷰의 조건을 위반한다면 수행되지 않도록 한 제약조건

그리고 `우수고객`의 뷰를 구성하는 `속성의 이름`은 기본 테이블인 `고객 테이블`에서 `검색한 속성의 이름`과 같기 때문에 다음과 같이 써도 된다.  

``` sql
CREATE VIEW 우수고객
        AS SELECT 고객아이디, 고객이름, 나이 FROM 고객 WHERE 등급 = 'vip' WITH CHECK OPTION;
```

``` SQL
SELECT * FROM 우수고객;
```

![image](https://user-images.githubusercontent.com/64796257/188351803-88a67f61-2d4b-489d-830d-97897aadd610.png)

ex2) 제품 테이블에서 제조업체별 제품수로 구성된 뷰를 업체별제품수라는 이름으로 생성. 

``` sql
CREATE VIEW 업체별제품수(제조업체, 제품수)
        AS SELECT 제조업체, COUNT(*) AS 제품수 FROM 제품 GROUP BY 제조업체 WITH CHECK OPTION;
```

- 결과 

![image](https://user-images.githubusercontent.com/64796257/188352673-5cad1ea8-8968-4a83-aa39-72c18ef4dfbc.png)

### 뷰의 활용 

- 기본적으로 `뷰`를 통해서 `SELECT문`은 가능하다. 

- INSERT, UPDATE, DELETE문도 수행할 수는 있지만 모든 뷰에 허용되는 건 아니다. 

예시 뷰) 

``` sql
CREATE VIEW 제품1 
        AS SELECT 제품번호, 재고량, 제조업체 FROM 제품 WITH CHECK OPTION;
```

![image](https://user-images.githubusercontent.com/64796257/188353186-1bac00c5-212a-4279-8c11-ebe064841c0d.png)

``` sql
CREATE VIEW 제품2
        AS SELECT 제품명, 재고량, 제조업체 FROM 제품 WITH CHECK OPTION;
```

![image](https://user-images.githubusercontent.com/64796257/188353226-f06b7d97-7d7d-4c99-b429-8fcaa4124929.png)

ex1) 제품번호 p08, 재고량 1000, 제조업체 신선식품인 새로운 제품의 데이터를 제품1 뷰에 삽입.

``` sql
INSERT INTO 제품1 VALUES('p08', 1000, '신선식품');
```

``` sql
SELECT * FROM 제품1; 
```

![image](https://user-images.githubusercontent.com/64796257/188353448-4e42f660-5fad-46c0-b41e-b236fae4c404.png)

`제품1` 뷰에 대한 삽입 연산은 `기본 테이블`인 `제품 테이블`의 내용을 변하게 한다.   
제품 테이블의 모든 내용을 검색하면 `뷰에서 삽입`했던 내용이 기본 테이블에 있다는 걸 확인할 수 있다. 

![image](https://user-images.githubusercontent.com/64796257/188353566-e4af56ae-f4f9-4b6a-bd39-2a12108039df.png)

하지만, `제품2` 뷰에서 삽입연산을 아래와 같이 실행하면 오류가 발생한다. 

``` sql
INSERT INTO 제품2 VALUES2('시원냉면', 1000, '신선식품');
```

왜 실패할까? 바로 `제품번호`의 속성때문이다.  

앞서 `PART1`에서 `제품번호`는 `기본키`로 지정했기 때문에 해당 속성은 `NULL값`을 가질 수 없다.  
즉, 새로운 튜플이 삽입되려면 기존 제품번호와는 다른 `유일한 속성 값`이 주어져야 한다. 

`제품2` 뷰는 `제품번호` 속성이 없기 때문에 제품2를 통해 `삽입`을 할 때 `제품번호`값에 `NULL값`을 줄 수밖에 없기 때문에 오류가 발생한 것이다.

UPDATE와 DELETE도 마찬가지로 기본키를 포함한 `제품1`에서는 오류가 없지만 `제품2`에서는 오류가 발생한다. 

또한 위에서 정의한 `업체별제품수` 뷰도 삽입/삭제/수정 연산을 허용하지 않는다. 

기본키를 포함하지 않은 것도 있지만 `제품수`라는 새로운 속성을 포함시켰기 때문이다. 

### 뷰의 대표적인 장점

그렇다면, 그냥 `기본 테이블`에서 검색/삽입/수정/삭제 작업을 하면 되는데 굳이 `뷰`를 정의해서 사용하는 이유는 뭘까.

1) Query를 좀 더 쉽게 작성할 수 있다.  
: `특정 조건을 만족하는 튜플들`로 `뷰`를 미리 만들면 사용자는 `where절`을 사용할 필요없이 뷰를 검색하면 된다.
: 그 밖에 GROUP BY, 집계 함수, 조인 등을 이용해 미리 `뷰를 만들어놓으면` 복잡한 SQL를 작성하는 부담을 덜 수 있다.

2) 데이터의 보안 유지에 도움이 된다.  
: `사용자`가 `자신에게 제공된 뷰`를 통해서만 `데이터에 접근`하도록 한다면,  
  `뷰에 포함되지 않은 데이터`를 사용자로부터 `보호`할 수 있다. 

3) 데이터를 좀 더 편리하게 관리할 수 있다.  
: 사용자 입장에서는 제공된 뷰에 포함되지 않은 다른 부분은 신경쓰지 않아도 된다. 

## 뷰의 삭제 

ex) 우수고객 뷰 삭제

``` sql
DROP VIEW 우수고객;
```

만약 삭제할 뷰를 참조하는 `제약조건`이 있다면 삭제가 수행되지 않는다. 때문에 삭제하고자 하는 뷰를 참조하는 제약조건을 먼저 삭제해야 한다. 

이걸 지원하는 옵션으로 `CASCADE CONSTRAINTS`가 있다. 이는 삭제할 뷰와 관련된 모든 참조 무결성 제약조건을 삭제하는 옵션이다.

``` sql
DROP VIEW 우수고객 CASCADE CONSTRAINTS;
```

## 05 삽입 SQL - 필요해지면 정리하자.






