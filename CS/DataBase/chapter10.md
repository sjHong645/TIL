## 이번 챕터에서 다룰 내용 

![image](https://user-images.githubusercontent.com/64796257/188577147-770a9eda-769b-456c-aa36-3eb76d91e651.png)

## 01 트랜잭션 

### 트랜잭션 개념 

데이터베이스는  
- 다수의 사용자가 `동시`에 사용하더라도 항상 `모순이 없는` 정확한 데이터를 유지해야 한다.
- `장애가 발생`하더라도 빨리 `원상태로 복구`할 수 있어야 한다.

DBMS는 `트랜잭션`을 이용해서 `DB의 회복과 병행 제어`를 가능하게 함으로써 DB의 `일관성`을 유지한다.

- 트랜잭션 : 하나의 작업을 수행하는 데 필요한 DB의 연산들을 모아놓은 것 ⇒ DB에서 `논리적인 작업의 단위`가 된다  
또한, DB에 `장애`가 발생했을 때 데이터를 `복구하는 작업의 단위`도 된다. 

### 트랜잭션의 특성 - ACID 

| 특성 | 내용 | 
| --- | --- | 
| 원자성(Atomicity) | 트랜잭션을 구성하는 연산들이 `모두 정상`적으로 실행되거나 `하나도 실행되지 않아`야 한다 | 
| 일관성(Consistency) | 트랜잭선 성공 이후 ⇒ DB가 `일관된 상태`를 유지해야 함을 의미 | 
| 격리성(Isolation) | `현재 수행중인 트랜잭션`이 완료될 때까지 `다른 트랜잭션`들이 `접근할 수 없음`을 의미 | 
| 지속성(Duration) | 트랜잭션 성공 이후 ⇒ `DB에 반영한 수행 결과`는 어떤 경우에도 `손실되지 않고 영구적`이여야 함 | 

DBMS에서는 트랜잭션의 기능을 다음과 같이 제공한다.  
![image](https://user-images.githubusercontent.com/64796257/188581232-6d8f4573-d7ee-4f0a-a7a9-0bbd7ce33ac5.png)

### 트랜잭션 연산 

| 연산 | 내용 | 
| --- | --- | 
| commit | 트랜잭션이 `성공적`으로 수행되었음을 선언 (작업 완료) | 
| rollback | 트랜잭션을 수행하는데 `실패했음`을 선언 (작업 취소) | 

- commit 연산을 수행한 경우 

![image](https://user-images.githubusercontent.com/64796257/188581666-446c3b7d-1b7f-4d46-acf8-939e9a796f75.png)

- rollback 연산을 수행한 경우 

![image](https://user-images.githubusercontent.com/64796257/188581748-586663ee-9372-4084-a9e8-b610a187308f.png)

## 02 장애와 회복 

`트랜잭션의 특성을 보장`하고, DB를 모순이 없는 `일관된 상태로 유지`하기 위해서 DBMS는 `회복 기능`을 제공한다.

### 장애의 유형 

![image](https://user-images.githubusercontent.com/64796257/188583375-81a7fce5-5c9c-44fc-a97b-2d36b47a0c78.png)

### 회복 기법 

회복(recovery) : `장애`가 발생했을 때 DB를 `장애가 발생`하기 `이전 상태로 복구`시키는 것

#### 회복을 위한 연산 

`회복`의 주요 흐름은 다음과 같다. 

1) 데이터를 `별도의 장소`에 미리 복사해 둔다.
2) `장애`로 `문제가 발생`했을 때 
3) `복사본`이용해서 을 원상태로 복원한다

- 복사본을 만드는 방법 

| 이름 | 내용 | 
| --- | --- | 
| 덤프(dump) | `DB 전체`를 다른 저장 장치에 주기적으로 복사하는 방법 | 
| 로그(log) | `변경 연산`이 실행될 때 마다 `데이터 변경 이전/이후 값`을 `별도의 파일`에 기록하는 방법 | 

- 복구 방법 
① redo 연산 : 로그에 기록된 `변경 이후의 값`을 이용해 `변경 연산`을 `재실행`하는 방법으로 DB를 복구

② undo 연산 : 로그에 기록된 `변경 이전의 값`을 이용해 `변경 연산`을 `취소`하는 방법으로 DB를 복구 

redo와 undo는 위에서 보다시피 `로그`가 중요하게 사용된다.  
로그를 저장한 파일을 `로그 파일`이라 하고 로그 파일은 `레코드 단위`로 기록된다.

일반적으로 `로그 파일`을 구성하는 `레코드`는 아래와 같이 분류된다. 

![image](https://user-images.githubusercontent.com/64796257/188772139-aa6ef178-7a3b-4832-af6e-17f0d5bd9778.png)

#### DB 회복 기법 분류 

![image](https://user-images.githubusercontent.com/64796257/188771796-5ba79eb0-161d-4a71-9fc9-b28f351d633c.png)

#### 로그 회복 기법

##### 즉시 갱신 회복 기법 
 
: 트랜잭션 수행 중에 `데이터를 변경한 연산`의 `결과`를 DB에 `즉시 반영`한다.  
: 장애 발생에 대비하기 위해 `데이터 변경에 대한 내용`을 `로그 파일`에 기록한다.

⇒ 때문에 `DB를 회복`할 때 로그를 `정상적으로 사용`하려면 
⇒ 트랜잭션에서 데이터 변경 연산을 실행했을 때 
⇒ `로그 파일`에 `로그 레코드`를 먼저 기록한 후 ⇒ DB에 변경 연산을 반영해야 한다. 

ex) 계좌이체 트랜잭션 

![image](https://user-images.githubusercontent.com/64796257/188773496-b0eff3ff-0f5b-4e8b-bb09-61b969b35e59.png)

트랜잭션 연산 수행 ⇒ 로그 파일에 로그 레코드 기록 ⇒ DB 변경 연산 변경 

그렇다면 어떻게 DB를 회복할까. 장애 발생 시점에 따라 `redo`, `undo` 연산을 실행해서 복구하는데 실행 기준은 다음과 같이 얘기할 수 있다. 

| case | 연산 | 설명 | 
| --- | --- | --- |
| 트랜잭선이 완료되기 `전` 장애 발생 | undo | `<Ti, start>`은 있고 `<Ti, commit>`은 없을 때 |
| 트랜잭선이 완료된 `후` 장애 발생 | redo | `<Ti, start>`, `<Ti, commit>` 둘 다 있을 때 |


예시와 함께 알아보겠다. 

트랜잭션 T1 : `A계좌`⇒ `B계좌`로 1000원 이체  
트랜잭션 T2 : `C계좌`⇒ `D계좌`로 2000원 이체

![image](https://user-images.githubusercontent.com/64796257/188774182-be7d459c-0a68-4381-9e26-81d6e84d7f56.png)

- `① 시점`에서 장애가 발생했을 때 

아직, `T1 트랜잭션`이 완료되기 전이라서 `<T1, start>` 로그 레코드만 존재하고 `<T1, commit>` 로그 레코드는 존재하지 않는다.  
⇒ 따라서, `undo` 연산을 실행해야 한다. 

즉, 로그 내용을 이용해서 `지금까지 변경한 데이터 값`을 `변경 연산 이전의 값`으로 되돌린다. 

변경 이전 상태의 A와 B는 각각 `5000원`, `0원`이다. 

- `② 시점`에서 장애가 발생했을 때 

해당 시점에서는 `T1 트랜잭션`은 모든 동작을 완료했고 `T2 트랜잭션`은 아직 완료되기 전 상태다. 

⇒ 따라서, T1에 대해서는 `redo` / T2에 대해서는 `undo` 연산을 실행해야 한다. 

이와 같이 redo, undo 연산을 모두 필요로 할 때는 `undo` 연산을 실행하고 나서 `redo` 연산을 실행한다. 

그렇다면 `T2의 undo 연산`을 통해 `C와 D`는 변경 이전 값인 `3000원`, `0원`으로 되돌아간다. 

`T1의 redo 연산`을 통해 `A와 B`의 값은 변경된 이후의 값인 `4000원`, `1000원`이 된다. 

##### 지연 갱신 회복 기법 

: 트랜잭션이 수행되는 동안 `데이터 변경 연산의 결과`를 DB에 즉시 반영하지 않고 `로그 파일`에만 `기록`했다가  
  트랜잭션이 `부분 완료`된 후에 로그에 기록된 내용을 이용해서 DB에 `한 번에 반영`한다. 
 
그래서 `장애`가 발생한 경우 `로그에 기록된 내용`은 `버리기`만 하면 원상태를 그대로 유지한다. 때문에 완료되기 전에 되돌아가는 `undo` 연산이 필요없다. 

따라서, `지연 갱신 회복 기법`의 회복 전략은 다음과 같다. 

| case | 연산 | 설명 | 
| --- | --- | --- |
| 트랜잭선이 완료되기 `전` 장애 발생 | 로그 내용을 무시하고 버림 | `<Ti, start>`은 있고 `<Ti, commit>`은 없을 때 |
| 트랜잭선이 완료된 `후` 장애 발생 | redo | `<Ti, start>`, `<Ti, commit>` 둘 다 있을 때 |

예시와 함께 살펴보자. 

![image](https://user-images.githubusercontent.com/64796257/188776721-18564f91-6bc9-475a-91cb-62a437922776.png)

- `① 시점`에서 장애가 발생했을 때 

`T1 트랜잭션`이 아직 `완료되기 전`에 발생했다. 아직 `변경 연산 결과`를 `DB`에 `반영하지 않았기` 때문에 로그에 기록된 내용만 버리면 된다. 

- `② 시점`에서 장애가 발생했을 때 

`T1 트랜잭션`의 수행이 `완료`되고 나서 장애가 발생했다. 때문에 `redo()` 연산을 실행해서 A, B계좌의 잔액이 각각 4000원, 1000원이 되도록 한다.

그리고 `T2 트랜잭션`이 아직 `완료되기 전`에 발생한 장애인데 `① 시점`과 마찬가지로 `T2와 관련된 내용`이 로그에 기록된 내용만 버리면 된다. 

#### 검사 시점 회복 기법

`로그를 이용한 회복기법`의 단점은 `로그에 기록된 모든 트랜잭션`을 대상으로 회복 기법을 적용하기 때문에 `많은 시간`을 필요로 하고 `불필요한 redo연산`을 실행할 수도 있다는 점이다. 

이러한 비효율성을 해결하기 위해 제안된 방법이 `검사 시점 회복 기법`이다. 

`검사 시점 회복 기법`은 로그 회복 기법과 같은 방법으로 `로그 기록`을 이용하되, `일정 시간 간격`으로 `검사 시점(checkpoint)`를 만들어준다. 

장애가 발생하면 가장 최근 검사 시점 이전의 트랜잭션에는 회복 작업을 수행하지 않고 `이후의 트랜잭션`에만 `회복 작업`을 수행한다. 

⇒ 이렇게 `회복 작업의 범위`가 정해지면서 불필요한 회복 작업을 수행하지 않아도 된다는 장점이 있다.

동작 과정을 살펴보면, 

(1) 일정 시간 간격으로 `검사 시점`이 되면 `모든 로그 레코드`를 `로그 파일`에 기록 ⇒ 트랜잭션의 데이터 변경내용을 DB에 반영한다.  
(2) 검사 시점을 표시하는 `<checkpoint L>` 형식의 로그 레코드를 `로그 파일`에 기록 (L = 현재 실행되고 있는 트랜잭션 리스트)  
(3) `장애가 발생`하면 가장 `최근 <checkpoint L>`을 찾아 그 이후의 로그 기록에만 회복 작업을 수행한다. 

회복 작업은 앞서 살펴본 `즉시 갱신 회복 기법` 또는 `지연 갱신 회복 기법` 등을 사용해주면 된다.

#### 미디어 회복 기법 

: `디스크에서 발생할 수 있는 장애`에 대비한 회복 기법

## 03 병행 제어 

























