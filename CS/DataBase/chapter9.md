## 이번 챕터에서 다룰 내용

![image](https://user-images.githubusercontent.com/64796257/188524266-eb6f230e-1b91-4efe-b0e4-56eaea2821e0.png)

## 01 정규화 개념과 이상현상

`정규화(Normalization)`를 이용해 DB를 설계할 수 있다. 그리고 DB를 설계한 후 `설계 결과물을 검증`하기 위해 사용하기도 한다.

### 이상(anomaly) 현상  
: DB를 `잘못 설계`했을 때 불필요한 데이터 중복이 발생해 relation에 대한 데이터의 `삽입/수정/삭제 연산을 수행`할 때 나타날 수 있는 `부작용` 

### 이상 현상 종류 

| 종류 | 내용 |
| --- | --- |
| 삽입 이상 | `새 데이터`를 삽입할 때 `불필요한 데이터`도 함께 삽입되는 문제 |
| 갱신 이상 | 중복 튜플 중 `일부만 변경`해서 데이터의 `불일치`가 발생하는 문제 |
| 삭제 이상 | 튜플을 삭제할 때 `다른 필요한 데이터`도 `같이 삭제`되는 문제 |

아래 표를 가지고 각각의 `이상 현상`에 대해 살펴보겠다.

![image](https://user-images.githubusercontent.com/64796257/188524854-4bcbcf18-9354-495b-a214-fdb06b978642.png)

- 기본키 : 고객아이디, 이벤트번호

#### 삽입 이상

삽입 이상 : `새 데이터`를 삽입할 때 `불필요한 데이터`도 함께 삽입되는 문제

ex) 아이디가 melon, 이름은 성원용, 등급은 gold인 신규 고객이 회원가입을 해서 표에 데이터를 `삽입`한다.

하지만, 해당 고객의 데이터는 삽입할 수 없다. 왜냐하면, 기본키 값인 `이벤트 번호`에 대한 정보가 없기 때문이다.  
정보가 없다면 `null값`을 삽입하는데 `기본키`에는 `null값`을 삽입할 수 없다. 

따라서, 해당 relation에서 `삽입 이상`이 발생한다. 

![image](https://user-images.githubusercontent.com/64796257/188525132-7cfc8fe7-833d-4bf4-9238-cbdec058dbc3.png)

#### 갱신 이상

갱신 이상 : 중복 튜플 중 `일부만 변경`해서 데이터의 `불일치`가 발생하는 문제 

표를 보면 `아이디가 apple`인 고객에 대한 튜플이 3개 존재한다.  
그 중 하나의 등급을 vip ⇒ gold로 바꾼다면 apple 고객에 대한 튜플 3개의 등급 속성 값을 모두 수정해줘야 한다. 

그렇지 않으면 `갱신 이상`이 발생한다. 

![image](https://user-images.githubusercontent.com/64796257/188525323-986f6b1c-910d-42bc-9b1d-65b3a2802ae7.png)

#### 삭제 이상

삭제 이상 : 튜플을 삭제할 때 `다른 필요한 데이터`도 `같이 삭제`되는 문제

ex) 아이디가 orange인 고객이 이벤트 참여를 취소해서 관련 튜플을 삭제한다. 

그럼 표에서 하나의 튜플을 삭제하면 된다.  

그런데, 그 튜플은 `아이디가 orange`인 고객에 대한 `이벤트 번호` 뿐만 아니라 `고객아이디`, `고객이름`, `등급`에 대한 정보를 가지고 있는 유일한 튜플이다.  

그래서 이 튜플을 삭제하면 `이벤트 참여`와 관련이 없는 다른 정보들도 함께 삭제되는 `삭제 이상`이 발생한다. 

![image](https://user-images.githubusercontent.com/64796257/188525601-cc7225e1-5691-4d61-b1b5-36a57fd6967c.png)

### 정규화의 필요성 

위와 같은 `이상 현상`이 발생하는 이유는 무엇일까.
```
관련 없는 데이터, 속성들을 하나의 relation에 모두 모아두고 있기 때문이다. 
```

이상 현상이 발생하지 않으려면 `관련 있는 속성들`로만 relation을 구성해야 하는데 이를 위해 필요한 것이 `정규화`이다. 

정규화는 이상현상이 발생하지 않도록 relation을 `관련 있는 속성들`로만 구성하귀 위해 relation을 `분해`하는 과정이다.

정규화에 들어가기 앞서 알아야할 개념이 `함수적 종속성(=함수 종속)`인데 이 개념에 대해서 먼저 살펴보겠다.

## 02 함수 종속 

```
X → Y 

X : 결정자 / Y : 종속자 

- X가 Y를 함수적으로 결정한다.
- Y가 X에 함수적으로 종속되어 있다.
```

ex)  
![image](https://user-images.githubusercontent.com/64796257/188526110-951bd342-567c-45ab-9a21-d9f8d32a5216.png)

위 표에서 `고객 relation`에서 각 `고객아이디 속성값`에 대응되는 `고객 이름 속성`과 `등급 속성`의 값은 단 하나다.

ex) apple → (정소화, gold) / banana → (김선우, vip) ⇒ 이를 통해 `고객아이디`는 결정자 / `고객이름, 등급`은 종속자가 된다. 

여기서 `함수 종속 관계`를 판단할 때 현재 시점의 relation에 포함된 속성 값만으로 판단하면 안된다.  
속성 값은 계속 변할 수 있기 때문에 `속성 자체`가 갖고 있는 `특성과 의미`를 기반으로 판단해야 한다.

여기서는 `고객아이디`가 `기본키`이기 때문에 아이디가 같은 서로 다른 고객은 존재할 수 없다.  
그래서, `고객아이디`가 정해지면 오직 하나의 `고객이름과 등급`이 결정된다.

물론, `결정자 X`가 되려면 해당 키가 기본키, 후보키여야 하는 건 또 아니다.  
속성 Y값을 유일하게 결정할 수 있는 `속성 X`라면 함수 종속 관계에서 모두 `결정자`가 될 수 있다.


ex)  
![image](https://user-images.githubusercontent.com/64796257/188527373-34ea3d16-e5a7-42fb-8f0b-867f5fe69227.png)

위 relation에 존재하는 `함수 종속 관계`를 표현하면 아래와 같다.

```
고객아이디 → 고객이름
{고객아이디, 이벤트번호} → 당첨여부
{고객아이디, 이벤트번호} → 고객이름
```
`고객이름` 속성은 `고객아이디 속성`뿐만 아니라 `{고객아이디, 이벤트번호}`속성에도 `종속`되어 있다.

이런 경우 `고객이름 속성`은 `{고객아이디, 이벤트번호}` 속성 집합에 `부분 함수 종속`되었다고 한다.

반면, `당첨여부` 속성은 `{고객아이디, 이벤트번호}`의 일부분이 아닌 `속성 전체 집합`에 종속되어 있다.  
이런 경우 `당첨여부` 속성은 `{고객아이디, 이벤트번호}`에 `완전 함수 종속`되었다고 한다.

## 03 정규화 












