## 25강

![image](https://user-images.githubusercontent.com/64796257/148230181-0b0f268f-4414-4eb9-a921-c23ad746599a.png)

처음에는 데이터베이스가 당연히 비어있다. 여기에 테이블, 뷰, 인덱스, 프로시저 등의 데이터베이스 객체를 작성해서 데이터베이스를 구축한다.

이번 장에서는 데이터 베이스 객체를 작성하거나 삭제하는 등 관리 방법에 대해서 알아보려 한다.

### 1. 데이터베이스 객체 

데이터베이스 객체 : 테이블, 뷰, 인덱스 등 데이터베이스 내에서 정의하는 모든 것들

여기서의 `객체`는 Java나 C++에서 사용하는 `객체`와는 다른 용어다. 데이터베이스에서의 객체는 `데이터베이스 객체`를 의미한다.

객체는 데이터베이스 내에 실체를 가지는 어떤 것을 말한다. 객체의 종류에 띠리 데이터베이스에 저장되는 내용도 달라진다.

이 책의 앞장 에서 다룬 객체는 `테이블`이다. 테이블은 `행`과 `열`이 저장되어 있다.

반면, SELECT, INSERT 와 같은 명령어들은 실체가 없기 때문에 객체라고 할 수 없다.

![image](https://user-images.githubusercontent.com/64796257/148230903-7af19efb-2c6a-4273-93f9-22c05dfd0b04.png)

객체는 이름을 가지는데 데이터베이스 내에서는 이름이 서로 겹치면 안 된다. 

객체 말고도 테이블의 열, SELECT 명령에도 이름을 붙일 수 있지만 이들은 객체가 아니다. 

이름을 붙일 때는 다음과 같은 제약사항을 따른다.
- 기존 이름이나 예약어와 중복하지 않는다.
- 숫자로 시작할 수 없다
- 언더스코어(_) 이외의 기호는 사용하지 않는다.
- 한글을 사용할 때는 큰 따옴표(MySQL에서는 백 슬래시)를 사용한다.
- 시스템이 허용하는 길이를 초과하지 않는다.

### 2. 스키마 

데이터베이스 객체는 스키마라는 그릇 안에 만들어진다. 객체의 이름이 같아도 스키마가 서로 다르면 상관없다. 

![image](https://user-images.githubusercontent.com/64796257/148231666-fc7855d5-00ce-40c4-ae66-a2b81c443a54.png)

때문에 데이터베이스 객체는 `스키마 객체`라고 불리기도 한다.  
실제로 데이터베이스에 테이블을 작성해서 구축해나가는 작업을 `스키마 설계`라고 부른다.

이때 스키마는 SQL 명령의 DDL을 이용해서 정의한다.

MySQL에서는 CREATE DATABASE 명령으로 작성한 `데이터베이스`가 스키마가 된다. 

테이블과 스키마는 무엇인가를 담는 그릇 역할을 한다는 점에서 비슷한다.

테이블 안에는 `열(column)`을 정의할 수 있고 스키마 안에는 `테이블`을 정의할 수 있다.  
각각의 그릇 안에서는 중복하지 않도록 이름을 지정한다.

이처럼 이름이 충돌하지 않도록 기능하는 그릇을 `네임스페이스(namespace)`라고 부르기도 한다.

## 28강 인덱스 구조

인덱스는 데이터베이스 객체 중 하나이다. 인덱스란 무엇이고 그 역할과 구조는 어떻게 이루어졌는지 살펴보자.

![image](https://user-images.githubusercontent.com/64796257/148299859-5fdc5fb1-1317-4b0d-8a21-aedbd3037a67.png)

테이블에서 인덱스를 작성할 수 있는데 인덱스를 지정하면 어떤 점이 좋고 그러한 효과를 얻을 수 있는 이유에 대해서 살펴보자.

### 인덱스 

인덱스는 테이블이 붙여진 `색인`이다. 인덱스의 역할은 `검색 속도의 향상`이다. 

여기서 검색이란 SELECT 명령에 WHERE 구로 조건을 지정하고 그에 일치하는 행을 찾는 일련의 과정을 말한다. 검색은 탐색이라고도 불린다.

테이블에 인덱스가 지정되어 있다면 효율적으로 검색할 수 있어서 WHERE로 조건이 지정된 SELECT 명령의 처리 속도가 빨라진다.

책의 목차와 색인과 같이 인덱스의 구조도 마찬가지다.  
데이터베이스의 인덱스에는 검색을 위해 사용하는 키워드와 이에 대응하는 데이터 행(row)의 장소가 지정되어 있다.

![image](https://user-images.githubusercontent.com/64796257/148300411-25b0b3f7-2647-4d55-838f-97cdeee733d3.png)

인덱스는 테이블과는 별개로 독립된 데이터베이스 객체로 작성된다. 

하지만, 인덱스 자체로는 아무런 의미가 없다. 목차밖에 없는 책은 없듯이 인덱스는 테이블에 의존하는 객체라 할 수 있다. 

그래서 대부분의 DB에서는 테이블을 삭제하면 인덱스도 같이 삭제된다.

### 검색에 사용하는 알고리즘 

- full table scan : 인덱스가 지정되지 않은 테이블을 검색할 때는 이 방법을 사용한다. brute force를 생각하면 된다.  
그래서 데이터의 양이 많을 수록 처리 속도가 늦어진다.

- 이진 탐색(binary search) : 아는 내용이라 생략 

⇒ 이진 탐색은 대량의 데이터를 검색할 때 빠른 속도를 제공하지만 데이터가 정렬되어 있어야 사용할 수 있다는 한계점은 분명하다.

하지만, 테이블 내의 행을 언제나 정렬된 상태로 두는 것은 힘든 작업이다. 

일반적으로 테이블에 대해 인덱스를 작성하면 테이블 데이터와 별개로 인덱스용 데이터가 저장장치에 만들어진다.  
이때, `이진 트리(binary tree)` 라는 데이터 구조로 작성된다. - 이진 트리는 아는 내용이니까 생략

### 유일성

이진 트리에서는 중복된 값을 여러 개 만들 수 없다는 `키 값`에 대한 `유일성`이라는 특징이 있다. 

그렇기 때문에 같은 키가 여러 개 있는 경우에 대해서는 고려하지 않아도 된다.

## 29강 인덱스 작성과 삭제

그렇다면 인덱스를 실제로 어떻게 작성하는지에 대해서 살펴보도록 하자.

- 인덱스 작성과 삭제 

![image](https://user-images.githubusercontent.com/64796257/148302248-9f2930fc-84fe-4bdd-8aa9-a6db2cfc39fa.png)

인덱스는 DB의 객체 중 하나로 DDL(Data Definition Language; 데이터 정의 언어)을 사용해서 작성하거나 삭제한다.  
표준 SQL에는 CREATE INDEX 명령이 없다. 인덱스를 DB 제품에 의존하는 선택적인 항목으로 취급하기 때문이다.

하지만, 대표적인 DB 제품에는 모두 인덱스 구조가 도입되어 있고 비슷한 관리 방법으로 인덱스를 다루고 있다.

### 인덱스 작성 - CREATE INDEX

CREATE INDEX 명령으로 인덱스를 만든다.  
인덱스에 이름을 붙여 관리하는데 `DB의 객체`가 될지 `테이블의 열`처럼 취급될지는 DB제품에 따라 다르다.

Oracle이나 DB2에서는 인덱스를 `스키마 객체`로 취급한다. 그래서 스키마 내에서 이름이 중복되면 안된다.

SQL Server나 MySQL에서 인덱스는 `테이블 내 객체`로 취급된다. 그래서 테이블 내에서 이름이 중복되면 안된다.


인덱스를 작성할 때 해당 인덱스가 `어느 테이블`의 `어느 열`에 관한 것인지 지정할 필요가 있다. 이때 열은 복수로 지정할 수도 있다.  
인덱스의 namespace가 DB 제품마다 다르다는 것에 주의하면 문법은 그리 어렵지 않다.

- 문법 
``` MySQL 
  CREATE INDEX 인덱스이름 ON 테이블이름(열이름1, 열이름2, ...)
```

ex. sample62라는 테이블의 no 열에 isample65 라는 인덱스를 작성한다. 
``` MySQL 
  CREATE INDEX isample65 ON sample62(no);
```

인덱스를 작성한다는 건 저장장치에 탐색용 데이터가 만들어지는 것이기 때문에  
테이블의 행이 많으면 많을수록 시간도 많이걸리고 저장공간도 많이 소비하게 된다.

### 인덱스 삭제 - DROP INDEX 

인덱스는 DROP INDEX 명령으로 삭제한다. DROP 할 때는 다른 객체와 동일하게 인덱스 이름만 지정하면 된다. 

다만 테이블 내의 객체로서 작성한 경우에는 테이블 이름도 같이 지정해야 한다.(이때, 인덱스로 구성한 열을 지정할 필요는 없다)

- 문법 
``` MySQL 
  DROP INDEX 인덱스이름 
  
  # 스키마 객체인 경우
```

``` MySQL 
  DROP INDEX 인덱스이름 ON 테이블이름
  
  # 테이블 내 객체인 경우
```

인덱스는 테이블에 의존하는 객체이기 때문에 DROP TABLE로 테이블을 삭제하면 테이블에 작성된 인덱스도 같이 삭제된다.

ex) 위에서 작성한 인덱스를 삭제하겠다. 

⇒ 인덱스 isample65를 삭제한다. 그런데 MySQL은 인덱스를 테이블 내 객체로 취급하기 때문에 테이블 이름인 sample62도 같이 작성해야 한다.

``` MySQL
  DROP TABLE isample65 ON sample62;
```

이와 같이 인덱스를 작성하면 `검색`이 빨라진다. 

작성한 인덱스의 열을 WHERE 구로 조건을 지정해서 SELECT 명령으로 검색하면 처리속도가 향상된다. (물론, 인덱스가 모든 SELECT 명령에 적용되지는 않는다)

반면, INSERT 명령의 경우 인덱스를 update해야 하는 처리가 늘어나기 때문에 INSERT의 처리속도는 조금 떨어진다.

SELECT 명령 사용에 대해서 살펴보자.

- 상황 
``` MySQL
  CREATE INDEX isample65 ON sample62(a); 
  
  # isample65라는 인덱스를 생성. 
  # 해당 인덱스는 sampel62라는 테이블에 a 열에 지정한 것이다.
```

WHERE 구에 a 열에 대한 조건식을 지정한 경우 SELECT 명령은 인덱스를 사용해 빠르게 검색할 수 있다.
``` MySQL
  SELECT * FROM sample62 WHERE a='a'; 
  
  # sample62라는 테이블의 a열에서 'a'라는 데이터를 검색하고 싶다.
```

위와 같이 SELECT 명령어를 사용하면 된다.  
그런데 WHERE 구의 조건식에서 a 열이 사용되지 않는다면 SELECT 명령어는 isample65라는 인덱스를 이용할 수 없다.

### EXPLAIN








