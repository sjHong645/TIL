■ 알고리즘이란 ⇒ 컴퓨터로 문제를 풀기 위한 단계적 절차

### 1. 주로 쓰는 알고리즘 기술 방법 
- 자연어  
![image](https://user-images.githubusercontent.com/64796257/148893834-72d08063-7536-4f47-a6bb-507affbbe2a2.png)

- 순서도  
![image](https://user-images.githubusercontent.com/64796257/148893846-88f55c40-9794-4700-b2fa-f500c46b61d9.png)

- 의사코드(Pseudo-code)  
![image](https://user-images.githubusercontent.com/64796257/148893863-b1a83be9-535f-4cea-bafb-9bd52fbb9657.png)

- 실제 코드  
![image](https://user-images.githubusercontent.com/64796257/148893868-bb073efe-8727-4951-aba4-30f28e92fb56.png)

### 2. 알고리즘의 성능분석 방법

#### 시간 복잡도와 공간 복잡도 

자료구조와 알고리즘(이하 `알고리즘`)이 잘 동작하는 것도 좋지만 좋은 성능까지 갖고 있다면 더 좋을 것이다.

알고리즘을 평가하는 2가지 요소는 다음과 같이 정리할 수 있다.
- 어떤 알고리즘이 어떤 상황에서 더 빠르고 느린지.
- 어떤 알고리즘이 어떤 상황에서 메모리를 적게 쓰고 많이 쓰는지.

사실 메모리를 적게 쓰고 속도도 빠르다면 최적의 알고리즘이라 할 수 있다.  
하지만 일반적으로 알고리즘을 평가할 때는 메모리의 사용량보다 실행속도에 초점을 맞춘다.

그렇다면 어떻게 속도를 측정할 수 있을까?

“연산의 횟수를 센다” // “그리고 처리해야할 데이터의 수를 n이라 할 때 연산횟수의 함수 T(n)을 구성한다”
연산의 횟수가 적다면 당연히 속도가 빠른 알고리즘이다.

식을 구성하면 데이터 수의 증가에 따라 연산횟수가 어떻게 변화하는지를 판단할 수 있다.

다음과 같이 그래프가 그려졌다고 하자.  
![image](https://user-images.githubusercontent.com/64796257/148894144-60609912-366f-49b9-be1d-927e53a2b7f5.png)

동일한 기능을 제공하는 서로 다른 두 알고리즘의 성능을 비교한 결과가 위와 같다.

데이터의 개수가 n개를 넘어가기 전에는 A의 연산횟수가 더 많다.  
즉, n개 이하의 데이터에서는 A의 속도가 더 느리다고 얘기할 수 있다.

하지만, 데이터가 n개를 넘어가면 상황이 달라진다.   
B 알고리즘의 연산횟수가 급격하게 늘어나게 되는데 이를 통해 n개의 데이터 이후에는 B의 연산 속도가 확연히 느려진다는 것을 확인할 수 있다.

ex) 

![image](https://user-images.githubusercontent.com/64796257/148894271-f3216794-3a7b-4d3d-b973-8cd917d38279.png)

Assignment = 대입 / Addition = 덧셈 / Multiplications = 곱셈

#### 빅-오 표기법(Big-O Notation)

빅-오란 무엇인가? 알고리즘의 연산횟수 T(n)에서 가장 영향력이 큰 부분이 어딘가를 따지는 것이다.

예를 들어, T(n)=n^2 + 2n + 1이라 하자.

+1 정도는 빼줘도 전체적인 식의 경향성은 변하지 않기 때문에 n^2 + 2n으로 식을 간략화 할 수 있다. 그리고 추가적으로 2n을 빼버려도 무방하다.  

n이 어느 정도 증가하면 n^2이 차지하는 비율이 99%을 넘어가기 때문에 

T(n) = n^2 + 2n + 1 에서 n이 증가함에 따라 2n+1이 미치는 영향은 미미해지므로 다음과 같이 간략화 할 수 있다.

T(n) = n^2 = O(n^2). 이와 같이 표현하는 것이 바로 빅-오 표기법이다.

위와 같은 사실을 통해서 T(n)이 다항식으로 표현된다면 최고차항의 차수가 빅오가 된다는 걸 알 수 있다.

빅오의 정의는 다음과 같다.  
![image](https://user-images.githubusercontent.com/64796257/148894748-4a5aa252-a05a-482e-a085-417002332730.png)

예제) 

![image](https://user-images.githubusercontent.com/64796257/148895244-5df6e7b9-9e24-4e2a-a83d-92a57b51f720.png)

![image](https://user-images.githubusercontent.com/64796257/148895254-62c5a675-daff-4e92-a2b9-3f74011ffc46.png)

빅-오 표기의 성능 비교

![image](https://user-images.githubusercontent.com/64796257/148895267-e0bed82d-7454-463e-b2f2-a3cb56829bb8.png)

- O(1) : 상수형 빅-오라 한다. 데이터의 수에 상관없이 연산횟수가 고정인 알고리즘을 의미한다.
- O(logn) : 로그형 빅-오. 데이터 수의 증가율에 비해 연산횟수 증가율이 낮은 알고리즘을 의미한다.
- O(n) : 선형 빅-오. 데이터의 수와 연산횟수가 비례하는 알고리즘
- O(nlogn) : 데이터의 수가 2배 늘어난다면, 연산횟수는 2배보다 조금 넘게 증가하는 알고리즘을 의미한다.
- O(n^2): 데이터의 수의 제곱에 해당하는 연산횟수를 요구하는 알고리즘. 따라서, 데이터의 양이 많을 경우에는 부적절한 알고리즘이라 할 수 있다. 도 마찬가지.
- O(2^n): 지수형 빅-오. 알고리즘을 개발할 때 이러한 성능을 보인다면 개선해야 한다.

#### 빅-오메가 표기법(Big-Omega Notation)

![image](https://user-images.githubusercontent.com/64796257/151689320-fd2187a2-49d2-4f9b-9bcf-ac40f0350f4b.png)

`빅-오` 정의에서 부등호의 방향이 바뀌었다고 생각하면 된다. 

![image](https://user-images.githubusercontent.com/64796257/151689344-46c92289-d0cc-41c0-850f-ae1222f77ed7.png)

#### 빅-쎄타 표기법(Big-Theta Notation)

![image](https://user-images.githubusercontent.com/64796257/151689347-46b1700c-48aa-433a-9465-1448591ca1cb.png)

함수 f(n)의 `빅-쎄타`는 함수 f(n)의 `빅-오`와 `빅-오메가`의 교집합의 원소다.







