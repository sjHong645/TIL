## Greedy Algorithm 

- Greedy Strategy
⇒ 지금 당장의 최선의 결과를 찾기 위한 방식  
⇒ 그러다 보니 대부분 최적화된 결과를 찾아내지는 못하지만 드물게 최적해를 보장하는 경우도 있다.

`최적해를 못 찾아내는` 대표적인 경우와 `최적를 찾아내는` 대표적인 경우를 하나씩 소개해보려 한다. 
그리고 최적화하는 경우라면 왜 최적화된 방법인지 까지 알아보자.

### 최적해를 못 찾아내는 경우 - Coin Changing Problem

500원, 100원, 50원, 10원, 5원, 1원 단위를 이용해서 돈을 표현할 때 가장 적은 동전의 수를 가지고 표현하려 한다.

ex) 3,256원을 적은 동전의 수로 표현하려 한다.   
    이를 `greedy 한 방식`으로 해결하는 방법은 `가장 큰 단위의 동전`을 `먼저 사용`하는 거다.  
    즉, 500원으로 먼저 주어진 금액을 최대한 표현하고 그 다음에는 100원, 그 다음에는 50원 이런 순으로.  
    
![image](https://user-images.githubusercontent.com/64796257/150663105-796d5c0e-26b0-4cad-b8b1-6b8f3ad02034.png)

하지만 이 방식은 최적해를 제공하지 않는다. 예시를 들어보자.

동전의 단위가 500원, 400원, 100원, 75원, 50원 단위로 있다고 하자. 

이때, 1300원을 가장 적은 동전의 수로 표현하려 한다. 

이때, 위에서 사용했던 방식을 사용한다면 `500원 2개 + 100원 3개 = 총 5개의 동전`을 사용한다.

하지만, 이보다 더 좋은 방법이 있는데 `500원 1개 + 400원 2개 = 총 3개`만 사용할 수 있는 방법이 있다.

따라서, `greedy 알고리즘`이 최적해를 제공한다고 할 수는 없다.

### 최적해를 찾아내는 경우 - 회의실 배정 문제(Activity Selection)

하나의 팀이 자신이 사용하는 시간 동안에는 하나의 회의실을 사용할 수 있다.   
여러 개의 팀이 회의실을 쓰려고 할 때 어떻게 하면 최대한 많은 팀이 회의실을 사용할 수 있을까??

#### 문제 정의 
Input : ![image](https://user-images.githubusercontent.com/64796257/150663133-a5f9e106-cb27-4bab-9ac0-979f7c430d67.png)

여기서 `s_i`는 `i번째 회의의 시작시간`, `f_i`는 `i번째 회의가 끝나는 시간`을 의미한다.

#### 과정 

##### 직관적 접근 
직관적으로 접근해보면(Naive solution by brute force) 일일이 경우의수를 세는 방법이 있다.

1) S의 부분집합의 경우의 수를 센다.
2) 그 중에서 서로 시간이 겹치는 부분집합이 있을텐데 이는 제외한다.
3) 남아있는 부분집합 중에서 가장 원소가 많은 부분집합을 찾는다.

⇒ 하지만, 이러한 방법은 비효율적이다.  
왜냐하면 `S의 원소의 개수` `n개` 일 때 `S의 부분집합의 개수`는 `2^n`이다.  
`n = 10`이라면 `1024개`의 어마어마한 경우의수로 불어난다. 따라서, 이러한 방법은 비효율적이다.

##### Greedy 접근 
이걸 greedy 하게 접근해보자.
S1) 회의 시간이 짧은 걸 먼저 고르는 방식 ⇒ 이 방식은 아래의 그림처럼 최적해를 보장하지 않는다. 

![image](https://user-images.githubusercontent.com/64796257/150663169-9dac0a30-1757-43a2-b40f-f403f88e6fdd.png)

S2) 끝나는 시간이 가장 빠른 걸 먼저 고르는 방식  
-1. S에서 끝나는 시간이 가장 빠른 회의를 고른다.
-2. 그 회의와 시간이 겹치는 회의는 S에서 지운다. ⇒ 이 과정을 S가 텅 빌 때까지 반복한다.


S2 - 1) 
![image](https://user-images.githubusercontent.com/64796257/150663181-dda13f5b-168a-4188-98f4-cfa1370a3513.png)

S2 - 2) 

![image](https://user-images.githubusercontent.com/64796257/150663185-84c9a03f-3332-4040-95de-821a775adf8b.png)

S2 - 3)

![image](https://user-images.githubusercontent.com/64796257/150663189-7fec0c03-14c8-4009-8a5d-c24054ddf93f.png)

##### 성능 평가

![image](https://user-images.githubusercontent.com/64796257/150663219-32967f73-09ac-41e2-9f07-241f54396adb.png)

`빨간 상자` 부분에서 정렬하는데 소요되는 시간 복잡도 ⇒ `O(nlogn)` / `녹색 상자` 부분에서 소요되는 시간 복잡도 ⇒ `O(n)` 

따라서, 시간복잡도는 `O(nlogn)`이 된다.

`Greedy algorithm`이 맞다는 것을 증명하기 위해서는 2가지를 보이면 된다.

1) Greedy choice property ⇒ 알고리즘의 첫 단계에서 만들어진 greedy한 방법이 최적해를 가지는지 파악한다.

2) Optimal sub-structure ⇒ 어떤 문제에 대한 최적해가 그 문제의 부분 문제에 대한 최적해를 가지고 있는지 파악한다. 

ex.  
Prim’s, Kruskal’s Algorithms for MST

1) Greedy choice 
- Prim’s algorithm : 새로운 노드를 추가할 때 추가되는 노드는 `weight가 가장 작은 노드`가 추가된다.  
 ⇒ `MST`에서는 `경로의 합이 최소`가 되야 하기 때문에 `처음부터 추가하는 노드의 가중치`가 `가장 낮은 것`이 `최적의 해`가 될 것이다.
 
- Kruskal’s algorithm : 각 단계의 cycle을 만들지 않는 `가장 weight가 작은 edge`를 추가한다.  
⇒ `MST`에서 `경로의 합이 최소`가 되니까 `추가하는 edge의 가중치`가 `가장 낮은 것`이 `최적해`가 될 것이다.

2) Optimal sub-structure : 그렇게 구성된 `최적의 MST`는 결국에는 `최적의 MS sub-tree`로 구성된다.  
`여러 개의 최적 부분 트리`를 통해서 `최적의 트리`가 만들어 진 것이다.

따라서, 두 알고리즘은 `greedy algorithm 방식`으로 `최적해`를 찾을 수 있는 방법이 된다.

Dijkstra’s algorithm

1) Greedy choice : 새로운 노드를 추가할 때 `가장 짧은 경로를 가진 노드`를 추가한다.  
⇒ `SSSP`에서는 `경로 합이 최소`가 되야 하기 때문에 `처음부터 추가하는 노드의 경로 값`이 `가장 낮다면` 이는 `최적해`가 된다.

2) Optimal sub-structure : 그렇게 구성된 `최적의 shortest path`는 `최적의 shortest sub-path`로 구성된다.  
`여러 개의 최적 부분 경로`를 통해서 `최적 경로`가 만들어 진 것이다.

따라서, Dijkstra’s algorithm도 `greedy algorithm 방식`으로 `최적해`를 찾을 수 있는 방법이 된다.














