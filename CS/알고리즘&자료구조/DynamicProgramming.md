## DP(Dynamic Programming) 

### 개념 
: `동적 프로그래밍`은 `큰 문제의 해답`에 `작은 문제의 해답`이 포함되어 있고  
   이를 `재귀호출 알고리즘`으로 구현했을 때 `지나친 중복이 발생`하는 경우 그 `중복 문제를 해결`하는 방법을 말한다.

ex) 피보나치 수 구하기 

피보나치 함수를 f라고 하자. 그러면 아래와 같이 정의된다.

정의 : f(n) = f(n-1) + f(n-2) /  f(1) = f(2) = 1

이를 통해 `n의 피보나치 수`는 `n-1의 피보나치 수`와 `n-2의 피보나치 수`를 포함한다는 걸 알 수 있다.

이와 같이 `큰 문제의 해답`에 그보다 `작은 문제의 해답이 포함`되어 있으면 `최적 부분구조(optimal sub-structure)`를 가졌다고 한다.  
이는 `동적 프로그래밍`을 적용하기 위한 `첫 번째 성질`이다.

이러한 최적 부분 구조를 가진 문제는 재귀호출을 통해 문제를 풀 수 있다.

``` java
int fib(n) { 
   
   if(n == 1 || n == 2) return 1;
   
   else return fib(n-1) + fib(n-2);
  
} 
```

하지만, 위와 같은 재귀적 알고리즘은 `엄청난 비효율`을 초래할 수 있다.  
위에서 작성한 알고리즘을 통해 `n의 피보나치 수`를 구하게 되면 `지수함수에 비례`하는 시간이 소요된다. 

`T(n) = fib(n)의 시간 복잡도`라고 하면   
![image](https://user-images.githubusercontent.com/64796257/150709015-72b0d6c2-ee07-49b5-8b45-4ed5f5c10de5.png)

위와 같은 식이 전개된다. 이러한 식이 전개되는 이유는 다음 그림을 보면 알 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150709034-da2ea8b3-c9b6-4237-b02c-3e86487e6536.png)
![image](https://user-images.githubusercontent.com/64796257/150709037-fbcd032f-ed86-4cf6-ac56-313e7bcfc678.png)

왼쪽의 그림과 표와 같이 이미 호출한 `fib(1)`이나 `fib(2)`가 계속해서 반복호출 된다는 걸 알 수 있다.

이렇게 `재귀적으로 구현`했을 때 `중복 호출`로 인한 `심각한 비효율이 발생`하는 경우가 동적 프로그래밍을 사용하기에 적합한 `두 번째 조건`이다. 

정리하면, 다음 `두 성질이 있는 문제`에 대해 적절한 저장 방법으로 중복 호출의 비효율을 제거하는 것을 동적 프로그래밍이라 한다.

1) 최적 부분 구조를 이룬다.
2) 재귀적으로 구현했을 때 중복 호출로 인한 엄청난 비효율이 발생한다.

이를 해결하기 위한 두 가지 접근법을 소개한다.

### 접근법 

#### 1) Top-down Approach (a.k.a memoization)
⇒ 즉, `이미 계산한` 피보나치 함수의 값들을 기억해놨다가 해당 함수의 값을 사용하면 `저장해놨던 걸 재사용`한다.

![image](https://user-images.githubusercontent.com/64796257/150709221-aae843d5-652d-4fa2-bc12-3445c16ea695.png)

이를 위해서는 계산한 숫자를 저장하기 위한 `추가적인 공간`이 필요하다. 그 공간을 `cache`라고 한다.

![image](https://user-images.githubusercontent.com/64796257/150709253-d6d313ee-ee85-4ee2-a289-52744fe77529.png)

처음 n의 값은 가장 큰 값이었다. 만약에 n = 6이라면, `fib[6]`의 값 /`fib[5]`의 값/ `fib[4]`의 값 순서로 각각의 값들이 저장되는 것을 말한다.

시간 복잡도 : `T(n)` = T(n-1) + T(n-2) + C = T(n-1) + C = ... = `O(n)` ⇒ T(n-2)가 없어지는 이유는 저장한 공간에서 재사용하기 때문이다.

공간 복잡도 : n의 크기와 비례해서 커진다. 따라서, `S(n) = O(n)`

#### 2) Bottom-up Approach
- Tabulation : 피보나치 계산 결과들을 배열과 같은 저장소에 저장하는 방법

![image](https://user-images.githubusercontent.com/64796257/150710247-b3b73704-f7d4-4ec4-8697-cd5425b5205b.png)

`fib[0]`에서 부터 시작해서 각각의 값들을 배열에 저장한다.

![image](https://user-images.githubusercontent.com/64796257/150710271-1dd83265-2bd9-40a0-9556-517380a9ac7f.png)

이때 사용하는 테이블은 위에서와 마찬가지로 `cache 역할`을 한다. `시간 복잡도`와 `공간 복잡도`는 모두 `O(n)`이 된다.

### 정리

`동적 프로그래밍`은 재귀적 문제를 최적화하기 위한 방법이다.  
⇒ 그 중에서도 `중복으로 인한 비효율`이 있고 `최적 부분 구조(optimal sub-structure)`를 가져야 `동적 프로그래밍`을 이용할 수 있다.

- main idea : `sub-program의 해결책`을 `저장`해서 그 값들을 재사용해서 약간의 메모리를 사용해  
  `프로그램 자체의 속도`를 `빨라지도록` 하는 것을 목적으로 한다.

이제 `동적 프로그래밍(Dynamic programming)`을 사용하는 대표적인 문제에 대해 살펴보도록 하자.

### 행렬 경로 문제(Maximum Cost Path in a matrix) 

#### 조건 및 규칙 
- `양수`로 이루어진 `n×n` 행렬이 있다.
- 행렬은 `왼쪽 위`에서 시작해서 `1칸씩` 이동해 `오른쪽 아래`까지 도달한다.
- 이 과정에서 방문한 칸에 있는 수들을 더한 값이 이 경로의 합이다. 

이동 규칙 : 1. `오른쪽`이나 `아래쪽`으로만 이동할 수 있다. 2. `왼쪽`, `위쪽`, `대각선 이동`은 허용하지 않는다.

이러한 조건을 통해서 이동할 때 행렬의 원소 `(1, 1)`에서 `(n, n)`으로 이동하는 `모든 경로의 점수 중`에서 `가장 높은 점수`를 구하려고 한다.

이를 동적 프로그래밍을 통해서 구할 수 있는지 따져보겠다.

#### DP 조건 만족 여부 및 구현

step 1) 최적 부분구조가 있는지 확인.

행렬의 원소 `(1,1)`에서 `(i,j)`까지 도달하는 경로들의 점수 중에서 `최고점`을 구해보려 한다.  
`원소 (i,j)`에 `도달하기 직전에 방문`할 수 있는 원소는 `(i-1, j)`와 `(i, j-1)` 단 `두 개밖에` 없다. 

그렇다면, `(1, 1)`에서 `(i, j)`까지 도달하는 경로가 `최대`가 되기 위해서는  
`(i-1, j)`에서 `(i, j)`로 도달하는 경우와 `(i, j-1)`에서 `(i, j)`로 도달하는 경우 중에서 `점수가 높은 쪽을 선택`하면 된다.

즉, `문제 (i, j)의 최적해`는 `문제 (i, j-1)의 최적해`와 `문제 (i-1, j)의 최적해`로 설명할 수 있다.   

자신의 `부분 문제에 대한 최적해`를 자신의 `최적해를 구성하는데 사용`하므로 `최적 부분 구조`를  

이를 토대로 재귀적 관계를 정의하면 다음과 같다.

![image](https://user-images.githubusercontent.com/64796257/150712414-fa176ac5-2e44-48ee-84ca-2d2bcce46c2d.png)
![image](https://user-images.githubusercontent.com/64796257/150712423-47064396-9897-43cb-9da8-5f0fe31d15aa.png)

![image](https://user-images.githubusercontent.com/64796257/150712434-c29bae7a-84bf-4221-8229-b7c52dbd8ab9.png)

하지만, 이 상태에서 끝내면 `중복 호출`로 인해 `시간 복잡도`가 `지수함수`에 비례해서 커진다.  
그래서 `memoization` 즉, `각각의 값들`을 `저장할 수 있는 요소`를 넣어야 한다.  

`C_i,j`를 0으로 초기화했다고 할 때 아래와 같은 두 가지 버전으로 작성할 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150712551-7e45ae4f-413f-413b-902a-8861f20016c7.png)

표현만 다를 뿐 둘 다 각각의 계산 결과값들을 저장한다는 공통점이 있다.

### 돌 놓기 문제(Pebbling a Checkerboard) 

#### 조건 및 규칙
돌을 놓는 조건은 다음과 같다.
- 가로나 세로로 인접한 두 칸에 동시에 돌을 놓을 수 없다.
- 각 열에는 적어도 하나 이상의 돌을 놓는다. 여기서의 `열`은 column 즉, 세로를 의미한다.
  
ex)  
![image](https://user-images.githubusercontent.com/64796257/150712813-7c814696-6587-4bec-aa88-09f7a8407db8.png)

이러한 제한 조건 때문에 임의의 `하나 열`에 돌을 놓을 수 있는 방법은 총 `4가지`가 있다.

![image](https://user-images.githubusercontent.com/64796257/150712839-b41649c2-cbef-4643-a62c-72aa5c72470d.png)
![image](https://user-images.githubusercontent.com/64796257/150712843-18636bae-ce20-47f1-831d-2c5bfd03661a.png)

이러한 패턴을 바탕으로 서로 인접한 열에서 놓을 수 있는 패턴은 다음과 같이 정리할 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150712871-68122cf0-4f34-4979-9f9a-29dd73dfc80c.png)

그렇다면 이 구조가 최적 부분 구조를 가지고 있는지 확인해보자. 

#### DP 조건 만족 여부 및 구현 
n열 중 `1열부터 i열`까지 돌을 놓은 경우에 `1열부터 i열까지 합`의 `최고치`를 생각해보자.

그렇다면 i열은 4가지 패턴 중 하나로 돌이 놓일 것이다.

1) i열이 패턴 1인 경우의 최고점

2) i열이 패턴 2인 경우의 최고점

3) i열이 패턴 3인 경우의 최고점

4) i열이 패턴 4인 경우의 최고점 

이 중에서 `4)의 경우` `i-1열`은 `패턴 2`로 놓여야 한다. 

따라서 `i열`이 `패턴 4`로 놓여 있을 경우의 최고점은   
(`i-1열`이 `패턴 2`로 놓여있을 경우의 최고점) + (`i열`에서 `패턴 4`로 돌이 놓인 곳에 있는 수)의 값이다.

마찬가지로 `1)의 경우`를 보면 `i-1열`은 `패턴 2 또는 3`으로 놓여야 한다. 

그래서 `i열`이 `패턴 1`로 놓여 있을 경우의 최고점은  
(`i-1열`이 `패턴 2`로 놓여있을 경우의 최고점)과 (`i-1열`이 `패턴 3`으로 놓여있을 경우의 최고점) `중에서 큰 값`과
(`i열`에서 `패턴 2`로 돌이 놓인 곳에 있는 수)를 더한 값이 되겠다.

즉, 자신보다 `크기가 하나 작은 문제의 최적해`를 `자신의 최적해`를 구성하는데 사용하므로 최적 부분 구조를 가진다고 할 수 있다.  
이를 통해서 최적 부분 구조를 정리해보자.

![image](https://user-images.githubusercontent.com/64796257/150713368-062fcc63-f106-4fb5-8e73-6e104e7e0083.png)

![image](https://user-images.githubusercontent.com/64796257/150713403-4ec6ae17-8ff1-4324-bfd2-eb358ff9eb3f.png)

여기서의 `q`는 패턴 `p`와 `양립하는 패턴`을 말한다.

만약에 `패턴 p`가 `1`이라면 이에 `양립할 수 있는 패턴`은 `2,3`이므로 `q값`은 `2또는 3`이 될 수 있다. 

만약에 `패턴 p`가 `2`라면 이에 `양립할 수 있는 패턴`은 `1,3,4`이므로 `q값`은 `1또는 3또는 4`가 될 수 있다.

만약에 `패턴 p`가 `3`이라면 이에 `양립할 수 있는 패턴`은 `1,2`이므로 `q값`은 `1또는 2`가 될 수 있다.

만약에 `패턴 p`가 `4`라면 이에 `양립할 수 있는 패턴`은 `2`이므로 `q값`은 `2`가 될 수 있다.

여기서 `패턴이 4가 아니라면` 양립하는 열의 패턴은 `여러가지`가 나올 수 있기 때문에  
그 중에서 `최대값`을 골라야 하므로 `max`라는 기호를 사용했다.

의사 코드를 확인할 건데 `i`는 `i번째 열`을 의미하고 `p`는 어떤 패턴인지 의미힌다.  
![image](https://user-images.githubusercontent.com/64796257/150714320-27e5fb40-243b-419c-85e9-0ca57d572645.png)

- 만약에 `1번째 열의 값`을 알고 싶다면 곧바로 `W_(1,p)`를 출력해주면 된다 
- `q`는 `패턴 p`와 `양립할 수 있는 패턴`을 의미한다. 

maximum <- max(maximum, pebbie(i-1, q))의 의미는.  
처음에 `maximum`을 `0`이라 하고 `p = 1`이라 하자. 그러면 `p = 1`과 `양립`할 수 있는 패턴 `q는 2 또는 3`이 될 것이다. 

처음에는 `maximum = 0`과 `pebbie(i-1, 2)`의 값을 각각 비교한다.  
`pebbie의 값`은 양수이기 때문에 기존 `maximum값보다는 크므로` pebbie(i-1, 2)의 값이 새로운 maximum값이 된다.

그러고 나서 다시 `maximum`과 `pebbie(i-1, 3)`의 값을 각각 비교한다.  
여기서의 maximum값은 pebbie(i-1, 2)의 값을 의미한다. 

그래서 결국에는 `pebbie(i-1, 2)` 과 `pebbie(i-1, 3)`을 서로 비교하는 형태가 만들어진다.

의미를 풀어보면 `i-1번째 열`에 `패턴 2의 형태`로 놓았을 때의 `최대 합`과  
	        `i-1번째 열`에 `패턴 3의 형태`로 놓았을 때의 `최대 합`을 서로 비교한다는 의미가 된다. 

그 중에서도 내가 알고 싶은 건 `i번째 열`에 `패턴 1의 형태`로 놓았을 때의 `최대 합`을 알고싶은 거니까  
`두 값`들 중에서 `더 큰 값을 선택`하면 된다.

그렇게 `더 큰 값`을 선택하고 나서 `i번째 열`에 `패턴 1의 형태`로 놓았을 때의 값을 더해야  
비로소 `i번째 열`에 `패턴 1의 형태`로 놓았을 때의 `최대 합`을 알 수 있다.

그런데... 여기서 끝나면 재귀 호출 과정에서 중복호출 문제가 발생한다.

이를 통해서 돌 놓기 문제는 최적 부분 구조를 가지면서 재귀적 구현에서 중복 호출 문제가 발생하므로
동적 프로그래밍을 하기에 적절한 대상임을 알 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150720809-18a10270-0291-4357-b558-75ea087fa47b.png)

pebble의 부분 문제의 개수를 보면 `문제의 크기가 n`일 때 이에 따른 `패턴은 4개`로 정해져 있으므로 `부분 문제의 개수는 4n`이다. 

![image](https://user-images.githubusercontent.com/64796257/150720862-34077524-69fb-4368-aadd-8a2a9486762f.png)

`pebble(n)`의 의미를 보면 `1열부터 n열까지` 돌을 놓았을 때 `최대 합을 출력`하는 함수를 의미한다.

여기서는 부분문제가 되는 `C_(i,p)의 값`을 각각 계산하면서 저장까지 한다.  
이러한 과정을 통해 최대 합을 `bottom-up 방식`으로 값들을 저장하면서 구할 것이다.

i = 1부터 시작해서 i = 2일 때의 상황을 예시로 들어서 설명하면 금방 이해된다.

이에 대한 `시간 복잡도`와 `공간 복잡도`는 `O(n)`이다.

왜냐하면, 내가 원하는 `행렬의 열 크기`만큼 for문이 동작하고  
`부분문제의 개수` 역시 `행렬의 열 크기`와 선형적으로 `비례`하기 때문에 `시간/공간 복잡도`를 `O(n)`이라 할 수 있다.

### 행렬 곱셈 순서 문제 

#### 조건 및 규칙

![image](https://user-images.githubusercontent.com/64796257/150722595-c566c0df-ab2c-4eb2-8e61-74fa328ca3a3.png)

가장 단순한 방법은 앞에서부터 곱하는 방법이다. 

그런데 행렬의 곱셈은 `결합법칙`이 성립한다. 즉, `(AB)C = A(BC)`가 성립한다.  
따라서, n개의 행렬을 `2개씩 짝지어 계산`해도 결과는 동일하다. 다음은 `4개의 행렬을 곱`하는 모든 경우다.

![image](https://user-images.githubusercontent.com/64796257/150722678-51384f30-a184-406d-aa09-c05a91543370.png)

이렇게 5가지가 존재한다. 하지만, 괄호를 어떻게 바꾸든지 간에 `3번의 행렬 곱셈`을 한다는 건 변함없다.  
따라서, 일반적으로 `n개의 행렬 곱셈`에 대해서 `총 n-1번 의 곱셈`을 하게 된다.

하지만, `스칼라 곱`은 순서에 따라 달라질 수 있다. 3개의 행렬 A, B, C가 있다고 하자.  

A: 10 * 100, B: 100 * 5, C: 5 * 50

![image](https://user-images.githubusercontent.com/64796257/150722750-5a09e947-854e-49c3-bcff-226eaf9132a7.png)
![image](https://user-images.githubusercontent.com/64796257/150722752-e44eee78-23ce-486e-8e80-f434394a4849.png)

이러한 차이가 발생한다.

`n개의 행렬`을 곱하기 위해 `괄호를 묶는 방법`의 경우의 수는 `Ω(2ⁿ)`이 된다. 모든 경우의 수를 일일히 세는 건 비효율적이다.

#### DP 조건 만족 여부 및 구현 

![image](https://user-images.githubusercontent.com/64796257/150725637-8f7d7314-6c2f-4d9c-9975-4fd187e315e5.png)

![image](https://user-images.githubusercontent.com/64796257/150725700-f7ef6f67-e349-4914-ba05-612de92c7e57.png)

위의 계산 식 모두 `Ai ~ Aj`를 계산한 식이기 때문에 `C_(i,j)`의 값이 될 수 있는 후보들이다.  
그 중에서 최솟값이 바로 `C_(i,j)`가 된다.

그러면 어떻게 위와 같은 계산식이 나올 수 있을까. 그 이유는 아래와 같다. 

![image](https://user-images.githubusercontent.com/64796257/150726105-bbb82c16-e17d-45ea-81c6-8e49d6b7976c.png)

![image](https://user-images.githubusercontent.com/64796257/150726500-78497d97-0de7-42c0-91a6-43f0f68a6b25.png)

그 중에서 최소값이 되는 것을 찾으려고 한다. 다음과 같은 식을 세울 수 있다.  
![image](https://user-images.githubusercontent.com/64796257/150726532-53b3ae1f-307b-4e97-a5b0-5773bb886d80.png)

여기서 `i < j`인 이유는 위에서 계산한 것처럼 ![image](https://user-images.githubusercontent.com/64796257/150726575-5948a915-0eba-4b01-b4bf-b14b4c2e57b5.png)로 계산되기 때문에 `i < j`라는 대소관계가 성립.

이를 바탕으로 pseudo-code를 작성하면 아래와 같다. `matrix-chain(i,j)`는 `C_(i,j)`를 계산하는 함수다.  
![image](https://user-images.githubusercontent.com/64796257/150726625-52cfce9d-81a9-4e7a-aa86-b9a6e04c4d9e.png)

여기서 `minimum의 값`은 잡을 수 있는 최대한의 값으로 `초기화한 상태`에 함수를 시작한다.

하지만, 이러한 방식에서 끝나면 재귀호출의 중복이 심해진다.  

그러나, `A₁ × A₂ × ... × A_n`에 대한 C_i,j의 부분 문제의 개수는 ![image](https://user-images.githubusercontent.com/64796257/150726866-89730535-6c7a-4243-a0bf-aa2b300bc362.png)
개 밖에 되지 않으므로

각각의 해를 `아래부터 저장`하면서 구하는 동적 프로그래밍을 사용하는 것이 적합하다.

이제 각각의 `C_i,j`의 값을 저장하는 코드를 작성하자.

![image](https://user-images.githubusercontent.com/64796257/150726903-8eb5a5e5-9133-457c-a07b-17f8ec9b714d.png)

일단, 1부터 n까지 `C_i,i`의 값을 0으로 초기화. 

그렇게 하고 나서 `C_i,j의 값`을 구할 때마다 저장할 것이다. 이에 대한 시간 복잡도는 for문이 중첩되어 있기 때문에
![image](https://user-images.githubusercontent.com/64796257/150727013-2e441395-8a04-47f5-b0a5-fc0fbd95429b.png)
이라 할 수 있다.

함수의 return값은 `C_(1,n)`. 즉, `A₁ × A₂ × ... × A_n`을 계산할 때 발생하는 최소 스칼라 곱셈횟수가 된다.

### 최장 공통 부분 순서(Longest Common Sub-Sequence) 

[관련 코드](/CodingTest/DP/LCS.md)

#### 조건 및 규칙

두 문자열 `X_m`과 `Y_n`이 있다. 여기서 `m,n`은 `X_m과 Y_n 문자열`의 각각의 `길이`를 의미한다.

이때, 두 문자열의 `공통 부분`이 있을 수 있는데 공통 부분 중에서 `가장 긴 공통 부분의 길이`가 뭔지 알아내려 한다.  
⇒ 이를 이용한 것이 git의 `diff`가 되겠다.

뭔 말인지 이해하기 힘들 수 있으니 단계적으로 의미를 살펴보자.
- sub-sequence
ex. A**BC**B**D**A**B**가 있다고 할 때 해당 문자열 중에서 **BCDB**를 sub-sequence라 할 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150727452-04096e11-1fc8-4d58-a178-faf3b501167e.png)

#### DP 조건 만족 여부 및 구현

그럼 이것도 동적 프로그래밍을 적용할 수 있을까? 먼저 `최적 부분 구조`를 살펴보자.

![image](https://user-images.githubusercontent.com/64796257/150727486-47a98848-885b-42b8-8341-6b303cd075e2.png)

1) ![image](https://user-images.githubusercontent.com/64796257/150727494-5b99ca05-e829-4088-82d3-efb534486055.png)
이라면, 

`X_m`과 `Y_n`의 `LCS`는 `X_(m-1)과 Y_(n-1)의 LCS`보다 `1 크다`.  
왜냐하면, 이미 각 문자열의 끝 부분인 `x_m과 y_n`이 `서로 같아서` 해당 문자열의 이전 부분인 `X_(m-1)과 Y_(n-1)의 LCS`를 구하고  
`x_m = y_n`은 성립하므로 `1`만 더해주면 된다.

즉, `(m,n) 크기 문제의 해`는 `(m-1, n-1) 크기 문제의 해`를 `포함`한다고 할 수 있다.

2) ![image](https://user-images.githubusercontent.com/64796257/150727670-94e5c4ed-06d4-4a91-a933-527aacd75c32.png)
이면, 

`X_m과 Y_n의 LCS 길이`는 이미 ![image](https://user-images.githubusercontent.com/64796257/150727721-6435611f-b1a5-4856-8d97-58d60d62ffc0.png)
라는 조건을 내걸었기 때문에 X_m과 Y_n을 굳이 `다 비교할 필요는 없다`. 

그래서 `x_m` 또는 `y_n`을 `하나씩 제외`하고 `각각의 문자열을 비교`한다.  
그러면, `X_m과 Y_(n-1) 사이의 LCS`와 `X_(m-1)과 Y_n 사이의 LCS`를 각각 구해서 `더 큰 값`이 `X_m과 Y_n의 LCS`가 되겠다.

![image](https://user-images.githubusercontent.com/64796257/150727818-a0746e29-7712-47fe-b3c9-ab31090bbf34.png)

이를 통해 점화식을 구하면 다음과 같다.

![image](https://user-images.githubusercontent.com/64796257/150727883-21ec6a68-b1a0-4c5d-9564-838f80880f71.png)

`C_(i,j)`는 ![image](https://user-images.githubusercontent.com/64796257/150727900-032d60b1-9983-4dd2-9246-62a6c57f244b.png) 과 ![image](https://user-images.githubusercontent.com/64796257/150727911-3a751ad1-538d-464e-b2ae-54ca76084901.png)
의 LCS라 하자.

![image](https://user-images.githubusercontent.com/64796257/150728002-c03ae0bc-a6f8-4612-b581-27decec21ab9.png)

여기서 끝내면 중복 호출을 많이 발생시킨다. 그래서 아래서부터 시작해서 각각의 계산 결과값을 저장하면서 재귀적으로 함수를 진행한다.

![image](https://user-images.githubusercontent.com/64796257/150728046-e66e9610-b721-4c1b-9bd6-efaa9cd51047.png)

이렇게 되면 최종적으로 `길이가 m인 문자열`과 `길이가 n인 문자열`의 `LCS`를 구할 수 있다. 

`시간복잡도`는 m번 반복하는 for문을 n번 반복하므로 `mn`이 되고

`공간복잡도`는 `i가 1부터 m까지` 이고 `j가 1부터 n까지` 이므로 필요한 `C_(i,j)`의 저장 공간개수는 `mn`이 된다.

따라서, 둘 다 `Θ(mn)`이다.
