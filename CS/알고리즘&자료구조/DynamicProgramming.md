## DP(Dynamic Programming) 

### 개념 
: `동적 프로그래밍`은 `큰 문제의 해답`에 `작은 문제의 해답`이 포함되어 있고  
   이를 `재귀호출 알고리즘`으로 구현했을 때 `지나친 중복이 발생`하는 경우 그 `중복 문제를 해결`하는 방법을 말한다.

ex) 피보나치 수 구하기 

피보나치 함수를 f라고 하자. 그러면 아래와 같이 정의된다.

정의 : f(n) = f(n-1) + f(n-2) /  f(1) = f(2) = 1

이를 통해 `n의 피보나치 수`는 `n-1의 피보나치 수`와 `n-2의 피보나치 수`를 포함한다는 걸 알 수 있다.

이와 같이 `큰 문제의 해답`에 그보다 `작은 문제의 해답이 포함`되어 있으면 `최적 부분구조(optimal sub-structure)`를 가졌다고 한다.  
이는 `동적 프로그래밍`을 적용하기 위한 `첫 번째 성질`이다.

이러한 최적 부분 구조를 가진 문제는 재귀호출을 통해 문제를 풀 수 있다.

``` java
int fib(n) { 
   
   if(n == 1 || n == 2) return 1;
   
   else return fib(n-1) + fib(n-2);
  
} 
```

하지만, 위와 같은 재귀적 알고리즘은 `엄청난 비효율`을 초래할 수 있다.  
위에서 작성한 알고리즘을 통해 `n의 피보나치 수`를 구하게 되면 `지수함수에 비례`하는 시간이 소요된다. 

`T(n) = fib(n)의 시간 복잡도`라고 하면   
![image](https://user-images.githubusercontent.com/64796257/150709015-72b0d6c2-ee07-49b5-8b45-4ed5f5c10de5.png)

위와 같은 식이 전개된다. 이러한 식이 전개되는 이유는 다음 그림을 보면 알 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150709034-da2ea8b3-c9b6-4237-b02c-3e86487e6536.png)
![image](https://user-images.githubusercontent.com/64796257/150709037-fbcd032f-ed86-4cf6-ac56-313e7bcfc678.png)

왼쪽의 그림과 표와 같이 이미 호출한 `fib(1)`이나 `fib(2)`가 계속해서 반복호출 된다는 걸 알 수 있다.

이렇게 `재귀적으로 구현`했을 때 `중복 호출`로 인한 `심각한 비효율이 발생`하는 경우가 동적 프로그래밍을 사용하기에 적합한 `두 번째 조건`이다. 

정리하면, 다음 `두 성질이 있는 문제`에 대해 적절한 저장 방법으로 중복 호출의 비효율을 제거하는 것을 동적 프로그래밍이라 한다.

1) 최적 부분 구조를 이룬다.
2) 재귀적으로 구현했을 때 중복 호출로 인한 엄청난 비효율이 발생한다.

이를 해결하기 위한 두 가지 접근법을 소개한다.

### 접근법 

#### 1) Top-down Approach (a.k.a memoization)
⇒ 즉, `이미 계산한` 피보나치 함수의 값들을 기억해놨다가 해당 함수의 값을 사용하면 `저장해놨던 걸 재사용`한다.

![image](https://user-images.githubusercontent.com/64796257/150709221-aae843d5-652d-4fa2-bc12-3445c16ea695.png)

이를 위해서는 계산한 숫자를 저장하기 위한 `추가적인 공간`이 필요하다. 그 공간을 `cache`라고 한다.

![image](https://user-images.githubusercontent.com/64796257/150709253-d6d313ee-ee85-4ee2-a289-52744fe77529.png)

처음 n의 값은 가장 큰 값이었다. 만약에 n = 6이라면, `fib[6]`의 값 /`fib[5]`의 값/ `fib[4]`의 값 순서로 각각의 값들이 저장되는 것을 말한다.

시간 복잡도 : `T(n)` = T(n-1) + T(n-2) + C = T(n-1) + C = ... = `O(n)` ⇒ T(n-2)가 없어지는 이유는 저장한 공간에서 재사용하기 때문이다.

공간 복잡도 : n의 크기와 비례해서 커진다. 따라서, `S(n) = O(n)`

#### 2) Bottom-up Approach
- Tabulation : 피보나치 계산 결과들을 배열과 같은 저장소에 저장하는 방법

![image](https://user-images.githubusercontent.com/64796257/150710247-b3b73704-f7d4-4ec4-8697-cd5425b5205b.png)

`fib[0]`에서 부터 시작해서 각각의 값들을 배열에 저장한다.

![image](https://user-images.githubusercontent.com/64796257/150710271-1dd83265-2bd9-40a0-9556-517380a9ac7f.png)

이때 사용하는 테이블은 위에서와 마찬가지로 `cache 역할`을 한다. `시간 복잡도`와 `공간 복잡도`는 모두 `O(n)`이 된다.

### 정리

`동적 프로그래밍`은 재귀적 문제를 최적화하기 위한 방법이다.  
⇒ 그 중에서도 `중복으로 인한 비효율`이 있고 `최적 부분 구조(optimal sub-structure)`를 가져야 `동적 프로그래밍`을 이용할 수 있다.

- main idea : `sub-program의 해결책`을 `저장`해서 그 값들을 재사용해서 약간의 메모리를 사용해  
  `프로그램 자체의 속도`를 `빨라지도록` 하는 것을 목적으로 한다.

이제 `동적 프로그래밍(Dynamic programming)`을 사용하는 대표적인 문제에 대해 살펴보도록 하자.

### 행렬 경로 문제(Maximum Cost Path in a matrix) 

#### 조건 및 규칙 
- `양수`로 이루어진 `n×n` 행렬이 있다.
- 행렬은 `왼쪽 위`에서 시작해서 `1칸씩` 이동해 `오른쪽 아래`까지 도달한다.
- 이 과정에서 방문한 칸에 있는 수들을 더한 값이 이 경로의 합이다. 

이동 규칙 : 1. `오른쪽`이나 `아래쪽`으로만 이동할 수 있다. 2. `왼쪽`, `위쪽`, `대각선 이동`은 허용하지 않는다.

이러한 조건을 통해서 이동할 때 행렬의 원소 `(1, 1)`에서 `(n, n)`으로 이동하는 `모든 경로의 점수 중`에서 `가장 높은 점수`를 구하려고 한다.

이를 동적 프로그래밍을 통해서 구할 수 있는지 따져보겠다.

#### DP 조건 만족 여부 및 구현

step 1) 최적 부분구조가 있는지 확인.

행렬의 원소 `(1,1)`에서 `(i,j)`까지 도달하는 경로들의 점수 중에서 `최고점`을 구해보려 한다.  
`원소 (i,j)`에 `도달하기 직전에 방문`할 수 있는 원소는 `(i-1, j)`와 `(i, j-1)` 단 `두 개밖에` 없다. 

그렇다면, `(1, 1)`에서 `(i, j)`까지 도달하는 경로가 `최대`가 되기 위해서는  
`(i-1, j)`에서 `(i, j)`로 도달하는 경우와 `(i, j-1)`에서 `(i, j)`로 도달하는 경우 중에서 `점수가 높은 쪽을 선택`하면 된다.

즉, `문제 (i, j)의 최적해`는 `문제 (i, j-1)의 최적해`와 `문제 (i-1, j)의 최적해`로 설명할 수 있다.   

자신의 `부분 문제에 대한 최적해`를 자신의 `최적해를 구성하는데 사용`하므로 `최적 부분 구조`를  

이를 토대로 재귀적 관계를 정의하면 다음과 같다.

![image](https://user-images.githubusercontent.com/64796257/150712414-fa176ac5-2e44-48ee-84ca-2d2bcce46c2d.png)
![image](https://user-images.githubusercontent.com/64796257/150712423-47064396-9897-43cb-9da8-5f0fe31d15aa.png)

![image](https://user-images.githubusercontent.com/64796257/150712434-c29bae7a-84bf-4221-8229-b7c52dbd8ab9.png)

하지만, 이 상태에서 끝내면 `중복 호출`로 인해 `시간 복잡도`가 `지수함수`에 비례해서 커진다.  
그래서 `memoization` 즉, `각각의 값들`을 `저장할 수 있는 요소`를 넣어야 한다.  

`C_i,j`를 0으로 초기화했다고 할 때 아래와 같은 두 가지 버전으로 작성할 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150712551-7e45ae4f-413f-413b-902a-8861f20016c7.png)

표현만 다를 뿐 둘 다 각각의 계산 결과값들을 저장한다는 공통점이 있다.

### 돌 놓기 문제(Pebbling a Checkerboard) 

#### 조건 및 규칙
돌을 놓는 조건은 다음과 같다.
- 가로나 세로로 인접한 두 칸에 동시에 돌을 놓을 수 없다.
- 각 열에는 적어도 하나 이상의 돌을 놓는다. 여기서의 `열`은 column 즉, 세로를 의미한다.
  
ex)  
![image](https://user-images.githubusercontent.com/64796257/150712813-7c814696-6587-4bec-aa88-09f7a8407db8.png)

이러한 제한 조건 때문에 임의의 `하나 열`에 돌을 놓을 수 있는 방법은 총 `4가지`가 있다.

![image](https://user-images.githubusercontent.com/64796257/150712839-b41649c2-cbef-4643-a62c-72aa5c72470d.png)
![image](https://user-images.githubusercontent.com/64796257/150712843-18636bae-ce20-47f1-831d-2c5bfd03661a.png)

이러한 패턴을 바탕으로 서로 인접한 열에서 놓을 수 있는 패턴은 다음과 같이 정리할 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150712871-68122cf0-4f34-4979-9f9a-29dd73dfc80c.png)

그렇다면 이 구조가 최적 부분 구조를 가지고 있는지 확인해보자. 

#### DP 조건 만족 여부 및 구현 
n열 중 `1열부터 i열`까지 돌을 놓은 경우에 `1열부터 i열까지 합`의 `최고치`를 생각해보자.

그렇다면 i열은 4가지 패턴 중 하나로 돌이 놓일 것이다.

1) i열이 패턴 1인 경우의 최고점

2) i열이 패턴 2인 경우의 최고점

3) i열이 패턴 3인 경우의 최고점

4) i열이 패턴 4인 경우의 최고점 

이 중에서 `4)의 경우` `i-1열`은 `패턴 2`로 놓여야 한다. 

따라서 `i열`이 `패턴 4`로 놓여 있을 경우의 최고점은   
(`i-1열`이 `패턴 2`로 놓여있을 경우의 최고점) + (`i열`에서 `패턴 4`로 돌이 놓인 곳에 있는 수)의 값이다.

마찬가지로 `1)의 경우`를 보면 `i-1열`은 `패턴 2 또는 3`으로 놓여야 한다. 

그래서 `i열`이 `패턴 1`로 놓여 있을 경우의 최고점은  
(`i-1열`이 `패턴 2`로 놓여있을 경우의 최고점)과 (`i-1열`이 `패턴 3`으로 놓여있을 경우의 최고점) `중에서 큰 값`과
(`i열`에서 `패턴 2`로 돌이 놓인 곳에 있는 수)를 더한 값이 되겠다.

즉, 자신보다 `크기가 하나 작은 문제의 최적해`를 `자신의 최적해`를 구성하는데 사용하므로 최적 부분 구조를 가진다고 할 수 있다.  
이를 통해서 최적 부분 구조를 정리해보자.

![image](https://user-images.githubusercontent.com/64796257/150713368-062fcc63-f106-4fb5-8e73-6e104e7e0083.png)

![image](https://user-images.githubusercontent.com/64796257/150713403-4ec6ae17-8ff1-4324-bfd2-eb358ff9eb3f.png)

여기서의 `q`는 패턴 `p`와 `양립하는 패턴`을 말한다.

만약에 `패턴 p`가 `1`이라면 이에 `양립할 수 있는 패턴`은 `2,3`이므로 `q값`은 `2또는 3`이 될 수 있다. 

만약에 `패턴 p`가 `2`라면 이에 `양립할 수 있는 패턴`은 `1,3,4`이므로 `q값`은 `1또는 3또는 4`가 될 수 있다.

만약에 `패턴 p`가 `3`이라면 이에 `양립할 수 있는 패턴`은 `1,2`이므로 `q값`은 `1또는 2`가 될 수 있다.

만약에 `패턴 p`가 `4`라면 이에 `양립할 수 있는 패턴`은 `2`이므로 `q값`은 `2`가 될 수 있다.

여기서 `패턴이 4가 아니라면` 양립하는 열의 패턴은 `여러가지`가 나올 수 있기 때문에  
그 중에서 `최대값`을 골라야 하므로 `max`라는 기호를 사용했다.

의사 코드를 확인할 건데 `i`는 `i번째 열`을 의미하고 `p`는 어떤 패턴인지 의미힌다.  
![image](https://user-images.githubusercontent.com/64796257/150714320-27e5fb40-243b-419c-85e9-0ca57d572645.png)

- 만약에 `1번째 열의 값`을 알고 싶다면 곧바로 `W_(1,p)`를 출력해주면 된다 
- `q`는 `패턴 p`와 `양립할 수 있는 패턴`을 의미한다. 

maximum <- max(maximum, pebbie(i-1, q))의 의미는.  
처음에 `maximum`을 `0`이라 하고 `p = 1`이라 하자. 그러면 `p = 1`과 `양립`할 수 있는 패턴 `q는 2 또는 3`이 될 것이다. 

처음에는 `maximum = 0`과 `pebbie(i-1, 2)`의 값을 각각 비교한다.  
`pebbie의 값`은 양수이기 때문에 기존 `maximum값보다는 크므로` pebbie(i-1, 2)의 값이 새로운 maximum값이 된다.

그러고 나서 다시 `maximum`과 `pebbie(i-1, 3)`의 값을 각각 비교한다.  
여기서의 maximum값은 pebbie(i-1, 2)의 값을 의미한다. 

그래서 결국에는 `pebbie(i-1, 2)` 과 `pebbie(i-1, 3)`을 서로 비교하는 형태가 만들어진다.

의미를 풀어보면 `i-1번째 열`에 `패턴 2의 형태`로 놓았을 때의 `최대 합`과  
	        `i-1번째 열`에 `패턴 3의 형태`로 놓았을 때의 `최대 합`을 서로 비교한다는 의미가 된다. 

그 중에서도 내가 알고 싶은 건 `i번째 열`에 `패턴 1의 형태`로 놓았을 때의 `최대 합`을 알고싶은 거니까  
`두 값`들 중에서 `더 큰 값을 선택`하면 된다.

그렇게 `더 큰 값`을 선택하고 나서 `i번째 열`에 `패턴 1의 형태`로 놓았을 때의 값을 더해야  
비로소 `i번째 열`에 `패턴 1의 형태`로 놓았을 때의 `최대 합`을 알 수 있다.

그런데... 여기서 끝나면 재귀 호출 과정에서 중복호출 문제가 발생한다.

이를 통해서 돌 놓기 문제는 최적 부분 구조를 가지면서 재귀적 구현에서 중복 호출 문제가 발생하므로
동적 프로그래밍을 하기에 적절한 대상임을 알 수 있다.


### 행렬 곱셈 순서 문제 












### 최장 공통 부분 순서(Longest Common Sub-Sequence) 














