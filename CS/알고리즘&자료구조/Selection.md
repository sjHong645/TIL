## 선택 알고리즘(selection)

n개의 원소로 된 집합에서 `최소 원소`를 찾기 위해서 `적어도 n-1번의 비교`가 필요하다. 이때 n에 비례하는 시간, 즉 `선형시간`이 소요된다.  
`최대 원소`를 찾을 때도 마찬가지다. 

그럼 `두 번째로 작은 원소`를 찾기 위해서는?  
지금까지 살펴본 원소 중에서 최소 원소와 두 번째로 작은 원소를 저장해서  
이를 갱신해가는 과정을 거치면 되겠다. 이 역시 마찬가지로 `선형 시간`에 구할 수 있다.

그렇다면, 일반적으로 `n개의 원소` 중에서 `i번째 작은 원소`를 찾기 위해서는 시간이 얼마나 필요할까?

ex. `중앙값`을 찾는다고 해보자. 

만약에 `최솟값`부터 시작해서 `n/2 번째 원소`까지 저장하면서 계속 갱신한다면, 이는 시간복잡도가 `O(n²)`인 비효율적인 방법이 되겠다. 

이를 어떻게 해결할 수 있을까?? 이에 대해서 이번 장에서 배울 것이다.

### 1) 평균 선형 시간 선택 알고리즘

#### 과정 
이번 장에서 소개하는 알고리즘은 `최악의 경우`에도 `선형 시간`에 `i번째 작은 원소`를 찾을 수 있게 한다.

n개의 원소가 무작위로 저장된 배열에서 i번째 작은 원소를 찾는다고 하자.

먼저 `퀵 정렬`에서 사용한 `분할 알고리즘`을 생각해보자.  
`분할 알고리즘`은 기준원소보다 작거나 같은 원소는 `왼쪽 그룹`으로 기준원소보다 큰 원소는 `오른쪽 그룹`으로 재배치한다.

분할 알고리즘이 return 하는 값으로 기준원소가 `전체에서 몇 번째 작은 원소`인지 알 수 있다.

이 방법을 통해서 `기준원소`가 `전체에서 k번째 작은 원소`란 사실을 알았다고 하자. 이제 `i`와 `k`값을 비교한다.

- i < k ⇒ i번째 작은 수는 왼쪽 그룹에 있는 원소 중 하나다.
- i = k ⇒ k번째 작은 수 즉, 기준원소가 바로 i번째 작은 수이다.
- i > k ⇒ i번째 작은 수는 오른쪽 그룹에 있는 원소 중 하나다.

ex. 선택 알고리즘을 통해 10개의 원소로 구성된 배열에서 2번째 작은 원소를 찾는 예시

![image](https://user-images.githubusercontent.com/64796257/150661014-2d8f6d3e-1e2f-4f78-86a3-f42e07022ecc.png)

`기준원소`는 `r`이 가리키고 있는 15이다.

`15`를 중심으로 `왼쪽 그룹`과 `오른쪽 그룹`을 각각 나누면 두 번째 그림과 같이 `왼쪽 3개` / `오른쪽 6개`로 나뉜다.

이를 통해, `기준원소 15`는 배열의 `4번째로 작은 숫자`이므로 `2번째 작은 숫자`는 `15보다 왼쪽에 위치`한다는 걸 알 수 있다

여기서 2번째 작은 원소를 찾는 과정은 배열의 크기가 작아졌을 뿐 앞에서의 과정과 똑같다. 같은 알고리즘을 재귀적으로 호출하면 된다.

#### 구현 

``` java
    public static <T extends Comparable<T>> int partition(T[] array, int left, int right) {
        int mid = (left + right) >>> 1;
        T pivot = array[mid];

        while (left <= right) {
            while (less(array[left], pivot)) {
                left++;
            }
            while (less(pivot, array[right])) {
                right--;
            }
            if (left <= right) {
                swap(array, left, right);
                left++;
                right--;
            }
            // number++;
        }
        return left;
    }
  
  // Generic 을 사용하기 위해서 배열의 자료형을 Integer로 사용함.
  // 세세한 구현의 내용보다는 전체적인 내용을 파악하는데 집중하자.
  
  // 전체 배열 arr의 index번째 작은 값을 찾는 
  public int selection(Integer[] arr, int index) {
		return select(arr, 0, arr.length - 1, index);
	}
	
	private int select(Integer[] Arr, int p, int r, int i) {
		
		QuickSort part = new QuickSort();
		int q;
		
		if(p == r) return Arr[p];
		
    // 배열 Arr의 q ~ r 부분 중에서 기준 인덱스를 하나 설정했다.
    // 그 값을 q에 저장한다.
		q = part.partition(Arr, p, r);
		
    // k값의 의미는...
    // 기준 인덱스인 q가 실제 배열에서 몇 번째로 작은지를 나타낸다.
    // 이에 대한 의미는 아래에서 좀 더 자세히 설명하겠다.
		int k = q - p + 1;
		
    // i값이 k보다 작다면 p ~ q-1 부분에서 i번째 작은 값을 찾도록 하고
		if(i < k) return select(Arr, p, q-1, i);
		
    // i == k라면 A[q] 값을 return하면 되고
		else if(i == k) return Arr[q];
		
    // i값이 k보다 크다면 q+1 ~ r 부분에서 i-k번째 작은 값을 찾도록 한다.
    // i - k인 이유는
    
    // 원래 전체 배열에서 i번째 작았던 값이 있는데 
    // 부분을 따로 나누면서 k개 만큼 배열의 앞부분이 사라졌다. 
    
    // 그러면서 배열의 시작값이 0에서 k로 바뀌면서 
    // 전체 배열의 i번째 값은
    // 오른쪽 부분의 i-k번째 값이라고 해야 동일한 값을 가리킬 수 있다.
		else return select(Arr, q+1, r, i-k);
		
	}   
```

##### k의 의미 
예를 들어 기준원소의 `index값`을 `4`라하면, q는 4가 되는데 대충 그림을 그리면 아래와 같다.  
![image](https://user-images.githubusercontent.com/64796257/150661568-5049269f-d146-48e4-8d86-b6d8b8b491d8.png)

`q`가 `4`라는 건 `q가 가리키는 값`이 `전체 배열에서 5번째로 작은 원소`라는 것을 의미한다.  
`k의 값`은 기준원소가 `전체 배열에서 몇 번째로 작은지`를 의미하는 값으로 저장했다.

이때, `p값(=배열의 시작값)`은 늘 바뀔 수 있다. 그래서 `k = (q-p) + 1`이라고 설정해야 한다.

그렇게 k값까지 설정하고 나서 i와 k를 비교해서 대소관계에 따라서 재귀적으로 함수를 실행하면 되고

만약에 `i = k`라면, `k번째 작은 원소 = A[q]의 값`을 return 하면 되겠다.

##### i-k인 이유 

![image](https://user-images.githubusercontent.com/64796257/150661762-b057dcf9-0ff3-45f6-9bc0-8050664a2024.png)

#### 수행시간 

기준원소가 전체 집합에서 `k번째 작은 원소`이면 두 그룹은 각각 `k-1`개, `n-k`개로 나뉜다. 이에 따른 알고리즘 수행시간은 다음과 같다.

![image](https://user-images.githubusercontent.com/64796257/150661774-1d1f5cd4-373c-4655-a10f-8e0164ae5dfb.png)

`T(k-1)`과 `T(n-k)`는 재귀호출에 관련된 비용으로 그 중에서 더 많은 시간을 소요하게 된 값을 선택한다.  
`Θ(n)`은 자기호출을 제외한 나머지 오버헤드로 분할에 관련된 비용이 대부분이다. 

입력 배열은 가능한 모든 경우가 골고루 일어난다고 가정하면, 전체 배열에서 `기준원소의 순위 k`는 `1부터 n까지 동일한 확률`로 선택될 수 있다.   
이를 반영해서 관계식을 세우면 아래와 같다.

![image](https://user-images.githubusercontent.com/64796257/150661800-ab51ac74-9684-42df-8f19-9c7022e7fbd5.png)

![image](https://user-images.githubusercontent.com/64796257/150661804-1bb5b6dd-00e5-454c-80eb-076b81dd4723.png)


⇒ 이를 통해 해당 알고리즘은 평균적인 경우 `Θ(n)` 의 시간이 소요되지만 최악의 경우에는 `Θ(n²)`이 소요된다.  

여기서 말하는 `최악의 경우`는 분할할 때마다 `왼쪽은 0개`의 원소가 있고 `오른쪽은 n-1개`의 원소가 있는 상황이다.

최악의 경우의 수행시간 점화식은 `T(n) = T(n-1) + Θ(n)` 이 되기 때문에 이를 전개했을 때 `T(n) = Θ(n²)`이 된다.

### 2) 최악의 경우에도 선형 시간을 보장하는 선택 알고리즘

#### 과정 
앞서 소개한 알고리즘은 `pivot으로 고른 원소`가 `분할의 균형이 맞지 않는다면` 최악의 경우 `Θ(n²)` 성능을 보이게 된다.  
이러한 단점을 개선한 알고리즘이 이번 알고리즘이다.

본론에 들어가기 전에 1)에서의 알고리즘에서 계속 `1:9로 분할`되고 이 중에서 `9에 해당하는 부분`을 계속 탐색한다고 하자.  
이런 식으로 계속 반복하면 수행시간은 어떻게 될까? 이 경우에는 다음 점화식으로 표현할 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150661876-1c50023c-fa67-4af1-969d-c36784ff14a8.png)

즉, `입력의 크기가 n`인 문제를 풀기 위해 `Θ(n)`의 overhead를 사용한 다음 입력의 크기가 ![image](https://user-images.githubusercontent.com/64796257/150661891-356871a3-7419-40bd-8e7d-a5ad303b7867.png)
인 문제를 재귀적으로 호출한다. ⇒ 이것을 계산하면 `T(n) = Θ(n)`이 된다. 

`1:99로 분할`해서 `99에 해당하는 부분을 탐색`했을 때 시간 복잡도도 `T(n) = Θ(n)` 가 된다.

정리하면, 분할의 균형이 아주 나빠보여도 `일정 상수비만 넘지 않는다면` `점근적 복잡도`는 항상 `T(n) = Θ(n)`을 보장한다는 걸 알 수 있다.

따라서, 이번에 소개할 알고리즘은 `분할의 균형을 어느 정도 맞춰줘서` 최악의 경우라 할 지라도 `Θ(n)`을 보장한다.

그렇지만 분할의 균형만 적당히 맞춘다고 `Θ(n)`이 무조건 보장되는 건 아니다.  
균형을 맞추는 overhead가 너무 커져버리면 오히려 복잡도가 더 커질 수도 있기 때문이다.

![image](https://user-images.githubusercontent.com/64796257/150662054-7e65e915-be83-43da-85e6-28b7f0d33799.png)
![image](https://user-images.githubusercontent.com/64796257/150662061-bfba5643-31f9-4f91-ae71-fc250a77f03c.png)

그렇게 `중앙값들의 중앙값`을 `pivot`으로 정하고 나서 그 값을 기준으로 `분할`을 하고  
분할을 하고나서 `왼쪽 그룹`과 `오른쪽 그룹`에서도 위에서의 과정과 똑같이 반복하면서 선택해주면 되겠다.

⇒ 이러한 방식을 사용하면 pivot의 순서는 배열의 `상위 30% ~ 70% 사이`에 위치한다는 걸 보장해준다.

![image](https://user-images.githubusercontent.com/64796257/150662106-7403213d-a63b-4748-b8a3-8200ff676b8a.png)

25개의 원소를 가진 배열을 5개의 그룹으로 나눴다. 각각의 그룹의 `중앙값의 중앙값`은 `14`라는 것을 알 수 있다.

이렇게 정하면 각각의 그룹이 오름차순으로 정렬되어 있는 상황에서  
`3번째 그룹`에 있는 `중앙값`은 `1,2번째 그룹`에 있는 `중앙값`보다 `크다`. 대소관계는 다음과 같다.

(1,2번째 그룹에 있는 중앙값) < (3번째 그룹에 있는 중앙값)

여기서 `1,2번째 그룹에 있는 중앙값`은 `자신의 그룹에 있는 2개의 원소`보다는 더 크다. 대소관계는 다음과 같다.

(1번째 그룹에 있는 앞의 2개의 값) < (1번째 그룹에 있는 중앙값)  
(2번째 그룹에 있는 앞의 2개의 값) < (2번째 그룹에 있는 중앙값)

그리고 3번째 그룹에 있는 중앙값 역시 자신의 그룹에 있는 2개의 원소보다 더 크다. 
(3번째 그룹에 있는 앞의 2개의 값) < (3번째 그룹에 있는 중앙값)

⇒ 이렇게해서 `(1,2,3번째 그룹에 있는 앞의 2개의 값) & (1,2번째 중앙값) < (3번째 그룹에 있는 중앙값)`이 된다는 것은 보장할 수 있다.  

이 부분을 표시한게 `파란 상자`이다.

`빨간 상자`에 있는 부분은 같은 원리로 `3번째 그룹에 있는 중앙값` 보다 `큰 값`이라는 것은 보장할 수 있는 값들이다.

그렇다면 어떻게 구현할 수 있을까??

![image](https://user-images.githubusercontent.com/64796257/150662307-ca2dbc7c-09ff-49c1-b5d2-21f74d2c2187.png)

1. 배열 A를 5개의 그룹으로 나눈다.

2. 각각의 그룹에서 `중앙값(median)`을 찾는다. i번째 그룹의 중앙값은 `m_i`라 하겠다.

3. 중앙값의 중앙값을 찾는다. 그 값을 `M`이라 하겠다.

4. 그렇게 찾은 `M`을 `pivot`으로 해서 전체 원소를 분할한다. (`M보다 작은 값`들은 `M의 왼쪽`에 `M보다 큰 값`들은 `M의 오른쪽`에)

5. 찾고자 하는 값이 `M`보다 크다면 `오른쪽에서 재귀적으로 진행`하면 되고 / `M`보다 작다면 `왼쪽에서 재귀적으로 진행`하면 된다.

#### 성능 평가 

![image](https://user-images.githubusercontent.com/64796257/150662540-3e1c3ad4-2e4d-4459-832a-3d5e4d374ea0.png)

1)은 n개의 원소를 5개짜리 그룹으로 나누는 동작이다. 이 동작은 각 원소를 한 번씩만 지나가면서 속 그룹을 정하기 때문에 `Θ(n)`만큼의 시간복잡도가 필요하다.

2)는 각 그룹에서 중앙값을 찾고 그 작업을 ![image](https://user-images.githubusercontent.com/64796257/150662567-3d29717a-a77c-4573-a172-ea7286b4661f.png)
 번 한다. 그래서 `Θ(n)`의 시간복잡도가 걸린다.
 
3)은 mom-select의 시간복잡도를 T(n)이라 했는데 이때 입력하는 데이터는 ![image](https://user-images.githubusercontent.com/64796257/150662574-6444f573-18d9-452a-ab85-5d71a33c4939.png)
개의 중앙값이다. 즉, 입력 개수가 ![image](https://user-images.githubusercontent.com/64796257/150662578-47fc7b63-f662-4456-b17a-92ac7aed1c46.png)
라는 말이므로 3)에서의 시간복잡도는 T(![image](https://user-images.githubusercontent.com/64796257/150662590-4a43a870-181e-4b4b-bc1c-5e326012addb.png)
)가 된다.

4)는 pivot을 기준으로 퀵 정렬을 하는 것이기 때문에 `Θ(n)`만큼 걸린다.

5)는 재귀호출인데 최악의 경우에서 입력할 수 있는 최댓값은 ![image](https://user-images.githubusercontent.com/64796257/150662613-0dc7bea0-f129-4114-84be-8fab160cd8c2.png)
이므로 시간복잡도는 T(![image](https://user-images.githubusercontent.com/64796257/150662614-57886d0f-4dfe-4a1e-a0fa-5cb9683e2843.png)
)가 된다.

따라서 수행 시간의 점화식은 ![image](https://user-images.githubusercontent.com/64796257/150662616-20af4fd5-dca4-425e-9e8c-ce3aa1a62330.png)
 가 된다.

최종적인 증명은 귀납적 증명법을 이용해서 증명할 수 있다.(p.147) 따라서, `T(n) = O(n)`이 된다.


#### 실제로 30% ~ 70%를 보장하는가? 

![image](https://user-images.githubusercontent.com/64796257/150662370-aaff1dd5-2948-4f8a-97da-3b9bd2dbd605.png)

이런식으로 나눴다고 할 때 가장 바람직한 경우에는 `pivot`이 되는 원소를 기준으로 정확하게 반반 나눠지는 것이다.  
하지만, 그런 상황이 될 가능성은 매우 낮다.

`최악의 경우`에는 모두 한 쪽으로 몰리는 경우인데 

위의 그림과 같이 pivot보다 무조건 `작은 값들도 존재`하고 무조건 `큰 값도 존재`하기 때문에 0 : n-1 과 같이 한쪽으로 몰리지는 않을 것이다. 

그래서 최악의 경우는 아래 그림과 같은 상황이라 할 수 있겠다.

![image](https://user-images.githubusercontent.com/64796257/150662393-806c572e-18ec-4c78-8f3a-3c7dcaea09f4.png)
![image](https://user-images.githubusercontent.com/64796257/150662400-a91e6bc0-3ba0-4633-8a59-3cc03291e4ec.png)

원소의 개수는 위와 같다.

그렇다면, `x`는 어떤 값일까??
그림을 보면 pivot이 있는 그룹을 기준으로 오른쪽에 있는 그룹의 개수는 ![image](https://user-images.githubusercontent.com/64796257/150662415-b42bd948-ee55-4c9f-9ec1-fe8dbf0efbe4.png)
개 라고 할 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150662469-ec5b4d2c-d97f-449d-b36a-533d33d0eccc.png)

오른쪽 그룹의 원소 개수를 세려고 한다.  

pivot이 포함된 그룹에서 pivot보다 큰 원소의 개수는 2개. 맨 마지막 그룹에서 pivot보다 큰 원소의 개수는 1개만 있다고 하자.  
그러면 2개를 제외한 ![image](https://user-images.githubusercontent.com/64796257/150662700-5a61c2b3-9e70-474f-9321-b4d234b73715.png)
개의 그룹에는 pivot보다 큰 원소의 개수가 

![image](https://user-images.githubusercontent.com/64796257/150662707-5ba8da4c-f248-4e2b-87d1-9f6e339b9abf.png)개라고 할 수 있다. 

왜냐하면, `pivot을 포함한 그룹`과 `맨 마지막 그룹`을 제외한 나머지 그룹에서는 `pivot보다 큰 원소`를 각각 3개씩 가졌기 때문이다.

따라서, 아래와 같은 식을 세울 수 있다.

![image](https://user-images.githubusercontent.com/64796257/150662771-2f41c263-40a5-48d2-a54a-5c3957bf07f5.png)

이를 통해 pivot의 오른쪽 부분의 원소는 최소 ![image](https://user-images.githubusercontent.com/64796257/150662781-07a6ea2d-e279-4e92-a26e-f548bf5b41c4.png)
개 있다고 할 수 있다.

이를 통해 비례식을 세우면 

![image](https://user-images.githubusercontent.com/64796257/150662787-8ba58717-5c46-4ae2-9426-de5e3a3595cf.png)

= ![image](https://user-images.githubusercontent.com/64796257/150662794-689c51d3-370f-45ae-b3e3-0246d4df11c7.png)
= ![image](https://user-images.githubusercontent.com/64796257/150662795-14a78a6c-9b25-4185-9450-bae3b1e6decd.png)

이므로 대략 `7 : 3`의 비율이 나타난다는 것을 알 수 있다.

이는 오른쪽을 제외한 모든 원소가 `다 왼쪽으로 몰렸을 때` 생기는 비율이다.  

만약에 왼쪽을 제외한 모든 원소가 `다 오른쪽으로 몰린다면` `|left partition|:|right partition| = 3:7`이 된다.

그래서 pivot의 순위는 `상위 30% ~ 70% 사이`에 있다고 말할 수 있는 것이다.

![image](https://user-images.githubusercontent.com/64796257/150662818-47d9bc97-715b-415c-b5e7-18cdda373751.png)





















