## RBT; RedBlackTree

`레드 블랙 트리`는 이진 탐색 트리의 모든 노드에 `빨강` 또는 `검정`을 칠한다.  
단, 아래의 성질을 만족하도록 색칠해야 하는데 이를 `레드 블랙 특성`이라 한다.

1) 루트 노드는 `Black`이다.
2) 모든 리프(NIL)은 `블랙`이다.(내가 알던 리프 노드와 다름 주의)
3) 노드가 `빨간색`이면 그 `노드의 자식`은 반드시 `검정색`이다.
4) `루트 노드`에서 `임의의 리프 노드`에 이르는 경로에서 만나는 `블랙 노드의 수`는 `모두 같다`.

![image](https://user-images.githubusercontent.com/64796257/150300461-c60a1eba-f3d0-429e-b8f3-299b9e57f833.png)

`레드 블랙 트리`를 실제로 구현할 때 `NIL 리프`를 어떻게 다루는지 살펴보도록 하자. 

그림처럼 하나씩 노드를 할당하는 방법도 있지만 이는 불편한 점이 많다.

그래서 노드 하나를 할당해서 이를 `리프`로 정하고 `모든 NIL 리프`에 대한 포인터가 이 노드를 가리키도록 하면 된다.

![image](https://user-images.githubusercontent.com/64796257/150300537-db60ee27-f792-4272-9bd4-4c2944ab0451.png)

레드 블랙 트리에서 `탐색`은 트리의 내용을 건드리지 않으므로 이진 검색 트리에서의 탐색과 동일하다.

다만, `삽입`과 `삭제`는 데이터 자체가 바뀌는 과정이기 때문에 레드 블랙 트리의 특성을 위반하는 경우가 발생할 수 있다.  
이때는 적절한 작업을 통해 `삽입과 삭제` 이후에도 레드 블랙의 특성을 만족하도록 바로잡아 주어야 한다.

### 삽입 

레드 블랙 트리에서 노드를 삽입할 때 먼저 이진 탐색 트리의 삽입 알고리즘에 따라 삽입을 한 다음에 새 노드의 색상을 `레드`로 색칠한다.

삽입에 관한 내용은 이진 검색 트리에서 다뤘다. 그 내용을 바탕으로 레드 블랙 트리에서도 삽입은 이뤄진다.

그리고 새 노드를 `빨간색으로 칠했을 때` 레드 블랙 트리의 특성을 만족시키지 않을 경우 어떻게 조치할 것인지에 대해 살펴볼 것이다.

그렇다면 일단 이진 탐색 트리의 삽입의 결과로 인해 새로운 노드가 추가되었고 새로운 노드를 x라 하겠다. 

일단 새로운 노드는 `빨간색`으로 칠한다. ⇒ 그렇다면 새로운 노드의 부모 노드 p는 무조건 `검은색`이어야 한다.  
만약에 새로운 노드의 부모 노드가 `빨간색`이라면 이는 레드 블랙의 특성을 위반하는 것이기 때문이다.

![image](https://user-images.githubusercontent.com/64796257/150343463-97373fce-55a4-40a3-b60a-2b3c0d30335b.png)
![image](https://user-images.githubusercontent.com/64796257/150343468-45dd9695-4d7d-4167-b71d-cbd04a79942b.png)

새 노드의 부모 노드는 검은색이라면 이는 레드 블랙의 특성을 만족한 것이다.

그럼, 새 노드가 빨간색이라면? 이에 대한 조치가 필요하다. 이에 대해서 배운것이 목적이다.

그런데 x가 삽입되기 전에는 `레드 블랙 트리`였다. 그래서 루트 노드인 g는 일단 검은색이다.

![image](https://user-images.githubusercontent.com/64796257/150343599-af30ff59-b479-4782-988b-7a73a3e88906.png)

그렇다면 x의 형제 노드인 `s` 역시 레드 블랙 특성을 만족시키던 상황이였으니까 위 그림과 같이 검은색 노드였을 것이다.

이를 통해 x 주변에서 레드와 블랙 두 가지가 모두 가능한 건 p의 형제노드 u뿐이다.

`u의 색깔`에 따라서 다음 두 가지 경우로 나누고 각각의 해결방법은 아래와 같다.

1) u가 `빨간색` 

![image](https://user-images.githubusercontent.com/64796257/150343724-a9a34318-5126-4cae-aac2-d43b970355de.png)

u가 빨간색이라면 순서대로 x의 부모 노드와 똑같은 레벨에 있는 노드들의 색깔을 검정색으로 바꾼다. 

그렇게 냅두면 p와 u는 `검정색`인데 g까지 `검정색`인 상황이 생기니까 g가 root 노드가 아닌 이상 `빨간색`으로 바꾼다.

만약에 g위에 더 많은 부모노드들이 존재한다면 이러한 과정을 `재귀적으로 반복하면서` 색깔을 바꿔준다.

2) u가 `검은색`
u가 검정색일 때는 여기서 4가지 case로 또 나눌 수 있다.  

ⅰ) p가 g의 왼쪽 자식 노드이면서 x가 p의 오른쪽 자식노드일 때(LR 상태)  
![image](https://user-images.githubusercontent.com/64796257/150344027-1eaa3d36-b3fb-4e7b-8f74-1b5a25a07b50.png)

ⅱ) p가 g의 왼쪽 자식 노드이면서 x가 p의 왼쪽 자식노드일 때(LL 상태)  
![image](https://user-images.githubusercontent.com/64796257/150344086-05fcfc79-e4c8-48c2-b85d-ba7850eb1b40.png)

ⅲ) p가 g의 오른쪽 자식 노드이면서 x가 p의 왼쪽 자식노드일 때(RL 상태)    
![image](https://user-images.githubusercontent.com/64796257/150344136-985f0ce8-7f09-464b-baeb-876eb398d1fc.png)

RL상태인 이유는 큰 구조를 봤을 때 RR상태다. 그리고 g의 오른쪽 서브 노드를 보면 해당 트리는 LL상태다. 그래서 `RL상태`라고 얘기한다.

ⅳ) p가 g의 오른쪽 자식 노드이면서 x가 p의 오른쪽 자식노드일 때  
![image](https://user-images.githubusercontent.com/64796257/150344221-6a071f7c-6b02-44d8-9185-9f15855ef77a.png)

cf) `LL상태`를 해결하기 위한 회전이 `LL회전` / `RR상태`를 해결하기 위한 회전이 `RR회전`이다.

이러한 레드 블랙 트리의 삽입과정을 pseudo-code로 표현하면 다음과 같다.

1) `x라는 노드`를 이진 탐색 트리의 삽입과정에 따라 삽입하고 x의 색깔을 `빨간색`으로 지정한다.
2) 만약에 x가 `root 노드`라면, 레드 블랙 특성에 맞춰 `x를 검정색`으로 바꾼다.
3) x가 root노드가 아니라면, x의 부모노드인 `p`가 `빨간색`인지 확인한다. ⇒ `검정색`이라면 색깔을 고칠 필요없다.

```
if( case 1에 해당한다면 = x에서 u의 노드가 빨간색이라면)
- p와 u를 검정색으로 바꾸고 p와 u의 부모노드인 g를 빨간색으로 바꾼다. 
- 이러한 과정을 g에 대해서 재귀적으로 반복한다.

else if( case 2-1에 해당한다면 ) // LR 상태
- p에 대해서 RR회전을 하고 2-2를 이용한다.

else if( case 2-2에 해당한다면 ) // LL 상태
- g에 대해서 LL회전하고 p와 g의 색깔을 바꾼다.

else if( case 2-3에 해당한다면 ) // RL 상태
- p에 대해서 LL회전하고 2-4를 이용한다.

else if( case 2-4에 해당한다면 ) // RR 상태
- g에 대해서 RR회전하고 p와 g의 색깔을 바꾼다.

```
### 삭제 

크게 두 가지 과정으로 진행된다.
1) 이진 탐색 트리의 삭제 과정에 따라 노드를 삭제한다.
2) 트리를 case에 따라서 re-arrange(재조정)한다.

여기서 짚고 넘어가야 할 내용은 다음과 같다.

ex) 임의의 노드 d를 삭제한다고 하자. 

- 이진 탐색 트리의 삭제과정
 
1) 해당 노드 d를 곧장 없애버리는 게 아니라 `d를 대체`할 `다른 노드 m`을 찾는다
2) 여기서 대체할 값인 `m`은 `오른쪽 서브트리의 최솟값`이라 하겠다
3) m을 찾고 m에 저장되어 있던 내용을 `기존의 d가 있던 자리`에 넣는다.  
4) m을 삭제한다.


이때, m을 삭제하고 나서 `RBT의 특성`을 만족시키지 못할 수 있다. 이에 대해서 알아보자.

그렇다면 m 노드는 `자식 노드 개수`에 따라 3가지 경우로 나눌 수 있다.
1) 자식 노드가 `0개` 일 때
2) 자식 노드가 `1개` 일 때
3) 자식 노드가 `2개` 일 때
⇒  하지만, `m 노드`는 자식 노드를 `2개` 가질 수 없다.
    왜냐하면, `m 노드`는 삭제한 노드였던 `d 노드의 오른쪽 서브 트리`의 `최솟값`을 갖고 있기 때문이다.
    이진 트리의 특성상 하나의 노드를 기준으로 왼쪽 서브 트리로 이동할 수록 값이 작아지는데  
    `m 노드`는 `트리의 최솟값`이니까 `왼쪽 서브 트리`는 `없`다.  
    그래서, m 노드의 자식 노드는 1개 아니면 0개가 된다.

이제부터 위에서 얘기했던 `m 노드`를 `d 노드`라 하겠다. 헷갈리지 않길 바랍니다.

d 노드(m 노드)를 삭제하기 이전에 이미 RBT였기 때문에 이에 대한 특성은 모두 만족시킨 상태였을 것이다.

### d 노드를 가지고 만들 수 있는 3가지 경우

d 노드를 가지고 크게 3가지 경우를 만들 수 있다.  
(d 노드가 빨간색이면서 자식 노드 c는 빨간색일 수 없다. 이는 레드 블랙 특성을 위반하는 상황이다)

#### 1) d 노드가 `빨간색`이고 자식 노드 c가 `검정색`일 때

![image](https://user-images.githubusercontent.com/64796257/150345384-e9a2c1cc-c3f0-4a3d-810b-c98be53d6ed0.png)

이때는 그냥 `d를 삭제`하면 된다. c가 `빨간색`이 아니기 때문에 부모 노드의 색이 바뀔 필요가 없고

d가 `빨간색`이어서 4번째 레드 블랙 특성인 

“루트 노드에서 임의의 NIL에 이르는 경로에서 만나는 검정색 노드의 개수가 같아야 한다”라는 특성에 대해서도 생각할 필요는 없다. 

왜냐하면 d는 검정색이 아니라서 NIL에 이르는 경로에서 만나는 검정색 노드의 개수가 줄어들지 않기 때문이다.

#### 2) d 노드가 `검정색`이고 자식 노드 c가 `빨간색`일 때

![image](https://user-images.githubusercontent.com/64796257/150345695-c01fb99c-2262-4a9d-a575-ce58abbfc3df.png)

`d를 삭제`하고 나서 c를 `검정색`으로 바꿔주면 된다.

애초에 c밑에 있는 NIL은 c 노드가 `빨간색`이었기 때문에 해당 NIL에 이르는 경로에서 만나는 검정색 노드의 개수에 c 노드는 포함되지 않는다.

대신 d 노드가 삭제되면서 NIL에 이르는 경로에서 만나는 검정색 노드가 하나 줄었으므로 c 노드의 색깔을 검정색으로 바꿔주기만 하면 된다.

#### 3) d 노드가 `검정색`이고 자식 노드 c가 `검정색`일 때 – 여기가 문제다. 여기에서 모든 문제가 시작된다.

![image](https://user-images.githubusercontent.com/64796257/150345795-7d270987-b06d-4c61-b5b5-ef872e760ff4.png)

삭제할 노드가 d였을 때 d를 삭제하고 나면 위 그림과 같이 레드 블랙의 4번째 특성을 만족하지 못하게 된다.

이러한 상황을 어떻게 처리할 지는 앞으로 보일 여러가지 경우에 따라서 달라진다.

##### case 1) p가 빨간색일 때 ⇒ 그렇다면 자동으로 s는 검정색이 된다.

![image](https://user-images.githubusercontent.com/64796257/150346299-337ab4e9-4dc8-44ce-aa0a-e130f16bad03.png)

이렇게 되면 l과 r의 색깔에 따라서 경우의 수를 나눌 수 있다.
1) <l, r> = <검, 검>
2) <l, r> = <빨, 빨> or <검, 빨> ==> <*, 빨>
3) <l, r> = <빨, 검>

##### case 2) p가 검정색 일 때 

![image](https://user-images.githubusercontent.com/64796257/150346486-0a5ba506-2113-4d00-9dac-d6a2ba7079a0.png)

이렇게 되면 s와 l과 r의 색깔에 따라서 경우의 수를 나눌 수 있다.
1) <s, l, r> = <검, 검, 검>
2) <s, l, r> = <검, 빨, 빨> or <검, 검, 빨> ==> <검, *, 빨>
3) <s, l, r> = <검, 빨, 검>
4) <s, l, r> = <빨, 검, 검>

그럼 각각의 case에 대해서 레드 블랙 트리의 삭제가 어떻게 이뤄지는지 살펴보자.

##### case 1-1) p가 `빨간색`이고 `<l, r> = <검, 검>` 일 때

![image](https://user-images.githubusercontent.com/64796257/150346299-337ab4e9-4dc8-44ce-aa0a-e130f16bad03.png)
![image](https://user-images.githubusercontent.com/64796257/150346604-29fa9fa9-5330-49b7-8b18-eaba75d35571.png)

앞에서 d와 c가 `검정색`이면 문제가 되는 이유가  
레드 블랙의 4번째 특성인 “NIL로 향하는 경로 상에 블랙 노드의 개수”가 맞지 않게 된다는 점에서 문제가 되었다.

이를 맞춰주기 위해서 p와 s의 색깔을 서로 바꿔줬다.  
이러면 `p`에서 `l` 또는 `r`를 거치는 경로위에 있는 `블랙 노드의 개수`는 변함이 없으면서  
`p`에서 `c`를 거치는 경로에는 `블랙노드의 개수가 1개 추가`되서 결과적으로 레드블랙 특성을 만족하게 된다.

##### case 1-2) & 2-2) p의 색깔에 상관없이 `<l, r> = <*, R>` // `<s, l, r> = <B, *, R>`

==> 좀 더 자세하게 보면 `p`가 `빨간색`이면(case 1) `s`는 무조건 `검정색`이다  
==> `p`가 `검정색`이면(case 2) `s`는 어떤 색깔이어도 상관없다.

![image](https://user-images.githubusercontent.com/64796257/150346813-e033efca-373b-490f-8534-8a3bcc7c4ad1.png)

먼저 `p`에 대해서 `왼쪽으로 회전(left rotation)`한다.

그러면 `s`는 자식 노드 3개가 생겨버리는데  
이는 이진 트리의 정의에 어긋나므로 `s`의 왼쪽 서브 노드인 `l 노드`를 `p의 오른쪽 서브노드`로 넘겨준다.

그렇게 하고 나서 p와 s의 색깔을 바꿔주고 빨간색이었던 r은 검정색으로 바꾼다.

##### case 1-3) & 2-3) p의 색깔에 상관없이 `<l, r> = <R. B>` // `<s, l, r> = <B, R, B>`

![image](https://user-images.githubusercontent.com/64796257/150347079-bb1b351c-3780-41d0-94d4-a4d8dba0247e.png)

일단 `s`에 대해서 `오른쪽으로 회전(Right rotation)`한다. 그러면 `l 노드의 오른쪽 서브 노드`는 `s의 왼쪽 서브노드`가 된다. 

그렇게 하고 나서 `l`과 `s`의 색깔을 바꾸면 `case *-2)의 경우`가 나타난다. 그에 따라서 해결해주면 된다.

![image](https://user-images.githubusercontent.com/64796257/150347582-fdb9cd19-ff2c-4f7b-839f-fde26cd3eaf9.png)

위의 두 그림을 보면 왜 `case *-2`와 똑같은지 알 수 있다.

##### case 2-1) `<s,l,r>` = `<B, B, B>`

![image](https://user-images.githubusercontent.com/64796257/150347623-89ad2d69-a9f0-4aaa-8caf-66b1fb34092a.png)

이때는 `검은색`이었던 `s`를 `빨간색`으로 바꾼다.

그러면 `p`에서 `l`, `r`로 향하는 경로에 있는 `검정색 노드`가 하나 줄면서 `c`에서 생긴 문제가 `p`에서 생긴 문제로 바뀐다.

p에서 생긴 문제 역시 똑같이 p 노드의 형제 노드를 빨간색으로 바꾸면서 재귀적으로 문제를 해결하면 되겠다.

##### case 2-4) `<s,l,r>` = `<R, B, B>`

![image](https://user-images.githubusercontent.com/64796257/150347764-b715311a-4d78-4695-bf9d-09203b426e7a.png)

먼저 `p`에 대해서 `왼쪽으로 회전`한다. 

그렇게 하고나서 `s의 왼쪽 자식 노드`인 `l 노드`를 `p의 오른쪽 자식노드`로 옮긴다. 그렇게 회전을 하고나서 `s`와 `p`의 색깔을 바꿔준다.

이후에는 `p`가 `빨간색`이 되면서 해당 노드는 case 1이 된다. 따라서 `case 1-*`의 방식으로 해결하면 된다.

### RBT의 시간복잡도 

키의 총 개수가 n개인 RBT의 가능한 최대 높이는 O(logn)이다. 

![image](https://user-images.githubusercontent.com/64796257/150348314-55bb3d11-fe41-45b9-b5d0-29a7129195ae.png)

fact : 블랙 노드의 개수가 bh(v)라면 internal node의 개수는 최소 2^(bh(v))-1 개가 있다.

RBT의 높이를 h라 하자. 높이가 h라는 건 트리마다 각각의 단계가 있는데 그 단계의 개수가 h라는 뜻이다.

즉, 루트 노드에서 부터 NIL로 이르는 경로를 지나는 black node의 개수는 최대 h개까지 될 수 있다.  
그렇다면, 최소 검정색 노드의 개수는 `h/2개` 이다.

왜냐하면, 레드 블랙 트리의 특성상 부모 노드가 검은색 노드일 때 자식 노드는 검은색 또는 빨간색이 될 수 있지만

부모가 빨간색 노드라면 자식 노드는 무조건 검은색 노드여야 한다.

그렇기 때문에 루트 노드에서 NIL로 이르는 경로를 지나는 노드들이 모두 빨간색이 될 수 없다.  
빨간색이 되려면 자식 노드는 무조건 검정색이어야 한다. 

이러한 조건에서 검정색 노드를 최소 개수로 사용하기 위해서는 단계를 내려갈 때마다 색깔을 계속 바꾸면 된다.

그래서 검정색 노드의 최소 개수는 h/2가 된다.

이제 위에서 소개한 fact를 통해서 검정색 노드의 최소 개수가 h/2이기 때문에 

RBT는 최소 `2^(h/2) - 1` 개의 internal node가 있다는 것을 알 수 있다.

이때, h/2는 최솟값이기 때문에 `2^(h/2) - 1` 역시 RBT가 가지는 최소 노드의 개수가 된다.

그러므로, `2^(h/2) - 1` 전체 노드의 개수는 n 보다 작다.

![image](https://user-images.githubusercontent.com/64796257/150349007-6933f5ac-fc7e-4426-9751-1a56bfd8bdb6.png)

따라서, n개의 노드를 가지고 있는 RBT는 최대 O(logn)의 높이를 가진다고 할 수 있다.

- 시간복잡도 
1) 탐색 : 높이의 최댓값이 O(logn)이기 때문에 시간복잡도는 O(logn)이 된다.

2) 삽입 & 삭제 : re-coloring & rotation은 상수 시간만큼 소요된다. 
		그리고 트리의 높이가 O(logn)이기 때문에 이에 비례해서 O(logn)의 복잡도를 가진다 할 수 있다.

- 공간복잡도 : O(n) ⇒ n개의 노드들을 저장해야 하기 때문에 O(n)의 공간이 필요하다.
















