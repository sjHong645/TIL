## Hash

### 개념 

- key를 비교하면서 찾아가는 것 대신 `key에 대응되는 항목의 위치`에 `바로 접근`하는 방법
- 입력 key에 대한 `산술적인 연산`을 통해 `항목이 저장되어 있는 위치(index)`를 직접 계산해서 접근

![image](https://user-images.githubusercontent.com/64796257/150664227-30e39178-1935-4d77-b40b-d1e0942574ef.png)

`탐색 key에 대한 주소`를 `Hash Table`에 저장한다. 

이때, 주소를 정하는 기준은 `Hash Function`에 의해서 결정된다.

그래서 key를 입력받아서 Hash 함수를 통해 index가 출력된다는 `h(key) = index` 라는 표현을 쓴 것이다.

### 발생할 수 있는 문제 

![image](https://user-images.githubusercontent.com/64796257/150664240-67a686f0-c00b-4bbe-ad89-309d8db2b484.png)

그렇다면 

Q1) 해시 함수를 어떻게 설계해야 충돌을 줄일 수 있을까?
Q2) 오버 플로우가 발생하면 어떻게 처리해야 할까? 

### 설계 

#### 해시 함수의 조건
1) `임의의 key값`, `k`를 입력으로 받으면 `해시 테이블이 M개의 bucket을 가진다`고 할 때 `h(k) ∈ [0, M-1]` 여야 한다.

2) `충돌(collision)`이 적어야 한다. 즉, 함수의 출력값이 테이블의 주소 영역 내에 `고르게 분포`되야 한다. 

3) 계산이 `빠르게` 이뤄줘야 한다.

#### 대표적인 3가지 해시 함수

##### 1) Division Function ==> h(k) = k % M 

장점 : 나머지 연산이기 때문에 계산이 빠르다. `O(1)`만큼의 시간이 소요된다.

단점 : `M`을 `적절하게 고르지 못하면` 출력이 골고루 분포되지 않을 수 있다.  
ex. k값이 짝수이면서 M = 8이라면 h(k)의 값으로는 전체 0~7중에서 0, 2, 4, 6 만 쓸 수 있다.

그래서 일반적으로는 `M을 소수(prime number)`를 사용한다. 하지만, 여전히 충돌 가능성은 존재한다.

##### 2) Mid-squares Function
⇒ 충돌을 줄이기 위해서(해시 출력 분포를 고르게 하기 위해서) `탐색 key를 제곱`해서 `중간 숫자(bits)를 취하고` `%M`을 수행한다.
    
![image](https://user-images.githubusercontent.com/64796257/150667649-414535c5-6192-4d0b-bc63-a5e7ddc88392.png)

##### 3) Folding Function 
⇒ `입력 key의 모든 bit들`을 활용하기 위해 탐색 키를 `여러 folds(겹)`로 나눠서 활용한다. 

![image](https://user-images.githubusercontent.com/64796257/150667827-75f839cc-b3f7-4c0e-ace3-a35f8deccdc2.png)
![image](https://user-images.githubusercontent.com/64796257/150667829-0dbca7b1-7a7c-46fc-ae33-1634e5661b37.png)

#### 충돌을 해결하는 대표적인 2가지 방법 

##### 1) Separate Chaining(닫힌 어드레싱 방법) 
⇒ 무슨 일이 있어도 자기 자리에 저장하는 방법 

그런데 어떻게 이게 가능할까? 이를 위해서 `연결 리스트`를 사용한다.  
`체이닝`은 `연결 리스트`를 이용해서 슬롯을 연결하는 방법으로 닫힌 어드레싱 방법을 대표한다.

- 특징
1. bucket에 고정된 slot이 아닌 삽입/삭제가 용이한 리스트로 구성
2. 리스트에 계속 저장할 수 있기 때문에 overflow는 발생하지 않음
3. Bucket 내에서는 순차 탐색을 수행

![image](https://user-images.githubusercontent.com/64796257/150667871-85860bb5-845f-4a19-b342-15b02631d5ed.png)

위 그림과 같이 슬롯을 생성해서 `연결 리스트`의 모델로 연결해나가는 방식으로 충돌 문제를 해결하는 걸 `체이닝`이라 한다.

체이닝 방법을 적용하면 `하나의 해쉬값`에 `다수의 슬롯`을 둘 수 있다.  
그래서 탐색을 위해 `동일한 해쉬 값으로 묶여 연결된 슬롯`을 모두 조사해야 하는 불편함이 있다.

하지만, 해쉬 함수를 잘 정의함으로써 `충돌 확률이 높지 않다면` 연결된 슬롯의 길이는 부담스러운 정도는 아니다

- 장점 : 충돌 해결 방법이 간단하다. 항목을 삽입할 때 `O(1)` 만큼의 시간만 필요
- 단점 : 어떤 bucket은 사용되지 않을 수 있다. 탐색/삽입에서 순차 탐색의 비용이 발생한다. 

##### 2) Open Addressing 

: 모든 아이템들을 slot 내에 저장하는 방식. 대표적으로 3가지 방식이 있다.

###### ① 선형 조사법(Linear Probing) 
: 충돌이 발생했을 때 그 옆자리가 비었는지 살펴보고 비었을 경우 그 자리에 대신 저장하는 방법.  

예를 들어 다음과 같이 해쉬 함수를 정의한 `f(x)`가 있고 `테이블의 내부 저장소`가 `배열`이라고 하자. 

해쉬 함수 : key % 7

`key = 9`인 데이터의 해쉬값은 `2`가 된다. 따라서 다음과 같이 `index = 2인 위치`에 저장된다.  
![image](https://user-images.githubusercontent.com/64796257/150667965-78741d54-ef88-4d7a-b6e8-2259f06b83ad.png)

이어서 `key = 2`인 데이터를 저장하려고 한다. 이 데이터의 해쉬 값은 `2`이기 때문에 앞서 저장한 데이터와 충돌이 발생한다.  
이렇게 `충돌이 발생`했을 때 바로 `옆자리 index = 3`인 자리를 살펴보는 것이 `선형 조사법`이다.  
따라서 데이터 2를 저장한 결과는 다음과 같다.  
![image](https://user-images.githubusercontent.com/64796257/150667989-6ee0fd5d-ee46-42ab-aba9-5e7a46f8a81b.png)

만약에 옆자리가 비어있지 않는다면 한 칸 더 이동해서 자리를 살핀다.  

정리하면, k의 키에서 충돌 발생시 `선형 조사법`의 조사 순서는 다음과 같이 전개된다.

f(k) +1 ==> f(k) +2 ==> f(k) +3 ==> f(k) +4 ---

또는 

![image](https://user-images.githubusercontent.com/64796257/150668010-43fc2a15-d3f0-4cd5-949d-9ed84524b7a8.png)

k를 해쉬 함수 h에 입력한다. 충돌이 발생하지 않는다면 h(k)의 출력값에 따라 key값을 넣으면 된다.  
그런데 충돌이 발생한다면 `h(k) + i`의 값을 `해쉬 함수 h`에 입력한다. 그걸 0부터 M까지 충돌이 발생하지 않을때까지 반복한다.

이때, `Linear Probing 방식`으로 `Remove`를 진행한다면 어떻게 될까?

![image](https://user-images.githubusercontent.com/64796257/150668046-b181fe19-f4b2-4310-9a67-f85b71115a3d.png)

해쉬 함수 h(k) = h % 10 // `15를 삭제`하고 나서 `25를 탐색`하려 한다. 

그런데 `25의 나머지값`은 `5`이기 때문에 `충돌`이 발생하면서 옆에 있는 index를 살펴보는데  
`선형 조사법`에 의하면 `현재 5`의 옆에 `아무런 값이 없으니까` 이 지점에서 `탐색이 종료`된다. 

하지만, 사실 25는 여전히 존재한다. 이러한 문제는 `Dirty bit`를 추가해서 해결한다.  
![image](https://user-images.githubusercontent.com/64796257/150668076-e3517747-b108-4f57-958a-9e6eca32b1be.png)

`Dirty bit`가 `empty`일 때 probing을 멈추도록 하면 remove를 하고 나서의 탐색 문제를 해결할 수 있다.

이러한 선형 조사법은 `메모리의 낭비가 적다`는 장점이 있지만  
충돌의 횟수가 증가함에 따라 특정 영역에 데이터가 집중적으로 몰리는 `클러스터(cluster) 현상`이 발생한다는 단점이 있다.  
이는 데이터 충돌의 확률을 높이는 직접적인 원인이 된다. 그렇다면 이러한 선형 조사법의 단점을 어떻게 극복할까?

###### ② 이차 조사법(Quadratic Probing) 
조금 먼 곳에 빈 공간을 찾으면 될 것이다. 이러한 생각을 근거로 탄생한 것이 `이차 조사법`이다. 
이차 조사법의 조사 순서는 다음과 같이 전개된다.

![image](https://user-images.githubusercontent.com/64796257/150668111-2585b94a-4187-41ea-b1ab-a5ac288b02f2.png)

선형 조사법이 `n칸 옆의 슬롯`을 검사한다면, 이차 조사법은 `n²칸 옆의 슬롯`을 검사한다. 

![image](https://user-images.githubusercontent.com/64796257/150668160-44923289-a2a4-4a86-a353-83a7fdb989bb.png)

`선형 조사법`만큼 연속적인 집중이 생성되지는 않지만 부분적인 집중이 생길 여지는 충분하다.

###### ③ 이중 해시법(Double Hashing or Rehashing) 

이전까지 빈 슬롯을 찾는 방법이 규칙적이었는데 이번에는 빈 공간을 선택하는 방식을 `불규칙하게` 구성하면 될 것 같다.  
이를 반영한 방법이 `이중 해쉬`방법이다. 이는 2개의 해쉬 함수를 사용하기 때문에 붙여진 이름이다.

`하나`는 앞서 보인것과 마찬가지로 `키(key)`를 근거로 저장위치를 결정하는 것이다.  
`다른 하나`는 `충돌이 발생했을 때`, `몇 칸 뒤에 위치`한 슬롯을 살펴볼지 그 `거리`를 결정하기 위한 것이다.

확실한 이해를 위해 이중 해쉬의 두 해쉬 함수를 정의해보자. 먼저 배열을 저장소로 하는 테이블이 존재한다고 하자.  
이 테이블의 해쉬 함수가 다음과 같이 정의되어 있다고 할 때 이중 해쉬 관점에서 `1차 해쉬 함수`가 된다.
```
1차 해쉬 함수 : h1(k) = k % 15 
```
이렇게 1차 해쉬함수가 결정되면 다음 식을 근거로 `2차 해쉬함수`를 결정하게 된다.
```
2차 해쉬 함수 : h2(k) = 1 + (k % c)
```
`1차 해쉬 함수`를 `%15`로 결정한 것으로 보아 `배열의 길이가 15`라는 걸 예상할 수 있다.  

이런 경우 `c`는 `15보다 작은 소수(素數 prime Number)`중 하나로 결정하게 된다.  
따라서 다음과 같이 1,2차 해쉬 함수를 결정할 수 있다.
```
1차 해쉬 함수 : h1(k) = k % 15 
2차 해쉬 함수 : h2(k) = 1 + (k % 7) c = 7이라고 조건에 맞춰 임의로 정한 값이다. 다른 값으로 해도 상관없다.
```

2차 해쉬 함수의 활용에 대한 예시를 하나 보자.
앞서 정의한 1차 해쉬 함수의 3개의 키 3, 18, 33을 적용해서 해쉬 값을 구하면 다음과 같다. 

h1(3) = 3 % 15 = 3
h1(18) = 18 % 15 = 3
h1(33) = 33 % 15 = 3

때문에 3, 18, 33 순서로 데이터를 저장하면 키가 `18, 33인 데이터`를 저장할 때 `충돌이 발생`한다.  
이번에는 2차 해쉬 값을 계산해보자.

h2(18) = 1 + (18 % 7) = 5
h2(33) = 1 + (33 % 7) = 6

보다시피 `1차 해쉬 값`은 같아도 `2차 해쉬 값`은 다르다는 걸 알 수 있다.  
그리고 2차 해쉬 값을 근거로 빈 슬롯을 찾는 과정은 다음과 같이 전개된다.

![image](https://user-images.githubusercontent.com/64796257/150668360-e363add0-438c-43fe-9426-9b715461bcd9.png)

또는

![image](https://user-images.githubusercontent.com/64796257/150668363-2b43f6eb-d26c-4f96-a8f9-22fe98b70db3.png)

위 이미지에서 step은 1차 해쉬 함수값을 의미한다.

`h2(18)`의 값은 원래 `5`인데 그 위치에 다른 값이 있다면 단계적으로 `5를 계속 더하는` 방식.  
`h2(33)`도 마찬가지. 원래 값 `6`에서 단계적으로 `6을 계속 더하는` 방식.

이렇듯 2차 해쉬 값의 크기만큼 건너뛰면서 빈 슬롯을 찾게 되므로 키가 다르면 건너 뛰는 길이도 달라진다.  
따라서 `클러스터(cluster) 현상`의 발생확률을 현저히 낮출 수 있다. 

![image](https://user-images.githubusercontent.com/64796257/150668446-a4990e48-a15b-4218-9ab6-7e5f740a2fae.png)
![image](https://user-images.githubusercontent.com/64796257/150668449-58be61c0-6efc-4200-8e72-bf2c02da6672.png)

![image](https://user-images.githubusercontent.com/64796257/150668452-9453e676-5bce-4421-89d4-731339944957.png)



























