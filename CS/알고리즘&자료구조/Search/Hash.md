## Hash

### 개념 

- key를 비교하면서 찾아가는 것 대신 `key에 대응되는 항목의 위치`에 `바로 접근`하는 방법
- 입력 key에 대한 `산술적인 연산`을 통해 `항목이 저장되어 있는 위치(index)`를 직접 계산해서 접근

![image](https://user-images.githubusercontent.com/64796257/150664227-30e39178-1935-4d77-b40b-d1e0942574ef.png)

`탐색 key에 대한 주소`를 `Hash Table`에 저장한다. 

이때, 주소를 정하는 기준은 `Hash Function`에 의해서 결정된다.

그래서 key를 입력받아서 Hash 함수를 통해 index가 출력된다는 `h(key) = index` 라는 표현을 쓴 것이다.

### 발생할 수 있는 문제 

![image](https://user-images.githubusercontent.com/64796257/150664240-67a686f0-c00b-4bbe-ad89-309d8db2b484.png)

그렇다면 

Q1) 해시 함수를 어떻게 설계해야 충돌을 줄일 수 있을까?
Q2) 오버 플로우가 발생하면 어떻게 처리해야 할까? 

### 설계 

#### 해시 함수의 조건
1) `임의의 key값`, `k`를 입력으로 받으면 `해시 테이블이 M개의 bucket을 가진다`고 할 때 `h(k) ∈ [0, M-1]` 여야 한다.

2) `충돌(collision)`이 적어야 한다. 즉, 함수의 출력값이 테이블의 주소 영역 내에 `고르게 분포`되야 한다. 

3) 계산이 `빠르게` 이뤄줘야 한다.

#### 대표적인 3가지 해시 함수

##### 1) Division Function ==> h(k) = k % M 

장점 : 나머지 연산이기 때문에 계산이 빠르다. `O(1)`만큼의 시간이 소요된다.

단점 : `M`을 `적절하게 고르지 못하면` 출력이 골고루 분포되지 않을 수 있다.  
ex. k값이 짝수이면서 M = 8이라면 h(k)의 값으로는 전체 0~7중에서 0, 2, 4, 6 만 쓸 수 있다.

그래서 일반적으로는 `M을 소수(prime number)`를 사용한다. 하지만, 여전히 충돌 가능성은 존재한다.

##### 2) Mid-squares Function
⇒ 충돌을 줄이기 위해서(해시 출력 분포를 고르게 하기 위해서) `탐색 key를 제곱`해서 `중간 숫자(bits)를 취하고` `%M`을 수행한다.
    
![image](https://user-images.githubusercontent.com/64796257/150667649-414535c5-6192-4d0b-bc63-a5e7ddc88392.png)

##### 3) Folding Function 
⇒ `입력 key의 모든 bit들`을 활용하기 위해 탐색 키를 `여러 folds(겹)`로 나눠서 활용한다. 


    
    
    
    
    
    
    







