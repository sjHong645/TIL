## 그래프(Graph) : 임의의 두 개체의 연결 관계를 표현한 자료구조

![image](https://user-images.githubusercontent.com/64796257/150704868-a5972b62-3d2e-4802-83a1-74b70d7f89a2.png)

### 정의 
: `정점의 집합`과 `간선의 집합`의 `쌍(pair)`으로 정의되어 있다.  

G = (V, E) : `V`는 `정점(노드)`의 집합 / `E`는 `간선`의 집합이다.

ex)  
![image](https://user-images.githubusercontent.com/64796257/150704903-85112f3d-3f56-41da-9f5c-21fb49578c16.png)

### 종류 
1) 방향 그래프  
![image](https://user-images.githubusercontent.com/64796257/150704978-09186cf8-595e-43c0-9b52-a0422a724253.png)


2) 무방향 그래프  
![image](https://user-images.githubusercontent.com/64796257/150704987-379be35c-c19a-4728-ba93-6c0607607d2b.png)


3) 가중치 그래프  
![image](https://user-images.githubusercontent.com/64796257/150704991-0c5aaa74-6eac-406a-84ac-9994bbb67aeb.png)

### 용어 

1) 인접 정점   
![image](https://user-images.githubusercontent.com/64796257/150705011-04d1583f-7ca3-44a3-a3a8-dbcab51857b0.png)

2) 정점 차수   
![image](https://user-images.githubusercontent.com/64796257/150705020-450b43e9-1cb8-400d-aa70-778058fc0bf1.png)

3) 경로 : 그래프에서 간선을 따라 갈 수 있는 길 

- 경로의 길이 : 경로를 구성하는데 지나간 간선의 개수  

![image](https://user-images.githubusercontent.com/64796257/150705103-7b10e997-0067-4759-aef0-b05a26e4559d.png)

![image](https://user-images.githubusercontent.com/64796257/150705114-b34b8d24-5e19-4fc8-9d43-1fe21f97ce98.png)

![image](https://user-images.githubusercontent.com/64796257/150705120-842ca4ef-2db3-49e5-a2ee-682d93f11c4c.png)

### 그래프 표현 방법 
아래와 같은 그래프가 있다.   
![image](https://user-images.githubusercontent.com/64796257/150705166-90a4417e-a6e8-487d-a94d-101496869273.png)

1) 인접 행렬로 표현 

![image](https://user-images.githubusercontent.com/64796257/150705183-72b60b35-81de-4f02-835f-57a7b7da5a06.png)
![image](https://user-images.githubusercontent.com/64796257/150705191-b93abc4f-a716-448d-a6fe-b221c409f7b4.png)

2) 인접 리스트로 표현  

![image](https://user-images.githubusercontent.com/64796257/150705233-01589eb1-7b98-4302-b961-70ea0ec32a4c.png)
![image](https://user-images.githubusercontent.com/64796257/150705242-f159dba7-a7a2-4d86-8de0-96a930af4886.png)

### 구현

#### 인접 행렬 클래스 구현

##### 구조 

원래 `key 벡터`는 다음과 같이 저장된다. ⇒ 0 2 3 1

여기서 indices의 index값들을 `key`로 이용할 것이다.

![image](https://user-images.githubusercontent.com/64796257/150705687-e1e5b988-8c72-499f-b09f-180d7f0459f2.png)
![image](https://user-images.githubusercontent.com/64796257/150705692-de44d2e6-cb76-48aa-b365-5ebef2633530.png)

이런 관계다.
indices[1] = 3 ⇒ 1이라는 key를 가진 행렬의 index 값은 3
indices[2] = 1 ⇒ 2라는 key를 가진 행렬의 index 값은 1
indices[3] = 2 ⇒ 3이라는 key를 가진 행렬의 index 값은 2

여기서 vector는 C++에서 사용한 자료구조다. Java에서는 `ArrayList`를 vector 대신 사용할 것이다. 

``` java
import java.util.ArrayList;
import java.util.NoSuchElementException;

enum DirectionType{
	DIRECTED, 
	UNDIRECTED;
}

enum WeightType{
	WEIGHTED, 
	UNWEIGHTED;
}

public class MatrixGraph {
	
	private ArrayList<Integer> keys;
	private ArrayList<Integer> indices;
	private ArrayList<ArrayList<Double>> A;
	DirectionType d_type;
	WeightType w_type;
	
	public MatrixGraph(DirectionType d_type, WeightType w_type) {
		this.d_type = d_type;
		this.w_type = w_type;
		A.add(new ArrayList<Double>()); // dummy
		indices.add(0); // dummy
		keys.add(0);    // dummy
	}
	
	public int get_index(int key) {
		if(indices.get(key) == null) {
			
			throw new NoSuchElementException("Key of the node doesn't exist");		
		}
		return indices.get(key);
	}
}

```







#### 인접 리스트 클래스 구현



























