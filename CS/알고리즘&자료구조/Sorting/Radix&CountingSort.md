## Radix sort(기수 정렬) 

### 과정

#### 1번째 이해 
기수 정렬은 정렬순서상 앞에 있는지 뒤에 있는지를 판단하기 위한 `비교연산을 하지 않는다`.

그리고 시간 복잡도 `O(nlogn)`을 넘을 수 있는 유일한 알고리즘이기도 하다.

하지만, 적용할 수 있는 범위가 `제한적`이라는 단점이 있다.  
예를 들어 다음 문장은 기수 정렬로 해결할 수 있다. 

- 정수배열 1, 7, 9, 5, 2, 6을 오름차순으로 정렬.
- 영단어 red, why, zoo, box를 사전편찬 순서대로 정렬.

반면, 다음 문장은 기수 정렬로 해결할 수 없다.
- 배열에 저장된 21, -9, 125, 8, -136, 45를 오름차순으로 정렬
- 영단어 professionalism, few, hydroxyproline, simple을 사전편찬 순서대로 정렬

⇒ 데이터의 `길이가 서로 같지 않다면` 기수 정렬을 사용하는데 있어서 제한이 있다.  

물론, 길이가 서로 다르면 다른 알고리즘을 사용해서 기수 정렬을 사용할 수 있지만 
굳이 별도의 알고리즘을 고민하고 효율의 문제를 감수하면서 `기수 정렬`을 사용할 필요는 없다.  

이제 `한 자리의 10진수 정수`들을 `기수 정렬`을 이용해서 정렬해보자.

![image](https://user-images.githubusercontent.com/64796257/150620484-c6cca79c-331f-466c-9600-ba275a8b6c67.png)

이렇게 10진수 정수의 정렬을 위해 총 10개의 `버킷`이 필요하다.  
`버킷`은 0부터 9까지 순서대로 이름이 메겨져 있고 정렬대상은 값에 해당하는 버킷으로 이동한다.
만약에 `정렬대상이 4`이면 `버킷 4`로 이동한다.

이렇게 모든 값들이 다 버킷으로 이동했다면 `버킷 0에 저장된 것`부터 시작해서 `버킷 9에 저장된 것`까지 순서대로 값을 꺼내서 나열하면 된다.  
이것이 바로 `기수 정렬의 기본원리`이다.

여기서 `기수(radix)`란 주어진 데이터를 구성하는 `기본 요소`를 의미한다.  

예를 들어, `2진수`는 `0과 1의 조합`으로 데이터를 표현하니 2진수의 `기수는 0과 1`이다.  
         `10진수`는 `0과 9의 조합`으로 데이터를 표현하니 10진수의 `기수는 0 ~ 9`이다.

이러한 `기수`들을 이용한 정렬을 `기수 정렬`이라 한다.

#### 2번째 이해 
이번에는 `3자리 정수`들을 대상으로 `기수 정렬`을 진행해보자. 오름차순으로 정렬할 것이다.  
단, 여기서 정수는 `5진수`이다. 따라서, `버킷의 개수는 5개`가 되겠다.

134, 224, 232, 122

지금부터 보이는 방법을 `LSD(Least Significant Digit) 기수 정렬`이라 한다. `덜 중요한 자릿수부터 정렬을 진행`하는 방식.  
쉽게 말하면 첫 번째 자릿수부터 시작해서 정렬을 진행한다는 의미이다.

##### 1단계 : 첫 번째 자리수 기준으로 정렬 진행

![image](https://user-images.githubusercontent.com/64796257/150620892-92425fac-1e59-4cd1-968c-8efb4cfd6506.png)
![image](https://user-images.githubusercontent.com/64796257/150620893-71e39b79-285f-4d02-b0bc-68cf6fc13f2f.png)

이렇게 하고 나서 버킷 0에서부터 시작해서 데이터를 꺼내자. 따라서, 232, 122, 134, 224 순으로 데이터가 정렬된다.

##### 2단계 : 두 번째 자리수 기준으로 정렬 진행 

![image](https://user-images.githubusercontent.com/64796257/150620920-595fb12b-b411-4b5b-bd6d-965f1cac15d3.png)
![image](https://user-images.githubusercontent.com/64796257/150620923-0d55417a-d817-4899-ae45-f33a9ae711eb.png)

똑같이 버킷 0에서부터 시작해서 데이터를 꺼내면 122, 224, 232, 134 순으로 데이터가 정렬된다.

##### 3단계 : 세 번째 자리수 기준으로 정렬 진행 

![image](https://user-images.githubusercontent.com/64796257/150620948-e3b9e174-d2c9-45d7-9324-354addd406ed.png)
![image](https://user-images.githubusercontent.com/64796257/150620949-02af8c85-440c-4e71-80c6-8b002c16d4d5.png)

여기서 잊지 말아야 할 내용이 있다.  
`1단계에서 정렬한 결과`를 `2단계에서 두 번째 자릿수를 기준으로 정렬`하고  
`2단계에서 정렬한 결과`를 `3단계에서 세 번째 자릿수를 기준으로 정렬`하는 과정이라는 걸 알아두자. 

이로써 오름차순이 정렬되었다.  
이 방법의 단점은 `작은 자릿수`부터 시작해서 `가장 큰 자릿수`까지 `모두 비교를 해야` 값의 대소를 판단한다.  

즉, 비교 중간에 대소를 판단할 수 없다는 단점이 있다. 하지만 이러한 단점이 프로그래밍을 하는데 있어서 장점이 된다.

### LSD vs MSD 
이제 `MSD`에 대해서 알아보자. `MSD : Most Significant Digit`의 약자로써 `가장 큰 자릿수`부터 정렬이 진행되는 방법이다.

`MSD`는 가장 큰 자릿수부터 정렬이 시작하다보니 LSD와 달리 첫 번째 과정만 거쳐도 대략적인 정렬의 결과가 눈에 보인다. 
따라서, MSD의 가장 큰 장점은 반드시 끝까지 가지 않아도 `중간에서 정렬을 완료`할 수 있다는 점이다.

하지만 이렇다보니 모든 데이터를 일괄적인 과정을 통해 정렬할 수 없다는 단점이 생긴다. 예시를 들어보자.

![image](https://user-images.githubusercontent.com/64796257/150621114-f11956f5-f88b-4fcf-84b0-0ecb77a167e6.png)

위의 그림은 잘못된 결과를 나타내는 그림이다.  
`첫 번째 정렬`을 통해서 224, 232가 정렬이 완료되었기에 여기서 정렬을 멈췄어야 했다. 

하지만, 멈추지 않고 `3번째 자릿수`를 기준으로 또 다시 정렬을 실행해서 잘못된 결과를 초래했다.
반면, 134, 122는 정렬을 계속 진행해야 한다.

이러한 오류를 범하지 않으려면 `MSD 방식`은 `중간에 데이터를 점검`해야 한다. 따라서 구현의 난이도가 LSD에 비해 높다.  
게다가 중간에 데이터를 점검해야 하므로 성능의 이점도 반감될 수 있다.

### 구현

### 성능 평가

## Counting sort(계수 정렬) 

### 과정

### 구현

### 성능 평가
