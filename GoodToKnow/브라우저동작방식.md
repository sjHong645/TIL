[출처1](https://d2.naver.com/helloworld/59361)

[출처2](https://poiemaweb.com/js-browser)

[출처3](https://bbangson.tistory.com/87)

## 브라우저의 핵심 기능 

: 사용자가 선택한 HTML문서, PDF, 이미지와 같은 자원을 서버에 요청하고 이를 화면에 표시하는게 브라우저의 기능이다. 

브라우저는 HTML과 CSS 명세에 따라 `HTML 파일`을 `해석`해서 `표시`하는데 이 명세는 `웹 표준화 기구인 W3C`에서 정한다.

## 브라우저의 주요 구성 요소 

![image](https://user-images.githubusercontent.com/64796257/193719896-c5c7f8b0-4e7d-4399-b63b-b0b58bedc15a.png)

| 구성요소 | 설명 | 
| --- | --- |
| UI | 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분 ex) 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등등 |
| 브라우저 엔진 | `UI`와 `렌더링 엔진` 사이의 동작을 제어 |
| 렌더링 엔진 | 요청한 콘텐츠 표시. ex) `HTML` 요청 ⇒ `HTML과 CSS를 파싱`하여 `화면`에 표시 |
| 통신 | HTTP 요청과 같은 `네트워크 호출`에 사용됨. 이는 `플랫폼에 독립적`인 인터페이스이고 각 플랫폼 하부에서 실행됨 |
| UI 백엔드 | 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용 |
| 자바스크립트 해석기 | JS 코드를 해석하고 실행 |
| 자료 저장소 | `자료를 저장`하는 계층. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 `웹 데이터 베이스`가 정의되어 있음 | 


여기서 사용자가 요청한 정보를 화면에 표시하는 `렌더링 엔진`에 대해서 자세하게 알아보겠다. 

## 렌더링 엔진(Rendering Engine) : 요청받은 내용을 `브라우저 화면`에 `표시`하는 역할 

여기서는 `HTML`과 `이미지`를 `CSS`로 표시하는 사용패턴에 대해 다룬다. 

- FireFox : Gecko(게코) 엔진 사용
- Chrome, Safari : Webkit(웹킷) 엔진 사용 

### 동작 과정 

`렌더링 엔진`은 통신으로부터 `요청한 문서의 내용`을 `얻는 것`에서 시작한다. 보통 문서의 내용은 8KB 단위로 전송된다.

- 기본적인 동작 과정  
![image](https://user-images.githubusercontent.com/64796257/193724628-e11fad0e-53cb-445e-80a7-c895a0a84442.png)

ex) 웹킷 - 크롬, 사파리에서 사용하는 엔진

![image](https://user-images.githubusercontent.com/64796257/193748385-d4952326-7121-45df-bc22-db3b9f61c991.png)

ex) 게코(Gecko) - 파이어폭스에서 사용하는 엔진 

![image](https://user-images.githubusercontent.com/64796257/193750097-3446b21c-5fb8-48a5-b087-a00b9fb35ccf.png)

여기서는 `웹킷`을 기반으로 `렌더링 엔진`의 동작 과정을 살펴보겠다. 

- 순서  
1) HTML 문서를 파싱해서 `DOM 트리` 생성
2) CSS 파일과 함께 포함된 스타일 요소를 파싱해서 `스타일 규칙` 생성
3) `DOM 트리`와 `스타일 규칙`을 가지고 `렌더 트리` 구축 = 어테치먼트(attachment) 
4) 렌더 트리 `배치`
5) 렌더 트리 `그리기` ⇒ 이 내용이 `화면`에 표시됨

### ① HTML 문서를 파싱해서 `DOM 트리` 생성

`HTML 파서`는 `HTML 마크업`을 `파싱 트리`로 변환한다. `DOM`과 `마크업`은 1:1 관계를 맺는다. 예시를 보자. 

``` html
<html>
  <body>
   <p>Hello World</p>
   <div><img src="example.png" /></div>
  </body>
</html>
```

위와 같은 마크업을 아래와 같은 `DOM 트리`로 변환할 수 있다. 

![image](https://user-images.githubusercontent.com/64796257/193750517-49ae86c5-8a1f-416c-8d5f-2aec03987d65.png)

### ② CSS 파일과 함께 포함된 스타일 요소를 파싱해서 `스타일 규칙` 생성

`CSS 파일`은 `스타일 시트 객체로 파싱`되고 각 객체는 `CSS 규칙`을 포함한다.  
그리고 `CSS 규칙 객체`는 선택자, 선언 객체, CSS 문법과 일치하는 다른 객체를 포함한다. 

![image](https://user-images.githubusercontent.com/64796257/193751419-2310698e-c68c-4ee6-ac35-e7c6971fc97e.png)

이렇게 `CSS 파일`을 파싱하여 자료를 구조화 한 것을 `CSS 객체 모델(CSSOM)`이라 한다. 

### ③ 렌더 트리 구축 

렌더 트리는 `표시해야 할 순서`와 `문서의 시각적인 구성요소`들을 `올바른 순서`로 그릴 수 있도록 해준다.

이때, 구성요소를 `웹킷`은 `렌더러(renderer)` 또는 `렌더 객체(render object)`라고 한다. 파이어폭스는 `형상(frames)`이라 한다. 

웹킷에서는 `스타일을 결정`하고 `렌더러를 만드는 과정`을 `어태치먼트(attachment)`라 한다. 

html 태그와 body 태그를 처리함으로써 `렌더 트리의 루트`를 구성한다.  
이를 웹킷에서는 `RenderView`, 파이어폭스는 `ViewPortFrame`이라 한다. 

이것이 문서가 가리키는 랜더 객체이고 `트리의 나머지 부분`은 `DOM 노드`를 추가함으로써 구축된다. 

### ④ 렌더 트리 배치

렌더러가 생성되어 트리에 추가될 때 크기와 위치 정보는 없다.  
여기서 크기, 위치 정보를 계산하는 것을 `배치(layout)` 또는 `리플로(reflow)`라 한다.

### ⑤ 그리기 

화면에 내용을 표시하기 위한 `렌더 트리가 탐색`되고 `렌더러의 paint 메소드`를 호출한다. `그리기`는 UI 기반의 구성요소를 사용한다. 

### JavaScript 처리 방식 

지금까지의 내용은 `HTML 문서`를 파싱해서 `HTML과 CSS`를 `렌더링 엔진`에서 `처리`하는 과정이었다. 

JavaScript는 HTML과 CSS와 달리 `자바스크립트 엔진`에서 처리한다. 

HTML 파서가 `script 태그`를 만나면 js 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 `js 엔진`으로 `제어 권한을 넘긴다`.   
자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 중지했던 시점부터 DOM 생성을 재개한다.

이와 같은 방식 때문에 html 요소들이 `script`로 인해서 로딩이 지연되지 않으려면 `script 태그의 위치`는 body 요소의 맨 아래에 위치하는 게 좋다.

그리고 DOM이 완성되지 않은 상황에서 자바스크립트가 DOM을 조작한다면 에러가 발생할 수도 있다.

이처럼 브라우저는 `동기(Synchronous)`적으로 HTML, CSS, Javascript를 처리한다. 

![image](https://user-images.githubusercontent.com/64796257/193762292-0125e0a5-a842-4d15-9d41-28f157a945bd.png)

























