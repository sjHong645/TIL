[출처](https://velog.io/@gotaek/%EC%84%B8%EC%85%98Session%EA%B3%BC-JWT)

[출처2](https://tecoble.techcourse.co.kr/post/2021-05-22-cookie-session-jwt/)

[출처3](https://www.geeksforgeeks.org/difference-between-session-and-cookies/)

## Authentication(인증) vs Authorization(권한 부여) 

- Authentication : 웹 사이트에서 `로그인`하는 동작
- Authorization : `로그인`을 한 후에 로그인 상태를 `유지` & 로그인 상태의 사용자만 사용할 수 있는 기능을 사용할 수 있도록 함 

모든 요청마다 로그인을 요구할 수는 없기에 `로그인 상태`를 유지할 수 있어야 하는데 이때 사용하는 기술이 `세션`, `JWT`이다. 

## 세션(Session) & 쿠키 

- 세션 : `서버` 쪽에서 저장되는 사용자 정보  
- 쿠키 : `클라이언트` 쪽에서 저장되는 사용자 정보 

브라우저를 통해 서버에 접속한다.  
이때, 클라이언트의 HTTP 요청할 때 `쿠키`에 `세션 id`가 없다면 아래와 같은 과정을 거친다.  
1) 서버는 `세션 id`를 `쿠키`에 담아서 `브라우저에게` 되돌려준다. 
2) 사용자는 `세션 id를 담은 쿠키(세션 쿠키)`를 이후 서버에 요청할 때 마다 `함께 전달`한다. 
3) 서버는 브라우저가 전송한 세션 id를 식별한다. 

⇒ 이 기술을 `세션 기반 인증방식` 보통 `세션`이라 한다. 

![image](https://user-images.githubusercontent.com/64796257/194996757-c39093ac-dd8b-41cd-b36d-7c03749e0a15.png)

1번의 `HTTP Request`를 `로그인`으로 볼 수 있다.  
쿠키가 없는 상태에서 처음 로그인을 했을 때의 정보가 Server의 `세션`으로 저장된다. 

2번 : 그럼 그 세션의 id를 담은 `쿠키`를 브라우저에게 전달 

3번 : 쿠키가 있는 상태에서 `HTTP 요청`을 한다는 건 `로그인`을 한 상황에서 `HTTP 요청`하는 것이다. 

4번 : 서버에서는 전달받은 `쿠키`를 통해 `클라이언트`가 로그인되었다는 걸 식별한다.   
      이때, 전달받은 쿠키의 session 정보와 DB에 저장된 session 정보를 비교하면서 식별한다. 그리고 요청에 따라 응답해준다. 

### 특징

| 특징 | 세션 | 쿠키 | 
| --- | --- | --- | 
| 만료시점 | 대부분 브라우저 종료시 | 영구 쿠키, 세션 쿠키에 따라 다름 | 
| 저장 위치 | 서버 | 클라이언트 | 
| 저장량 | 적음 | 많이 저장할 수 있음 |

서로 반대되는 개념이 아니다.  
- `세션 id`를 `쿠키`에 담아서 통신하기 때문에 세션은 쿠키를 사용하는 방식이라 볼 수 있다. 
- 쿠키에 로그인 정보를 담으면 client에 노출되면서 위험해지니까 `서버에 저장`하는 방식으로 세션을 사용한다.

### 세션의 장점 

1) 쿠키를 포함한 요청이 `외부에 노출`되더라도 세션 ID 자체는 유의미한 개인정보가 없다. 
2) 각 사용자마다 `고유한 세션 ID`가 `발급`되기 때문에, 요청이 들어올 때마다 회원정보를 확인할 필요가 없습니다.

### 세션의 단점 

1) 세션 기반 인증 방식을 사용하면 `중앙 세션 관리 시스템`의 문제가 시스템 전체로 확산됨 ⇒ 세션은 `서버`에 저장되어 있으니까
2) 사용자 ↑ ⇒ 세션 DB와 서버가 많이 필요함(부하가 커진다)  
3) 세션 DB가 A, B로 나눠졌을 때 `내 정보를 A에 저장`했다고 하자.  
   그러면 앞으로 해당 웹페이지에 request를 보낼 때마다 `세션 A`하고만 통신하도록 해야 한다.

## JWT(JSON Web Token) 

### 구성 

ex) aaaaaaaaa.bbbbbbbbbb.cccccccccc
- 첫 번째 부분(aaaaa) : header
- 두 번째 부분(bbbbb) : payload
- 세 번째 부분(ccccc) : signature

`.`을 기준으로 header, payload, signature로 구성되어 있다. JWT는 암호화되어 있지 않기 때문에 중요한 정보를 담으면 안된다. 

- header : `typ`와 `alg`로 이뤄짐  
ex) 
```
{ 
    "alg" : "HS256"  // 해싱하기 위한 알고리즘 
    "typ" : JWT
}
```

- payload : 클레임(토큰에서 사용할 정보)이 있음. 토큰의 목적에 따라 클레임이 달라진다  
            `key-value` 형식으로 이뤚니 한 쌍의 정보를 `claim`이라 한다.
ex) 
```
{
  "sub" : "1234567"
  "name" : "Kong Log"
  "iat" : 121314
}
```

- signature : 인코딩된 header + 인코딩된 payload ⇒ 비밀키로 해싱해서 생성

header, payload는 인코딩된 값이라 복호화 및 조작이 가능하지만  
서버 측에서 관리하는 비밀키가 유출되지 않는이상 signature를 복호화할 수는 없다. 

그래서 signature는 `토큰의 위변조 여부`를 확인하는데 사용한다.

### 동작 방식 

1) 어떤 웹사이트에 로그인한다. 
2) 성공적으로 `Authentication`이 이뤄지면 
3) `서버`는 사인된 확인서(JWT)를 사용자에게 제공한다. 

- `클라이언트`에서는... 해당 웹사이트에 요청할 때마다 `JWT`를 서버에게 같이 보여주면서 `권한을 확인`받는다.  
- `서버`에서는... `JWT`만 확인해서 `Authorization`이 이뤄지기 때문에 세션 DB에 저장할 필요가 없다.

![image](https://user-images.githubusercontent.com/64796257/194998438-8a294abf-b966-4869-b68f-dd6c80eb46af.png)

### 저장위치 

기본적으로 `브라우저 저장소` 와 `쿠키에 저장`하는 방식을 사용한다. 

하지만, 로컬 스토리지, 세션 스토리지와 같은 `브라우저 저장소`를 사용하면 `XSS`에 취약하다.  
`쿠키`에 저장할 때 `http-only`를 사용하면 `HTTPS`로만 쿠키가 전달되서 보안을 강화할 수 있다. 

## 세션과 JWT의 차이점 

- 세션 방식 

: `서버`에서 로그인 된 유저 정보를 모두 저장하고 있어서 사용자들의 통제가 쉽다.  
ex) PC, 모바일 기기의 동시 접속 차단 

- JWT 

서버가 `JWT`를 발급하고 나면 JWT를 관리하지 않는다. 때문에 서버의 자원과 비용을 절감할 수 있다.

다만, 제 3자에게 `탈취`당할 가능성이 있다. 이를 해결하기 위한 방법은 2가지가 있다. 
































