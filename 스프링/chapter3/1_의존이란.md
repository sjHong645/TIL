## 의존(Dependency) 

- `객체 간의 의존`을 의미함

ex) 회원 가입을 처리하는 기능을 구현한 코드 

서로 다른 회원은 `동일한 이메일 주소`를 `사용할 수 없다`고 가정하자.   

동일한 이메일 주소가 있는지 `확인`하기 위해서 `memberDao.selectByEmail`이라는 메소드를 사용했다. 

만약에 `같은 이메일`이 `존재`하면 Exception이 발생하고 `존재하지 않는다`면 `DB에 삽입`한다. 

``` java
import java.time.LocalDateTime;

public class MemberRegisterService {
	  private MemberDao memberDao = new MemberDao();

    public void regist(RegisterRequest req) {
  
      // 이메일로 회원 데이터(member)를 조회 
      Member member = memberDao.selectByEmail(req.getEmail());
    
      // 이미 같은 이메일을 지닌 회원이 존재한다면 Exception 발생
      if (member != null) {
        throw new DuplicateMemberException("dup email " + req.getEmail());
      }
    
      // 같은 이메일을 가진 회원이 존재하지 않는다면 DB에 삽입
      Member newMember = new Member(
          req.getEmail(), req.getPassword(), req.getName(), 
          LocalDateTime.now());
        
      memberDao.insert(newMember);
    }
}
```

여기서 주목할 부분은 MemberRegisterService 클래스가 `DB 처리`를 위해 `MemberDao 클래스의 메소드`를 사용했다는 점이다.  
회원 데이터가 존재하는지 확인하기 위해 `memberDao.selectByEmail()`을 사용했고  
회원 데이터를 DB에 삽입하기 위해서 `memberDao.insert()`을 사용했다. 

이렇게 `한 클래스`가 `다른 클래스의 메소드를 실행`할 때 이를 `의존`한다고 표현한다.  

앞서 코드에서는 `MemberRegisterService 클래스`가 `MemberDao 클래스`에 `의존한다`고 표현할 수 있다. 

그렇다면, `의존하는 대상`을 어떻게 구할까. 가장 쉬운 방법은 `의존 대상 객체`를 `직접 생성`하는 것이다.  
앞서 살펴본 `MemberRegisterService 클래스`에서는 다음과 같이 `MemberDao의 객체`를 생성했다. 

``` java
public class MemberRegisterService {
  // 의존 객체를 직접 생성 
	private MemberDao memberDao = new MemberDao();
  ...
	}
}
```

이런 방식이기 때문에 다른 클래스에서 `MemberRegisterService` 객체를 생성한다면 그 객체 안에서 `MemberDao 객체`도 같이 생성한다. 

하지만, 이런 방법은 `유지보수 관점`에서 문제가 될 수 있다.  
그래서 다른 방법으로 `DI`와 `서비스 로케이터`를 이용한다. 이 중에서 스프링과 관련된 건 `DI`이므로 이에 대해서 살펴보도록 하겠다.
