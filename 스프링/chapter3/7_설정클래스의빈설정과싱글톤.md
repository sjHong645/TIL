- 앞서 작성한 AppCtx 클래스의 코드 
``` java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import spring.ChangePasswordService;
import spring.MemberDao;
import spring.MemberInfoPrinter;

// 스프링 설정 클래스를 의미하는 @Configuration
// 이 Annotation을 붙여야 스프링 설정 클래스로 사용할 수 있다
@Configuration
public class AppCtx {

	@Bean
	public MemberDao memberDao() {
		return new MemberDao();
	}
	
	@Bean
	public MemberRegisterService memberRegSvc() {
		return new MemberRegisterService(memberDao());
	}
	
	@Bean
	public ChangePasswordService changePwdSvc() {
		ChangePasswordService pwdSvc = new ChangePasswordService();
		pwdSvc.setMemberDao(memberDao());
		return pwdSvc;
	}
}
```
`memberRegSvc 메서드`와 `changePwdSvc 메서드`는 둘 다 `memberDao() 메서드`를 실행하고 있다.  
그리고 `memberDao() 메서드`는 매번 새로운 `MemberDao 객체`를 생성해서 return한다. 

그렇다면 이런 질문을 던질 수 있다. 

1) `memberDao()`가 새로운 `MemberDao 객체`를 생성해서 return한다면 
2) `memberRegSvc 메서드`에서 생성한 `MemberRegisterService 객체`와  
   `changePwdSvc 메서드`에서 생성한 `ChangePasswordService 객체`에서 생성한 `MemberDao 객체`는 서로 다른 객체 아닌가?   

하지만, `스프링 컨테이너`가 생성하는 `Bean`은 `singleton 객체`라서 가능하다. 

- 싱글톤(singleton) 객체란? 

ex) 
``` java
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Main2 {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = 
				new AnnotationConfigApplicationContext(AppContext.class);
    
    // 이름이 greeter인 bean 객체를 구해서 각각 g1, g2 변수에 할당했다. 
		Greeter g1 = ctx.getBean("greeter", Greeter.class);
		Greeter g2 = ctx.getBean("greeter", Greeter.class);
    
    // g1과 g2는 같은 객체인가?  같은 객체다. 그래서 true를 출력한다.  
		System.out.println("(g1 == g2) = " + (g1 == g2));
		ctx.close();
	}
}
```

별도의 설정이 없다면 spring은 `bean 객체`를 `1개`만 생성하는데, 이때 `bean 객체`는 `singleton 범위를 갖는다`고 표현한다.  
`싱글톤`은 `단일 객체`를 의미하는 단어로 스프링은 기본적으로 `1개의 @Bean`에 대해 `1개의 bean 객체`를 생성한다. 

따라서, 다음과 같은 설정을 사용하면 `greeter`에 해당하는 객체 한 개와 `greeter1`에 해당하는 객체 한 개, 총 2개의 bean 객체가 생성된다. 
``` java
public Greeter greeter() {
  Greeter g = new Greeter(); 
  g.setFormat("%s, 안녕하세요>");
  return g;
}
```

``` java
public Greeter greeter1() {
  Greeter g = new Greeter(); 
  g.setFormat("%s, 안녕하세요>");
  return g;
}
```

이렇듯, `@Bean`이 붙은 메서드에 대해 `1개의 bean 객체`만 생성한다.  
이는 다른 설정 메서드에서 `memberDao()`을 몇 번을 호출하더라도 `항상 같은 객체`를 return한다는 것을 의미한다. 

이게 어떻게 가능할까.  
`스프링`은 `설정 클래스`를 그대로 사용하지 않는다. 설정 클래스를 `상속`한 `새로운 설정 클래스`를 만들어 사용한다. 

ex) 대략적인 방식 - 실제로는 훨씬 복잡 
``` java
public classAppCtxExt extends AppCtx { 
  private Map<String, Object> beans = ... ; 
  
  @Override
  public MemberDao memberDao() {
    if(!beans.containsKey("memberDao")) beans.put("memberDao", super.memberDao()); 
    
    return (MemberDao) beans.get("memberDao"); 
  }
}
```
스프링이 런타임 때 생성한 설정 클래스의 `memberDao()` 메서드는 매번 새로운 객체를 생성하지 않는다.  
대신, `한 번 생성한 객체`를 `보관`했다가 이후에는 `동일한 객체`를 return한다. 

따라서, `memberRegSvc() 메서드`와 `changePwdSvc() 메서드`에서 `memberDao() 메서드`를 각각 실행해도 동일한 `MemberDao 객체`를 사용한다. 






























