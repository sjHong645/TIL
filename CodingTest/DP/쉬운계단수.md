[문제](https://www.acmicpc.net/problem/10844)

### 문제 

#### 문제 설명 

45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

#### 입력 

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

#### 출력 

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

#### 예제 입력 1
```
1
```

#### 예제 출력 1
```
9
```

#### 예제 입력 2
```
2
```

#### 예제 출력 2
```
17
```

### 정답 코드 

문제의 제한사항을 보면 100자리의 숫자까지 구하라고 요구한다.

하지만, 그렇게 큰 값을 직접 구해서 저장한다면 너무나도 큰 용량을 요구하기 때문에 비효율적이다.

일단 계단수의 특징을 이용해서 다음과 같은 성질이 있다는 것을 파악했다.

1) 0 뒤에는 1만 올 수 있다.
2) 9 뒤에는 8만 올 수 있다.
3) i(1 ≤ i ≤ 8) 뒤에는 i-1과 i+1이 올 수 있다.

N = 2인 상황을 얘기해보자. 

계단수를 직접 구하지 않고도 17이라는 값을 구해낼 수 있다. 

일단, 1 ~ 9까지의 숫자가 있는데 여기에 일의 자리를 하나 덧붙일 예정이다.

그렇다면 몇 개의 숫자가 탄생할까?? 

1 ~ 8은 각각 2개의 숫자들이 뒤에 올 수 있다. ⇒ 따라서, 16개를 만들 수 있다.
9는 1개의 숫자만 뒤에 올 수 있다. ⇒ 따라서, 1개를 만들 수 있다.

⇒ 이렇게 총 17개의 2자리 계단수가 생긴다는 걸 알 수 있다.

이처럼, 맨 끝자리를 N자리라고 하면 꼭 계단수를 구하지 않더라도 N-1번째 자리에 0~9라는 숫자가 몇 개씩 있는지 파악하면

N자리 계단수의 개수를 파악할 수 있다. 

그렇다면 개수를 어떻게 저장해야 할까? N-1번째 자리에 숫자들이 몇 개씩 있는지 파악해야 하기 때문에 2차원 배열의 형태로 저장하려 한다.

![image](https://user-images.githubusercontent.com/64796257/154845634-0d5cf98f-458d-406d-8f6b-8408f7b1aa45.png)

배열의 이름을 `Nth`라고 했는데 

`Nth[3][5]`의 의미는 5자리 계단수의 끝에 있는 숫자 3의 개수를 의미한다.

`Nth[5][8]`의 의미는 8자리 계단수의 끝에 있는 숫자 5의 개수를 의미한다.

이를 토대로 아래와 같은 코드를 작성했다.

``` java
import java.util.Arrays;
import java.util.Scanner;

public class 쉬운계단수 {
	
	static long[][] Nth = new long[10][101];
	
	static void findN(int N) {
		
		// 초기 조건
		if(N == 1) return;
		
    // 출력할 값은 정답을 1,000,000,000으로 나눈 나머지를 출력하도록 했기 때문에
    // 모든 값에 대해서 % 1000000000이 적용되도록 했다.
		for(int i = 2; i <= N; i++) {
			
			for(int j = 0; j < 10; j++) {
				
				// 끝자리가 0이 되기 위해서는
				// N-1번째 자리 숫자가 1이어야 한다. 
				// 즉, N-1번째 자리의 1의 개수 만큼 0의 개수가 정해진다.
				if(j == 0) {
					Nth[0][i] = Nth[1][i-1] % 1000000000;
				}
				
        // 0에서와 마찬가지로 끝자리가 9가 되기 위해서는
        // N-1 번째 자리 숫자가 8이어야 한다.
				else if(j == 9) {
					Nth[9][i] = Nth[8][i-1] % 1000000000;
				}
				
				else {
        
          // 만약에 N번째 자리 숫자가 3이 오려면
          // N-1번째 자리 숫자가 2 또는 4가 되어야 한다. 
          
          // 즉, N번째 자리 숫자가 3이 올 수 있는 경우는
          // N-1번째 자리 숫자가 2가 될 경우와 4가 될 경우의 합을 의미한다.
          
          // 이 내용을 그대로 적용한 것이 아래의 코드이다.
          // i번째 자리에 j라는 숫자가 오는 경우는
          // i-1번째 자리 숫자가 j-1이 되는 경우와 j+1이 되는 경우의 합을 의미한다.
          
					Nth[j][i] = (Nth[j-1][i-1] + Nth[j+1][i-1]) % 1000000000;
				}
					
				
			}
			
		}
		
		
		
		
	}

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		int N = sc.nextInt();
				
		// Nth[i][1]의 의미는... 1자리 숫자에 존재하는 자연수들의 개수를 의미한다.
		// 1자리 숫자에서는 0이 없고 1~9는 1개씩 있어서 아래와 같이 설정했다.
		for(int i = 0; i < 10; i++) {
    
    // 0이 첫 번째 자리에는 올 수 없기 때문에 원하는 동작을 하고 continue 하도록 했다.
			if(i == 0) {
				Nth[i][1] = 0; 
				continue;
			}
			Nth[i][1] = 1;
		}
		
		// 자릿수 N을 전달하면서 함수가 동작한다.
		findN(N);
		
		long[] total = new long[10];
		
		for(int j = 0; j < 10; j++) {
			total[j] = Nth[j][N];			
		}

		System.out.println(Arrays.stream(total).sum() % 1000000000);
	}

}
```






















