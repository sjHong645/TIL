[문제](https://www.acmicpc.net/problem/2589)

1) `육지`에 해당하는 모든 점을 시작점으로 놓고 동작한다.
2) `각각의 시작점`에 대해 가능한 `모든 육지 지점을 도착지점`으로 생각하고 `최단경로`를 구한다. 
3) 그 중 `가장 길이가 긴 최단경로`를 출력한다.

``` java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Node {
    int i;
    int j;
    int count;

    public Node(int i, int j, int count) {
        this.i = i;
        this.j = j;
        this.count = count;
    }
}

public class yes {

    static int N, M;
    static char[][] map;
    static boolean[][] visited;
    static int maxCount = Integer.MIN_VALUE;

    static int[] dx = {0, 0, -1, 1};
    static int[] dy = {-1, 1, 0, 0};

    public static void main(String[] args) throws IOException {

        // L(육지)과 W(바다) & 이동은 상하좌우로 이웃한 육지만 가능

        // 보물은 최단거리로 이동할 때
        // 가장 긴 시간이 걸리는 육지 2곳에 묻혀있다.

        // 두 곳 사이를 최단거리로 이동할 때 같은 곳을 2번 이상 지나거나 멀리 돌아가면 안 된다.

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 그래프 설정
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken()); // 노드 개수
        M = Integer.parseInt(st.nextToken());

        map = new char[N][M];

        for(int i = 0; i < N; i++) {
            String line = br.readLine();
            for(int j = 0; j < M; j++) {
                map[i][j] = line.charAt(j);
            }
        }

        // 모든 지점을 시작점으로
        // 각각의 육지를 도착점으로 정할 때
        // 가장 많이 걸린 시간을 구하는 문제

        // 시작점
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < M; j++) {
                if(map[i][j] == 'L') {
                    visited = new boolean[N][M];
                    bfs(i, j);
                }
            }
        }

        System.out.println(maxCount);

    }

    // (i, j)에서 최단 경로 탐색 시작
    static void bfs(int i, int j) {

        Queue<Node> que = new LinkedList<>();
        que.offer(new Node(i, j, 0));
        visited[i][j] = true;

        while(!que.isEmpty()) {

            Node now = que.poll();

            for(int k = 0; k < 4; k++) {

                int nx = dx[k] + now.i;
                int ny = dy[k] + now.j;

                if(nx >= 0 && nx < N && ny >= 0 && ny < M
                && !visited[nx][ny] && map[nx][ny] == 'L') {
                    visited[nx][ny] = true;

                    if(now.count + 1 > maxCount) maxCount = now.count + 1;

                    que.offer(new Node(nx, ny, now.count + 1));
                }
            }
        }
    }
}
```
