[문제](https://www.acmicpc.net/problem/1068)

1) 트리의 전체 상황을 배열에 저장했다. 
    - tree[i] = j ==> i번째 노드의 부모노드 j 
    - tree[지우고 싶은 노드] = -2로 설정
2) `부모 노드`를 확인한다. 부모 노드가 `지우고 싶은 노드`라면 탐색에서 제외한다.
3) `자식 노드`를 확인한다. 자식 노드가 `1개 이상` 존재하면 탐색에서 제외한다.

``` java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

import java.util.StringTokenizer;

public class yes {

    static int d;
    static int[] tree;

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int N = Integer.parseInt(br.readLine()); // 노드 개수

        tree = new int[N];

        // 트리의 상황
        st = new StringTokenizer(br.readLine());
        for(int i = 0; i < N; i++) {
            tree[i] = Integer.parseInt(st.nextToken());
        }

        // 지울 노드
        d = Integer.parseInt(br.readLine());
        tree[d] = -2;

        // 리프 노드는 몇 개 남았는가
        int count = 0;
        for(int i = 0; i < N; i++) {

            // i번째 노드의 부모 노드를 찾는다.
            // 그 중에서 tree[부모] == -2라면 멈춘다.
            if(!find_parent(i)) continue;

            // i번째 노드가 자식 노드가 있는지 살펴본다.
            // 단 하나라도 있다면 멈춘다.
            if(find_child(i)) count++;
        }

        System.out.print(count);
    }

    static boolean find_parent(int i) {

        // tree[i] == i번째 노드의 부모노드
        if(tree[i] == -1) return true;

        else if(tree[i] == -2) return false;

        else return find_parent(tree[i]);

    }

    static boolean find_child(int i) {

        for(int k = 0; k < tree.length; k++) {
            if(tree[k] == i) return false;
        }

        return true;

    }
}

```
