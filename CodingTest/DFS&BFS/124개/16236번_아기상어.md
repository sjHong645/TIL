[문제](https://www.acmicpc.net/problem/16236)

- 동작 과정 

1) 그래프 설정 
2) `큐에서 꺼낸 물고기`가 먹을 수 있는 모든 물고기를 `eatFish 라는 list`에 저장
3) 먹은 물고기 중에서 가장 가깝고 위에 있고 왼쪽에 있는 물고기를 선택 
4) 그 물고기를 먹고 그 `위치에서 다시 시작`하기 위해 해당 위치를 `큐에 저장`한다. 
5) 2)~4) 반복 

``` java
import java.io.IOException;

import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

class XY {
    int x;
    int y;
    int dist;

    public XY(int x, int y, int dist) {
        this.x = x;
        this.y = y;
        this.dist = dist;
    }
}

public class yes {

    static int[][] field;

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // BFS를 이용하기 위한 큐와
        // 그래프 설정
        Queue<XY> que = new LinkedList<>();
        int N = Integer.parseInt(br.readLine());

        field = new int[N][N];

        for(int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j = 0; j < N; j++) {
                field[i][j] = Integer.parseInt(st.nextToken());

                // 처음 위치를 큐에 저장하고 빈칸으로 바꾼다.
                if(field[i][j] == 9) {
                    que.add(new XY(i, j, 0));
                    field[i][j] = 0;
                }
            }
        }

        int bulk = 2; // 아기상어의 크기
        int eat = 0; // 먹은 물고기 마리수
        int total_dist = 0; // 움직인 전체 거리 

        int dx[] = {0,0,1,-1};
        int dy[] = {1,-1,0,0};

        List<XY> eatFish; // 먹은 물고기 list
        while(true) {
            eatFish = new LinkedList<XY>();
            
            // 아기 물고기가 닿는 거리
            int[][] dist = new int[N][N];

            while(!que.isEmpty()) {

                XY xy = que.poll();
                int x = xy.x;
                int y = xy.y;

                for(int k = 0; k < 4; k++) {

                    int nx = x + dx[k];
                    int ny = y + dy[k];

                    if(nx >= 0 && nx < N && ny >= 0 && ny < N) {
                    
                    // dist 값이 0이라는 건 아직 방문하지 않았다는 뜻 
                    // 그리고 해당 위치에 있는 물고기의 크기가 bulk(아기 상어 크기)보다 작다면 
                    // 지나갈 수 있다. 
                        if(dist[nx][ny] == 0 && field[nx][ny] <= bulk) {
                            dist[nx][ny] = dist[x][y] + 1; // dist 값을 저장 
                            que.offer(new XY(nx, ny, dist[nx][ny])); // 큐에 저장
                             
                            // field 값이 물고기이고 
                            // bulk보다 작아서 아기 상어가 먹을 수 있다면
                            // eatFish 리스트에 추가한다. 
                            if(1 <= field[nx][ny] && field[nx][ny] <= 6 && field[nx][ny] < bulk) {
                                eatFish.add(new XY(nx, ny, dist[nx][ny]));
                            }
                        }
                    }
                }
            }

            // 0마리 먹은 경우 == 엄마에게 도움을 요청해야 하는 경우
            // 끝낸다.
            if(eatFish.size() == 0) {
                System.out.print(total_dist);
                return;
            }

            // 물고기를 먹었다는 건
            // 물고기를 먹은 그 자리가 목적지라는 걸 의미
            
            // 먹은 물고기 중에서
            // 거리가 가장 짧고
            // 가장 위에 있으면서 
            // 가장 왼쪽에 있는 물고기를 선택한다. 
            XY nowFish = eatFish.get(0);

            for(int i = 1; i < eatFish.size(); i++) {

                if(nowFish.dist > eatFish.get(i).dist) nowFish = eatFish.get(i);

                else if(nowFish.dist == eatFish.get(i).dist) {

                    if(nowFish.x > eatFish.get(i).x) nowFish = eatFish.get(i);

                    else if(nowFish.x == eatFish.get(i).x) {
                        if(nowFish.y > eatFish.get(i).y) nowFish = eatFish.get(i);
                    }
                }
            }

            // 선택한 물고기 자리의 field 값을 0으로 만들고
            // 선택한 물고기 까지 닿은 거리 dist 값을 전체 값에 추가하고 
            // 1마리 먹었으니까 eat를 추가한다. 
            field[nowFish.x][nowFish.y] = 0;
            total_dist += nowFish.dist;
            eat++;

            // 먹은 물고기 마리수가 크기랑 동일하면
            // 크기를 1 키운다. 
            if(bulk == eat) {
                bulk++; eat = 0;
            }
            
            
            // 큐에 추가한다. 
            que.add(nowFish);
            
        }
    }
}
```
