[문제](https://www.acmicpc.net/problem/2206)

[출처](https://velog.io/@yanghl98/백준-2206-벽-부수고-이동하기-JAVA자바)


- 벽을 부수지 않았을 때 vs 벽을 부쉈을 때  
⇒ 두 가지 경우 중 `뭐가 최단 경로가 될 지` 모르기 때문에  
⇒ `모든 경우를 구하기` 위해서 두 경우를 모두 고려해줘야 한다.

그래서 `visited 배열`을 `3차원 배열`로 설정했다. 
```
visited[0][][] ⇒ 벽을 부시지 않았을 때 방문 배열
visited[1][][] ⇒ 벽을 한 번이라도 부셨을 때 방문 배열
```

``` java
import java.io.IOException;

import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Node {
    int i;
    int j;
    int count;
    boolean destroyed;

    public Node(int i, int j, int count, boolean destroyed) {
        this.i = i;
        this.j = j;
        this.count = count;
        this.destroyed = destroyed;
    }
}

public class yes {

    static boolean[][] visited;
    static int[][] map;
    static int[] dx = {0, 0, -1, 1}; // 상하좌우
    static int[] dy = {-1, 1, 0, 0}; // 상하좌우

    static int N, M;
    static int minPath = Integer.MAX_VALUE;
    static int wallCrash = 0;

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 그래프 설정
        st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        map = new int[N][M];
        visited = new boolean[N][M];

        String line;
        for(int i = 0; i < N; i++) {
            line = br.readLine();
            for(int j = 0; j < M; j++) {
                map[i][j] = line.charAt(j) - '0';
                // 0 = 이동할 수 있는 곳
                // 1 = 벽
            }
        }

        Queue<Node> que = new LinkedList<>();
        que.add(new Node(0, 0, 1, false));

        int[] dx = {0, 0, -1, 1}; // 상하좌우
        int[] dy = {-1, 1, 0, 0}; // 상하좌우

        // visited[0][][] ==> 벽을 부시지 않았을 때 방문 배열
        // visited[1][][] ==> 벽을 한 번이라도 부셨을 때 방문 배열

        // 벽을 부수지 않았을 때 vs 벽을 부쉈을 때
        // 둘 중 언제 최단 경로가 될지 모르기 때문에 모든 경우를 구하기 위해서
        // 두 경우를 모두 고려해줘야 한다.
        boolean[][][] visited = new boolean[2][N][M];

        while(!que.isEmpty()) {

            Node nowNode = que.poll();

            // 도착점에 도달했다면 멈춰야한다.
            if(nowNode.i == N-1 && nowNode.j == M-1) {
                System.out.print(nowNode.count);
                return;
            }

            for(int k = 0; k < 4; k++) {

                int ni = nowNode.i + dx[k];
                int nj = nowNode.j + dy[k];

                // 범위를 만족하지 않으면 넘어간다.
                if(ni < 0 || ni >= N || nj < 0 || nj >= M) continue;

                int nextCount = nowNode.count + 1;

                // 벽이 아닌 경우
                if(map[ni][nj] == 0) {

                    // 벽을 여태까지 부신적이 없는 경우
                    if(!nowNode.destroyed && !visited[0][ni][nj]) {
                        que.add(new Node(ni, nj, nextCount, false));
                        visited[0][ni][nj] = true;
                    }

                    // 벽을 1번 부신적이 있는 경우
                    else if(nowNode.destroyed && !visited[1][ni][nj]) {
                        que.add(new Node(ni, nj, nextCount, true)); // 벽을 부쉈으니까 true로 저장
                        visited[1][ni][nj] = true;
                    }


                }

                // 벽인 경우
                else {
                    // 아직까지 벽을 부신적이 없다면 부신다.
                    // destroyed == true 와 동치
                    if(!nowNode.destroyed) {
                        que.add(new Node(ni, nj, nextCount, true));
                        visited[1][ni][nj] = true;
                    }

                }

            }

        }
        // 여기에 도달했다는 건 목적지에 도달하지 못했다는 것
        System.out.println(-1);
    }
}
```
