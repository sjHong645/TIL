[문제](https://www.acmicpc.net/problem/1520)



``` java
import java.io.IOException;

import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.util.StringTokenizer;

public class yes {

    static int M, N;
    static int[][] graph, dp;

    static int[] dx = {0, 0, -1, 1};
    static int[] dy = {-1, 1, 0, 0};

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 그래프 설정
        // 세로 크기 M, 가로 크기 N
        st = new StringTokenizer(br.readLine());

        M = Integer.parseInt(st.nextToken());
        N = Integer.parseInt(st.nextToken());

        graph = new int[M][N];

        for(int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j = 0; j < N; j++) {
                graph[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        // dp도 설정
        // dp[i][j] = (i, j) 부터 끝점까지 도달한 경로의 개수

        // 재귀만을 이용하면 시간초과 또는 메모리 초과가 발생하기 때문에
        // DP를 사용해야 한다.
        dp = new int[M][N];

        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                dp[i][j] = -1;
            }
        }

        // 시작점 = (0, 0)에서 탐색 시작 
        System.out.print(dfs(0, 0));

    }

    static int dfs(int x, int y) {

        if(x == M-1 && y == N-1) return 1;

        if(dp[x][y] != -1) return dp[x][y];

        dp[x][y] = 0;

        for(int k = 0; k < 4; k++) {
            int nx = x + dx[k];
            int ny = y + dy[k];

            if(!(nx >= 0 && nx < M && ny >= 0 && ny < N)) continue;

            // 현재 위치의 높이 = dp[x][y]
            // 이웃한 위치의 높이 = dp[nx][ny]

            // 이웃한 위치의 높이가 더 낮다면 dp[x][y]의 값을 [nx][ny]에서의 경로값에 더한다. 
          
          // (x,y) ~ 끝점의 경로의 개수 
          // (x,y) ~ (nx, ny) ~ 끝점의 경로의 개수 와 동일함
          
          // 그렇기 때문에 (x,y) 에서의 경로의 개수에 (nx, ny) 에서의 경로의 개수를 추가해줘야 한다.
            if(graph[x][y] > graph[nx][ny]) dp[x][y] += dfs(nx, ny);
        }

        return dp[x][y];

    }

}





```
