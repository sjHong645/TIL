[문제](https://www.acmicpc.net/problem/9019)

A -> B가 되는 계산 과정을 저장하기 위해서 `String 배열`을 사용했다는 것이 특징이다. 

ex) String[1010] = `A -> 1010`라는 숫자가 되기 위한 계산과정 

나머지는 `이웃한 값`이 무엇인지 정의를 다르게 했을 뿐 이전까지의 BFS와 동일하다.

``` java
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class yes {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int T = Integer.parseInt(br.readLine());

        for(int t = 0; t < T; t++) {

            st = new StringTokenizer(br.readLine());

            int A = Integer.parseInt(st.nextToken());
            int B = Integer.parseInt(st.nextToken());

            boolean[] visited = new boolean[10000];
            String[] commands = new String[10000];
            Arrays.fill(commands, "");

            // BFS 적용
            Queue<Integer> que = new LinkedList<>();
            que.offer(A);
            visited[A] = true;

            while(!que.isEmpty() && !visited[B]) {

                int now = que.poll();

                int S = now == 0 ? 9999 : now - 1;
                int leftRound = L(now);
                int rightRound = R(now);

                // 2배 or 1 빼기 or 왼쪽 회전 or 오른쪽 회전
                if(!visited[(now * 2) % 10000]) {
                    commands[(now * 2) % 10000] = commands[now] + "D";

                    visited[(now * 2) % 10000] = true;
                    que.offer((now * 2) % 10000);
                }

                if(!visited[S]) {
                    commands[S] = commands[now] + "S";
                    visited[S] = true;
                    que.offer(S);
                }

                if(!visited[leftRound]) {
                    commands[leftRound] = commands[now] + "L";
                    visited[leftRound] = true;
                    que.offer(leftRound);
                }


                if(!visited[rightRound]) {
                    commands[rightRound] = commands[now] + "R";
                    visited[rightRound] = true;
                    que.offer(rightRound);
                }
            }

            System.out.println(commands[B]);
        }
    }

    static int L(int num) {

        int temp1 = num % 1000;
        int temp2 = num / 1000;

        return 10 * temp1 + temp2;
    }

    static int R(int num) {

        int temp1 = num / 10;
        int temp2 = num % 10;

        return 1000 * temp2 + temp1;

    }
}

```
