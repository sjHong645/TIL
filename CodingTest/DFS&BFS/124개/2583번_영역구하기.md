[문제](https://www.acmicpc.net/problem/2583)

`영역의 개수 구하기` 문제에 `각 영역의 넓이 구하기`가 추가됨 

K의 값은 주어진 직사각형의 개수일 뿐 영역의 개수가 아님

``` java
import java.io.IOException;

import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

class XY {
    int x;
    int y;

    public XY(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

public class yes {

    static boolean[][] visited;
    static int[][] field;
    static int M, N;

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 그래프 설정
        st = new StringTokenizer(br.readLine());

        M = Integer.parseInt(st.nextToken()); // 세로 길이
        N = Integer.parseInt(st.nextToken()); // 가로 길이
        int K = Integer.parseInt(st.nextToken()); // 직사각형 갯수

        field = new int[N][M];
        visited = new boolean[N][M];

        // 주어진 좌표에 해당하는 영역을 표시
        for(int k = 0; k < K; k++) {

            st = new StringTokenizer(br.readLine());
            int m1 = Integer.parseInt(st.nextToken());
            int n1 = Integer.parseInt(st.nextToken());

            int m2 = Integer.parseInt(st.nextToken());
            int n2 = Integer.parseInt(st.nextToken());

            for(int i = m1; i < m2; i++) {
                for(int j = n1; j < n2; j++) {
                    field[i][j] = 1;
                }
            }
        }

        // 영역의 개수
        // 그리고 각 영역의 넓이 구하기
        int fieldCount = 0;
        List<Integer> countList = new LinkedList<>();

        for(int i = 0; i < N; i++) {
            for(int j = 0; j < M; j++) {
                if(!visited[i][j] && field[i][j] == 0) {
                    countList.add(bfs(i, j));
                }
            }
        }

        // 영역의 넓이 값의 개수를 출력 
        System.out.println(countList.size());

        Collections.sort(countList);
        for(int i : countList) {
            System.out.print(i + " ");
        }

    }

    // 영역의 넓이 값을 return하도록 함 
    static int bfs(int i, int j) {

        Queue<XY> que = new LinkedList<>();
        que.offer(new XY(i, j));
        visited[i][j] = true;
        int count = 1;

        int[] dx = {0, 0, -1, 1};
        int[] dy = {-1, 1, 0, 0};

        while(!que.isEmpty()) {

            XY nowXY = que.poll();

            // nowXY와 이웃한 모든 노드를 탐색 
            int nx, ny;
            for(int k = 0; k < 4; k++) {

                nx = dx[k] + nowXY.x;
                ny = dy[k] + nowXY.y;

                if(nx >= 0 && nx < N && ny >= 0 && ny < M
               && !visited[nx][ny] && field[nx][ny] == 0) {
                    visited[nx][ny] = true;
                    count++; // 아직 방문하지 않은 노드를 1칸 지났으니까 count값을 1 증가시킨다
                    que.offer(new XY(nx, ny));
                }
            }
        }

        return count;

    }
}





```
