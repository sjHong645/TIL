[문제](https://www.acmicpc.net/problem/1987)

`백트래킹` 문제 


``` java
import java.io.IOException;

import java.io.BufferedReader;

import java.io.InputStreamReader;

import java.util.StringTokenizer;

public class Main {
    
    static boolean[] visited = new boolean[26];
    static int[][] field;
    static int[] dx = {-1, 1, 0, 0}; // 상하좌우
    static int[] dy = {0, 0, -1, 1}; // 상하좌우
    static int answer = 0; 

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        
        // 그래프 설정
        st = new StringTokenizer(br.readLine());

        int R = Integer.parseInt(st.nextToken());
        int C = Integer.parseInt(st.nextToken());

        field = new int[R][C];

        String line;
        for(int i = 0; i < R; i++) {
            line = br.readLine();
            for(int j = 0; j < C; j++) {
                field[i][j] = line.charAt(j) - 'A';
            }
        }

        // (0, 0)에서 시작한다. 
        dfs(0, 0, 0); 
        
        System.out.print(answer);

    }
    
    static void dfs(int x, int y, int count) {
        
        // 이미 방문한 곳에 진입했다는 건
        // 같은 알파벳이 적힌 칸에 2번 접근했다는 뜻이기 때문에 여기서 멈춰야 한다. 
        
        // 그래서 count를 갱신하고 끝낸다. 
        if (visited[field[x][y]]) { 
            answer = Math.max(answer, count); 
            return; 
        }
        
        else {
            
            // 방문하고 나서 
            visited[field[x][y]] = true;
            
            // 이웃한 영역에 진입한다. 
            for(int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];
                
                if(nx >= 0 && nx < field.length && ny >= 0 && ny < field[0].length) {
                    dfs(nx, ny, count + 1); 
                }
                
            }
            
            // 방문이 끝났으면 다른 경우를 살피기 위해서 
            // 기존 방문을 취소한다. 
            visited[field[x][y]] = false; 
            
        }   
    }   
}
```
