[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43164)

## 주요 흐름



## 정답 코드
``` java
// 1차 - 7/17(일)
// 2차 - 7/18(월) - 문제 : 중간에 경로를 이탈해서 다른 공항으로 가버린다.
// 3차 - 7/28(목)
// 4차 - 8/2(화) - 되돌아가야 하는데 되돌아갈 방법을 모르겠다.
// 5차 - 8/5(금)

import java.util.List;
import java.util.LinkedList;

import java.util.Map;
import java.util.HashMap;

import java.util.Collections;

import java.util.Comparator;

import java.util.Queue;
import java.util.Deque;

class Airport {
    
    String airport;
    boolean visited; // 해당 공항을 방문했다는 걸 표시하는 boolean 변수
    
    Airport(String airport) {
        
        this.airport = airport;
        this.visited = false; 
        
    }
        
    String getAp() { return this.airport; }
    
    void setVisited(boolean visited) { this.visited = visited; }
    
    boolean getVisited() { return this.visited; }
    
}
    
class Graph { 
    
    // List<List<String>> airLines;     
    // Map<String, List<String>> airLines;
    Map<String, List<Airport>> airLines;
    
    int vertexCount;
    
    Graph() { 
        airLines = new HashMap<>(); 
        this.vertexCount = 0;
    
    }
    
    
    Map<String, List<Airport>> getLines() { return airLines; }
    
    int getVertexCount() { return this.vertexCount; }
    
            
    // v1 -> v2로 이어지는 방향 간선 추가
    void addEdge(Airport v1, Airport v2){
        
        if(airLines.containsKey(v1.airport)) {
            airLines.get(v1.airport).add(v2);
            
            if(!airLines.containsKey(v2.airport)) { airLines.put(v2.airport, new LinkedList<>()); }
        }
        
        else {
            
            airLines.put(v1.airport, new LinkedList<>());
            airLines.get(v1.airport).add(v2);
            
            if(!airLines.containsKey(v2.airport)) { airLines.put(v2.airport, new LinkedList<>()); }
        }
        
    }
    
}

class Solution {
    
    // "ICN"에서 항상 출발
    // 방문하는 공항 경로를 배열에 담아 return 
    
    // 그래프를 이었을 때 ICN에서 출발해서 방문하는 공항 경로를 return한다.
    // DFS를 이용하는게 좋은가?
    // 가능한 경로가 여러 개라면 알파벳 순서가 앞서는 경로를 return해야 한다.
    
    
    // 일종의 방향 그래프를 전달하는 게 tickets 배열
    
    // 그래프를 만들어야 하나? 인접 리스트로 만드는게 좋을 거 같다. 인덱스가 따로 존재하지 않기 때문.
    
    // static Queue<String> results = new LinkedList<>();
    static Deque<String> results = new LinkedList<>();
    
    static int ticketLen;
    
    static int count = 0; 
    
    public String[] solution(String[][] tickets) {
                
        // 그래프 설정
        Graph g = new Graph();
        
        ticketLen = tickets.length;
        
        for(int i = 0; i < tickets.length; i++) {
            
            g.addEdge(new Airport(tickets[i][0]), new Airport(tickets[i][1]));
            
        }
        
        /*for(String k : g.getLines().keySet()){
            System.out.print("키 = " + k + " ");
            System.out.println("사이즈 = " + g.getLines().get(k).size());
        }*/
        
        // System.out.println("공항 개수 = " + g.getLines().size());
        
        // value = list들 알파벳 순으로 정렬
        for(String k : g.getLines().keySet()){
            
            Collections.sort(g.getLines().get(k), new Comparator<Airport>() {
                
                // str1.compareTo(str2) 
                // 양수 => str1이 str2보다 사전적으로 뒤에 있음
                // 음수 => str1이 str2보다 사전적으로 앞에 있음
                
                // ex) a1 > a2일 때
                // 1을 return 하면 오름차순
                // -1을 return 하면 내림차순
                @Override
                public int compare(Airport a1, Airport a2){
                    
                    return a1.getAp().compareTo(a2.getAp());
                    
                }
                
            });
            
        }
        
        route(g, "ICN");
        
        String[] answer = new String[results.size()];
        
        for(int i = 0; i < answer.length; i++) {
            answer[i] = results.poll();
        }
        
        return answer;
        
    }
    
    // void route(Graph g, String start) {
    boolean route(Graph g, String start) {

        // System.out.println("횟수 = " + count); count++;
        // System.out.println("노드 = " + start);
        boolean button = true;
        // start의 이웃한 노드
        for(Airport nb : g.getLines().get(start)) {
            
            // 하나라도 false가 있다면 지나간다. 
            if(nb.getVisited() == false) {
                button = false;
                break; 
            }
        }

         
        
        // 모든 노드를 다 방문했는데 아직 끝나지 않은 상황이니까
        // 되돌아가야 한다.
        if(button == true && results.size() != ticketLen) {
            
            // 여기서 거슬러 올라가줘야 한다. 
            return true; 
            
        }
        
        // 이웃한 노드가 없다 = 더 이상 탐색할 곳이 없는 상황
        // 그런데 아직 끝나지 않았다면 되돌아간다.
        /*else if(g.getLines().get(start).size() == 0 && results.size() != ticketLen){
            System.out.print("이웃한 노드가 없는 노드 = "  + start);
            return true;   
        }*/
        
        
        results.offer(start);
        
        // System.out.print(start + " ");
        
        // start를 key로 갖고 있지 않다면 그냥 끝낸다.
        // if(!g.getLines().containsKey(start)) return true;
        
        // start의 이웃한 노드
        for(Airport nb : g.getLines().get(start)) {
            
            if(nb.getVisited() == false) {
                
                nb.setVisited(true);
                if(route(g, nb.getAp()) == true) nb.setVisited(false);
                
                
            }
        }
        
        for(Airport nb : g.getLines().get(start)) {
            
            // 단 하나라도 방문하지 않았다면 true로 보낸다.
            // 그리고 최근에 추가되었던 start 노드를 results에서 제외한다.
            if(nb.getVisited() == false) {
                results.pollLast();
                return true;
            }
        }
        
        return false;
    }
    
    // BFS로 바꿔서 해봅시다.
    /*void route(Graph g, String start) { 
        
        Queue<Airport> que = new LinkedList<>();
        
        System.out.print(start + " ");
        que.offer(new Airport(start));
        
        Airport pollAp;
        while(!que.isEmpty()) {
            
            pollAp = que.poll();
            
            if(!g.getLines().containsKey(pollAp.getAp())) continue; 
            
            for(Airport nb : g.getLines().get(pollAp.getAp())) {
                
                if(nb.getVisited() == false) {
                    nb.setVisited(true);
                    System.out.print(nb.getAp() + " ");
                    que.offer(nb);
                }
            }
            
            
        }
        
    }*/
}
```
