[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43164)

## 주요 흐름

- Airpot 클래스
```
airport : 공항 이름
visited : 각 항공에 방문했는지 여부를 표시하는 boolean 변수
```

- 그래프 : `인접 리스트`로 구현함

- results 큐 : 공항이 다녀간 경로를 저장하는 `덱(Deque)` ⇒ `덱`으로 저장하면 `peekLast`, `pollLast`를 통해 최근에 도착한 공항 정보에 접근할 수 있다

1) 그래프를 선언하고 주어진 매개변수 `tickets`를 가지고 그래프를 만든다
2) 인접 리스트 형태로 만들었기 때문에 각 공항에 이웃한 노드를 `LinkedList`에 저장했다. 그 `LinkedList`를 `오름차순`정렬한다.
3) `ICN`에서부터 작업을 시작한다.
4) 경로를 따라가다가 더 이상 아무곳도 움직이지 못할 때 
    1) `results의 길이` == `전체 노드 개수 - 1`을 만족하지 못한다면, `되돌아간다`
    2) 그렇지 않으면 그곳에서 끝낸다.


## 정답 코드
``` java
// 1차 - 7/17(일)
// 2차 - 7/18(월) - 문제 : 중간에 경로를 이탈해서 다른 공항으로 가버린다.
// 3차 - 7/28(목)
// 4차 - 8/2(화) - 되돌아가야 하는데 되돌아갈 방법을 모르겠다.
// 5차 - 8/5(금)

import java.util.List;
import java.util.LinkedList;

import java.util.Map;
import java.util.HashMap;

import java.util.Collections;

import java.util.Comparator;

import java.util.Queue;
import java.util.Deque;

class Airport {
    
    String airport;
    boolean visited; // 해당 공항을 방문했다는 걸 표시하는 boolean 변수
    
    Airport(String airport) {
        
        this.airport = airport;
        this.visited = false; 
        
    }
        
    String getAp() { return this.airport; }
    
    void setVisited(boolean visited) { this.visited = visited; }
    
    boolean getVisited() { return this.visited; }
    
}
    
class Graph { 
    
    Map<String, List<Airport>> airLines;
    
    int vertexCount;
    
    Graph() { 
        airLines = new HashMap<>(); 
        this.vertexCount = 0;
    
    }
    
    
    Map<String, List<Airport>> getLines() { return airLines; }
    
    int getVertexCount() { return this.vertexCount; }
    
            
    // v1 -> v2로 이어지는 방향 간선 추가
    void addEdge(Airport v1, Airport v2){
        
        if(airLines.containsKey(v1.airport)) {
            airLines.get(v1.airport).add(v2);
            
            if(!airLines.containsKey(v2.airport)) { airLines.put(v2.airport, new LinkedList<>()); }
        }
        
        else {
            
            airLines.put(v1.airport, new LinkedList<>());
            airLines.get(v1.airport).add(v2);
            
            if(!airLines.containsKey(v2.airport)) { airLines.put(v2.airport, new LinkedList<>()); }
        }
        
    }
    
}

class Solution {
    
    // "ICN"에서 항상 출발
    // 방문하는 공항 경로를 배열에 담아 return 
    
    static Deque<String> results = new LinkedList<>();
    
    static int ticketLen;
    
    static int count = 0; 
    
    public String[] solution(String[][] tickets) {
                
        // 그래프 설정
        Graph g = new Graph();
        
        ticketLen = tickets.length;
        
        for(int i = 0; i < tickets.length; i++) {
            
            g.addEdge(new Airport(tickets[i][0]), new Airport(tickets[i][1]));
            
        }
               
        // System.out.println("공항 개수 = " + g.getLines().size());
        
        // value = list들 알파벳 순으로 정렬
        for(String k : g.getLines().keySet()){
            
            Collections.sort(g.getLines().get(k), new Comparator<Airport>() {
                
                // str1.compareTo(str2) 
                // 양수 => str1이 str2보다 사전적으로 뒤에 있음
                // 음수 => str1이 str2보다 사전적으로 앞에 있음
                
                // ex) a1 > a2일 때
                // 1을 return 하면 오름차순
                // -1을 return 하면 내림차순
                @Override
                public int compare(Airport a1, Airport a2){
                    
                    return a1.getAp().compareTo(a2.getAp());
                    
                }
                
            });
            
        }
        
        route(g, "ICN");
        
        String[] answer = new String[results.size()];
        
        for(int i = 0; i < answer.length; i++) {
            answer[i] = results.poll();
        }
        
        return answer;
        
    }
    
    boolean route(Graph g, String start) {
    
    
        boolean button = true;
        // start의 이웃한 노드
        for(Airport nb : g.getLines().get(start)) {
            
            // 하나라도 false가 있다면 지나간다. 
            if(nb.getVisited() == false) {
                button = false;
                break; 
            }
        }

        
        // 모든 노드를 다 방문했는데 아직 끝나지 않은 상황이니까
        // 되돌아가야 한다.
        if(button == true && results.size() != ticketLen) {
            
            // 여기서 거슬러 올라가줘야 한다. 
            return true; 
            
        }        
        
        results.offer(start);
        
        // start의 이웃한 노드
        for(Airport nb : g.getLines().get(start)) {
            
            // 방문하지 않았던 곳에 접근한다.
            if(nb.getVisited() == false) {
                
                nb.setVisited(true);
                
                // 그 길을 시작으로 더 이상 돌아올 곳이 없었다면 
                // 해당 노드의 방문을 취소한다.
                if(route(g, nb.getAp()) == true) nb.setVisited(false);
                
                
            }
        }
        
        for(Airport nb : g.getLines().get(start)) {
            
            // 단 하나라도 방문하지 않았다면 다시 되돌아간다.
            // 위에 있는 반복문의 목적은 start의 이웃한 노드를 모두 다 방문하도록 하기 위한 것인데
            // 단 하나의 노드라도 방문하지 못했다면 다시 위로 되돌아가도록 한다.
            
            // 그리고 최근에 추가되었던 start 노드를 results에서 제외한다.
            if(nb.getVisited() == false) {
                results.pollLast();
                return true;
            }
        }
        
        return false;
    }
}
```
