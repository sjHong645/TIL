[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42627#)

[정답 출처](https://maetdori.tistory.com/entry/프로그래머스-디스크-컨트롤러-JAVA)

## 주요 흐름

`SJF`를 써야 한다는 건 알았지만 이렇게 `구현`할 줄은 몰랐다. 반복해서 내껄로 만들자.

크게 `2개의 큐`를 사용한다. `waiting_q`, `ready_q`.

여기서는 `waiting_q`를 파라미터로 주어진 `jobs`를 사용한다. 어떻게 사용하는지는 코드를 보면 알 수 있다. 

1) 먼저 `jobs`를 `작업의 시작시간` 기준으로 `오름차순 정렬`한다.
2) 가장 작은 `작업 시간`을 먼저 출력하는 `우선순위 큐`를 선언한다.
3) 작업을 실행한다. - 자세한 건 코드 부분에서

## 정답 코드 

``` java
import java.util.Arrays; 

import java.util.PriorityQueue;
import java.util.Comparator;

class Solution {
    public int solution(int[][] jobs) {
        int answer = 0;
        
        // 먼저 jobs를 정렬한다. 
        // 이 배열은 '시작시간'을 기준으로 오름차순 정렬한다. 
        // 시작시간이 같다면 '작업시간'을 기준으로 오름차순 정렬한다.
        
        // 이 배열이 waiting q 역할을 할 것이다. 
        Arrays.sort(jobs, new Comparator<int[]>() {
            
            @Override
            public int compare(int[] arr1, int[] arr2) {
                
                if(arr1[0] == arr2[0]) return arr1[1] - arr2[1];
                
                return arr1[0] - arr2[0];
                
            }
            
        });
        
        return schedule(jobs);
        
    }
    
    public int schedule(int[][] jobs) {
        
        // 작업시간을 작은 것을 먼저 출력하는 우선순위 큐 선언
        PriorityQueue<int[]> que = new PriorityQueue<>(new Comparator<int[]> () {
          
            @Override
            public int compare(int[] arr1, int[] arr2) {
                
                return arr1[1] - arr2[1];
                
            }
            
        });
        
        // jobs[0] == 시작시간이 가장 빠른 작업. 그래서 먼저 넣어준다.
        que.offer(jobs[0]); 
        
        int end = jobs[0][0]; // 끝나는 시간 : 처음에는 첫 작업의 시작시간으로 초기화
        
        int sum = 0; // turn-around time 의 합
        int idx = 1; // waiting_q가 가리키고 있는 작업
        
        while(!que.isEmpty()) {
            
            int[] cur = que.poll(); // 현재 작업
            end += cur[1];
            sum += end - cur[0]; // 끝나는 시간 - 현재 작업의 작업 요청시간 = TAA 시간을 적립
            // System.out.println(sum);
            
            // waiting_q가 여전히 남아있고
            // 남아있는 waiting_q의 첫 번째 작업의 요청시간이 이미 지나가버렸다면
            // 큐에 남아있는 작업들을 하나씩 넣어준다. 
            while(idx < jobs.length && jobs[idx][0] <= end) que.offer(jobs[idx++]);
            
            // waiting_q는 남아있는데 que가 다 비어있다면
            
            // 이 경우는 남아있는 작업의 시작시간이 다른 작업들이 모두 끝난 이후의 시간일 때 이런 상황이 벌어진다.
            // ex) end = 11, 남아있는 작업의 요청시간 15
            if(idx < jobs.length && que.isEmpty()) {
              
                end = jobs[idx][0]; // 남아있던 waiting_q의 첫 작업의 요청 시간을 end로 초기화
                que.offer(jobs[idx++]); // que에 넣어준다.
                
                // 맨 처음에 0번째 값을 넣어준 것과 유사하다.
            } 
            
            
        }
        
        return sum / jobs.length;
        
    }
}
```
