[문제](https://school.programmers.co.kr/learn/courses/30/lessons/67259)

[정답 출처](https://ltk3934.tistory.com/177)

## 주요 내용 

1) `최단경로`를 구하기 위해 `BFS`를 사용한다.
2) 기존에 알고 있던 최단경로 문제에 `방향` 개념을 추가한다. 왜냐하면, `최소비용`은 `방향`에 따라 달라지기 때문이다. 

## 정답 코드 

``` java
import java.util.Queue; 
import java.util.LinkedList; 

import java.util.Arrays; 

class Solution {
    public int solution(int[][] board) {
        
        // dy = 세로방향 - 1이면 아래, -1이면 위
        // dx = 가로방향 - 1이면 오른쪽, -1이면 왼쪽
        int[] dy = {-1, 0, 1, 0}, dx = {0, 1, 0, -1};
        int N = board.length;

        // 방향 개념이 추가되어야 하기 때문에
        // 3차원 배열로 구현함
        int[][][] cost = new int[N][N][2];
        
        // cost 배열의 모든 값을 최댓값 le9로 설정
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                Arrays.fill(cost[i][j], (int)1e9);

        // 큐 설정과 초기값
        Queue<int[]> queue = new LinkedList<>();
        cost[0][0][0] = 0;
        cost[0][0][1] = 0;
        queue.add(new int[]{0, 0, 0});
        queue.add(new int[]{0, 0, 1});

        // BFS 시작 
        while (!queue.isEmpty()) {
            int[] cur = queue.poll(); // 현재 노드 
            
            // d = 0 현재노드의 위에 있는 값
            // d = 1 현재노드의 오른쪽에 있는 값
            // d = 2 현재노드의 아래에 있는 값
            // d = 3 현재노드의 왼쪽에 있는 값
            for (int d = 0; d < 4; d++) {
                int ny = cur[0] + dy[d]; // 현재 노드에 이웃한 y좌표
                int nx = cur[1] + dx[d]; // 현재 노드에 이웃한 x좌표
                
                // cur[2]가 짝수 (0또는 2)라면... 지금 경로는 세로 방향에서 이동한 경로
                // cur[2]가 홀수 (1또는 3)라면... 지금 경로는 가로 방향에서 이동한 경로
                
                // 짝수 + 짝수 = 짝수, 홀수 + 홀수 = 홀수이기 때문에 
                // cur[2] + d가 짝수가 된다는 건 같은 방향으로 경로가 진행되었다는 뜻. 즉, 직선도로이기 때문에 100원이 비용이 발생한다.
                // cur[2] + d가 홀수가 된다는 건 코너가 생기면서 경로가 진행되었다는 뜻. 즉, 곡선도로이기 때문에 600원이 비용이 발생한다.
                int nc = cost[cur[0]][cur[1]][cur[2]] + ((cur[2] + d) % 2 == 0 ? 100 : 600);
                
                // 범위를 넘어서거나 (ny < 0 || nx < 0 || ny >= N || nx >= N)
                // 막다른 길이거나 (board[ny][nx] == 1) 
                // 
                if (ny < 0 || nx < 0 || ny >= N || nx >= N || board[ny][nx] == 1 || cost[ny][nx][d % 2] <= nc) continue;
                
                cost[ny][nx][d % 2] = nc;
                queue.add(new int[]{ny, nx, d % 2});
            }
        }

        int[] ans = cost[N - 1][N - 1];
        return Math.min(ans[0], ans[1]);
    }
}
```
