[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42892)

## 주요 내용

1) 주어진 배열을 `이진트리`형태로 만들어야 한다.
- 주어진 값에서 `가장 높은 위치`에 있어야 할 노드는 `y좌표가 가장 큰 노드`이다. 
- 그래서 무작위로 주어진 정보를 `y좌표`를 기준으로 `내림차순`정렬했다. 

- 기준은 다음과 같다.
```
노드의 왼쪽 서브트리의 모든 x값 < 노드의 x값 < 노드의 오른쪽 서브트리의 모든 x값
```

위 기준을 만족하면서 `삽입`하면 된다.

2) 만들고 나서 `전위 순회`와 `후위 순회`를 하면 된다.




## 정답 코드
``` java
// 각 장소가 '이진트리의 노드'가 되도록 구성함

// 모든 노드는 서로 다른 x값을 가짐
// 같은 level에 있는 노드는 같은 y좌표를 가짐

// 자식 노드의 y값 < 부모 노드의 y값

// V의 왼쪽 서브트리의 모든 x값 < V의 x값 < V의 오른쪽 서브트리의 모든 x값

// 이진 트리의 전위 순회, 후위 순회 값을 return 하라
import java.util.Arrays;
import java.util.Comparator;

import java.util.Queue;
import java.util.LinkedList;

class Node {
    
    int data; // 노드 번호
    int x; 
    int y; 
    
    Node left; 
    Node right; 
    
    Node(int data, int x, int y) {
        this.data = data;
        this.x = x; 
        this.y = y;
        this.left = null; this.right = null;
    }
    
    int getData() { return this.data; }
    int getX() { return this.x; }
    int getY() { return this.y; }
    
    
    Node getLeft() { return this.left; }
    Node getRight() { return this.right; }
    
    void setLeft(Node node) { this.left = node; }
    void setRight(Node node) { this.right = node; }
    
}

class Tree {
    
    Node root; 
    
    Tree() { root = null; }
    
    boolean empty() { return this.root == null; }
    
    Node getRoot() { return this.root; }
    
    // 삽입 
    public void insert(Node node) {
        
        if(empty()) this.root = node;
        
        else insert(this.root, node.getData(), node.getX(), node.getY());
        
    }
    
    private void insert(Node node, int data, int x, int y) {
        
        // 현재 노드 node
        // 삽입하려고 하는 노드의 x, y좌표
        // 현재 노드의 x값이 더 작으니까 삽입할 노드는 오른쪽에 추가되어야 한다.
        if(node.getX() < x) {
            
            if(node.getRight() == null) node.setRight(new Node(data, x, y));
            
            else insert(node.getRight(), data, x, y);
            
        }
        
        else {
            
            if(node.getLeft() == null) node.setLeft(new Node(data, x, y));
            
            else insert(node.getLeft(), data, x, y);
            
        }
    }
    
    // 전위 순회
    void preOrder(Node node, Queue<Integer> que) {
        
        if(node == null) return;
        
        que.offer(node.getData()); // 내가 원하는 동작
        preOrder(node.getLeft(), que);
        preOrder(node.getRight(), que);
        
    }
    
    // 후위 순회
    void postOrder(Node node, Queue<Integer> que) {
        
        if(node == null) return;
        
        postOrder(node.getLeft(), que);
        postOrder(node.getRight(), que);
        que.offer(node.getData()); // 내가 원하는 동작
        
    }
    
}


class Solution {
    public int[][] solution(int[][] nodeinfo) {
        
        // 노드 번호를 꼭 가지고 있어야 함
        Node[] nodeInfo = new Node[nodeinfo.length];
        
        for(int i = 0; i < nodeInfo.length; i++) {
            nodeInfo[i] = new Node(i + 1, nodeinfo[i][0], nodeinfo[i][1]);
        }
        
        // 높이가 높은 값이 먼저 올 수 있도록
        // 주어진 자료를 y값을 기준으로 내림차순하겠다.
        Arrays.sort(nodeInfo, new Comparator<Node>() {
            
            @Override
            public int compare(Node a1, Node a2) {
                
                if(a1.getY() > a2.getY()) return -1; 
                
                else if(a1.getY() < a2.getY()) return 1; 
                
                else return 0;
                
            }
            
        });
        
        // 주어진 자료를 이진 트리로 만들어야 한다.
        Tree tree = new Tree();
        
        for(int i = 0; i < nodeInfo.length; i++) tree.insert(nodeInfo[i]);
        
        int[][] answer = new int[2][nodeinfo.length]; // answer[0] = 전위 순위 값 저장, answer[1] = 후위 순위 값 저장
        
        Queue<Integer> results = new LinkedList<>();
        
        // 전위 순회
        tree.preOrder(tree.getRoot(), results);
        
        int idx = 0; 
        while(!results.isEmpty()) answer[0][idx++] = results.poll();
        
        // 후위 순회
        tree.postOrder(tree.getRoot(), results);
        
        idx = 0; 
        while(!results.isEmpty()) answer[1][idx++] = results.poll();
        
        
        return answer;
    }
}
```
