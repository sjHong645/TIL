[문제](https://school.programmers.co.kr/learn/courses/30/lessons/60059)

## 주요 내용

1) key는 회전 각도에 따라 `4가지`로 나눌 수 있다. ⇒ 0도, 90도, 180도, 270도 

2) `4가지 key`가 `자물쇠`와 맞는지 전부 `check`한다. 

### check 할 때 `주의`할 점

열쇠를 `자물쇠`와 대조할 때 주어진 열쇠의 영역을 `벗어날`수 있다.

ex) 아래와 같이 `key`와 `lock`이 주어졌다고 하자.  
![image](https://user-images.githubusercontent.com/64796257/186578966-cdb19aa1-d8d8-42bd-bbab-ef998291216a.png)

`key`는 `3칸`의 돌기가 있어서 `lock`과 전혀 맞지 않아 보이지만 다음과 같이 생각하면 `lock`의 홈 부분을 정확히 채울 수 있다.  

① key를 오른쪽으로 90도 회전

![image](https://user-images.githubusercontent.com/64796257/186579359-9d15757f-b4b9-4e1d-afcc-abd65f2c9dc8.png)

② 그러면 `key`의 `(0, 1)` 부분과 `(1, 0)` 부분이 lock의 홈 부분과 정확히 대조된다. 

그래서 원활한 대조를 위해 자물쇠의 영역을 확장한 `std`라는 배열을 check 메소드에서 만들었다. 

`std`의 길이는 `(lock 길이) + 2 * (key 길이 - 1)`

기본적으로 `std`는 자물쇠 `lock`의 확장판이기 때문에 기본적으로 `lock의 길이`만큼 가져야 한다. 

추가적으로 `key`가 아래와 같이 대조할 수 있어야 한다. 

![image](https://user-images.githubusercontent.com/64796257/186580854-c70303a2-3dee-440d-b39b-3d7796253d73.png)

그래서 총 길이가 `(lock 길이) + 2 * (key 길이 - 1)`가 된다. 



  

## 정답 코드 

``` java
// 1차 - 8/8(월)
// 2차 - 8/11(목) - 어떻게 하면 넓은 판에 열쇠를 하나씩 대조시키는지가 관건
// 3차
// 4차 - 8/25(목)

// 열 수 있으면 true / 열 수 없으면 false
class Solution {
    
    public boolean solution(int[][] key, int[][] lock) {
        
        int M = key.length; int N = lock.length;
        
        // key 그대로 자물쇠와 비교
        if(check(key, lock) == true) return true;
        
        // key를 시계방향으로 90도 돌렸을 때
        int[][] key90 = rotate(key);
        
        if(check(key90, lock) == true) return true;
                
        // key를 시계방향으로 180도 돌렸을 때
        int[][] key180 = rotate(key90);
        
        if(check(key180, lock) == true) return true;
        
        // key를 시계방향으로 270도 돌렸을 때
        int[][] key270 = rotate(key180);

        if(check(key270, lock) == true) return true;
                
        return false;
        
    }
    
    // 출처 : https://bcp0109.tistory.com/150
    int[][] rotate(int[][] mtx) {
        int n = mtx.length;
        
        // 매개 변수를 깊은 복사한다.
        int[][] matrix = new int[n][n];
        
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                matrix[i][j] = mtx[i][j];
            }
        }

        // 위, 아래 바꿈
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < n; j++) {
                int temp = matrix[i][j];
                // matrix[i][j] = matrix[n - i - 1][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;

            }
        }

        // 대각선 기준 대칭이동
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        return matrix;
    }
    
    // M <= N
    // 여기서 자물쇠에 대해서 key를 대조해보고 싶다.
    // 간과한 점은 열쇠가 자물쇠 영역을 벗어나서 대조해 볼 수 있다는 점이다.
    boolean check(int[][] key, int[][] lock) {
        
        int M = key.length; int N = lock.length;
        
        // 자물쇠의 홈 개수
        int holeCount = 0; 
        
        for(int i = 0; i < lock.length; i++) {
            for(int j = 0; j < lock.length; j++) {
                if(lock[i][j] == 0) holeCount++;
            }
        }
        
        // 열쇠가 자물쇠 영역을 벗어나서 대조할 수 있도록 한 배열
        // 즉, lock을 확장함
        // 아래와 같이 for문을 동작하면 정가운데에 자물쇠가 위치하게 됨
        int[][] std = new int[N+2*(M-1)][N+2*(M-1)]; 
        
        for(int i = M-1; i < M-1 + N; i++) {
            for(int j = M-1; j < M-1 + N; j++) {
                std[i][j] = lock[i-(M-1)][j-(M-1)];
            }
        }
        
        
        // std 부분과 key를 비교 
        // key를 std 전체에서 1칸씩 이동하면서 일일이 대조한다. - 그 내용이 Loop1에 있다
        // 그러다가 key의 돌기와 std의 돌기끼리 만난다면 멈추고 다음 칸으로 이동하고 
        // 정확하게 맞아떨어진다면 count의 개수를 증가시킨다. 
        
        for(int i = 0; i < std.length - (M-1); i++) {
            for(int j = 0; j < std.length - (M-1); j++) {
                
                int count = 0; 
                
                Loop1: 
                for(int m = 0; m < M; m++) {
                    for(int n = 0; n < M; n++) {
                    
                        // key[m][n]
                        // std[m+i][n+j]
                        
                        // 여기서 곧바로 return false를 할 필요는 없음
                        // 다만, 돌기와 돌기가 만난다면 해당 작업을 종료하는 설정을 필요하다
                        if(std[m+i][n+j] == 1 && key[m][n] == 1) break Loop1;
                        
                        // 키와 자물쇠가 서로 맞아떨어지면서
                        // 지금 대조하고 있는 자물쇠 부분이 유효한 자물쇠 부분이라면 
                        // 개수를 추가해준다.
                        if(std[m+i][n+j] == 0 && key[m][n] == 1
                             && (M-1 <= m+i && m+i < M-1+N)
                             && (M-1 <= n+j && n+j < M-1+N)) {
                            
                            count++;
                        }
                    }
                }
                // 세어낸 개수가 lock의 홈 개수와 일치하면 true를 return한다. 
                // 그렇지 않으면 계속 반복한다.
                if(holeCount == count) return true;
                
            }
            
        }
        
        return false;
        
    }
}
```

