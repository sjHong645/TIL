[문제]()

[정답 출처](https://velog.io/@hyeon930/프로그래머스-추석-트래픽-Java)  
[카카오 해설](http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/)

## 주요 내용

### 1) 시간으로 주어졌다면 `시간`답게 환산하자. 

이 부분을 간과해서 `예제 5`와 `테스트 케이스 1번`을 계속 틀렸다.  

ex) `20:59:57.421`라는 시간을 `밀리초(ms)`로 변환하겠다. 

처음에는 이렇게 변환했다. 코드가 간단했기 때문이다.
``` 
20:59:57.421 ⇒ 205957421  
```

하지만, 위와 같이 변환하니 위에서 말한 2개의 문제에서 계속 오답이 나왔다. 

`시간`은 `시간`으로 변환해야 한다.

```
20:59:57.421 ⇒ 20 * 60 * 60 * 1000 
              + 59 * 60 * 1000
              + 57 * 1000 + 421
```

### 2) 처리량

문제에서 구하고자 하는 건 `1초`동안 `가장 많은 처리량`을 구하라는 문제였다.

때문에 여기서 주목해야 하는 점은 **`언제 처리량이 변하는가`** 였다.

처리량이 변하는 시점은 `하나의 작업`을 기준으로 봤을 때 2군데가 있다. `시작`할 때 / `끝`날 때.

어떤 작업의 `시작` 순간을 지나면 `처리량`은 1개 증가되고  
어떤 작업의 `마지막` 순간을 지나면 `처리량`은 1개 감소된다.

따라서, 1초 동안의 작업의 개수를 비교할 때 각 작업의 `시작` 시간과 `끝` 시간을 시작점으로 놓고  
1초동안 몇 개의 작업이 있는지 파악하면 된다.

## 정답 코드 
``` java
// 1차 - 8/9(화)
// 2차 - 8/16(화)
// 3차 - 8/18(목)
// 4차 - 8/29(월) - 카카오 해설을 봤다
// 5차 - 9/4(일) - 4차 때 봐도 모르겠다.

import java.util.StringTokenizer;

class Data { 
    
    long start; // 시작 시간(단위 ms)
    long end;  // 끝나는 시간(단위 ms)
    
    Data(long end, long running) {
        this.end = end;
        this.start = end - running + 1;
    }
    
}

class Solution {
    public int solution(String[] lines) {
        
        if(lines.length == 1) return 1; // 처리할 작업이 1개라면 굳이 처리량을 계산할 필요는 없다
        
        Data[] data = new Data[lines.length];
            
        long endTime = 0; long runTime = 0;
        
        StringTokenizer st, end, run;
        
        for(int i = 0; i < lines.length; i++) {
            
            endTime = 0; runTime = 0; // 초기화
            
            
            st = new StringTokenizer(lines[i]); st.nextToken(); // 날짜는 버림
            
            // 끝난 시간
            // :을 가지고 나누자.            
            end = new StringTokenizer(st.nextToken(), ":"); 
            
            endTime += Long.parseLong(end.nextToken()) * 60 * 60 * 1000; // 시간 => 밀리초
            endTime += Long.parseLong(end.nextToken()) * 60 * 1000;    // 분 => 밀리초
            endTime += makeRun(end.nextToken()); // 초 & 밀리초 => 밀리초
            
            
            // 동작 시간
            runTime = makeRun(st.nextToken());
            
            data[i] = new Data(endTime, runTime);
            
        }   
        
        // 시작 시간과 끝 시간만 가지고 풀 수 있다고 한다.
        // 요청량이 변하는 순간은 시작 시간과 끝 시간이 지날 때이기 때문이다
        
        // 구하고 싶은 건 '처리량이 가장 많은 1초'의 처리량
        
        // 카카오 해설에서 언급했듯이 요청량이 변하는 순간은 '시작 시간'과 '끝 시간'
        
        
        int maxCount = 1; // 기본적으로 1개의 작업은 있다. 
        for(int i = 0; i < data.length; i++) {
            
            // data[i].start = 윈도우의 시작시간
            // data[i].end = 윈도우의 끝 시간
            
            // data[i].start = 윈도우의 시작시간을 시작으로 1초간 동작하는 동작
            int count1 = 1; // i번째 작업은 포함하기 때문에 1로 초기화
            for(int j = 0; j < data.length; j++) {
                if(i == j) continue; 
                
                // j번째 작업의 시작 시간이 (i번째 작업의 시작 시간) ~ (i번째 작업의 시작 시간 + 999) 안에 있을 때
                // j번째 작업의 끝 시간이 (i번째 작업의 시작 시간) ~ (i번째 작업의 시작 시간 + 999) 안에 있을 때
                // j번째 작업이 (i번째 작업의 시작 시간) ~ (i번째 작업의 시작 시간 + 999)을 포함하고 있을 때
                if((data[i].start <= data[j].start && data[j].start <= data[i].start + 999) 
                 ||(data[i].start <= data[j].end && data[j].end <= data[i].start + 999)
                 ||(data[j].start <= data[i].start && data[i].start+999 <= data[j].end)) {
                    
                    count1++;

                }
                                
                
            }
            
            if(maxCount < count1) maxCount = count1;
            
            // data[i].end = 윈도우의 끝 시간을 시작으로 1초간 동작하는 동작
            int count2 = 1; // i번째 작업은 포함하기 때문에 1로 초기화
            for(int j = 0; j < data.length; j++) {
                if(i == j) continue; 
                
                // j번째 작업의 시작 시간이 (i번째 작업의 끝 시간) ~ (i번째 작업의 끝 시간 + 999) 안에 있을 때
                // j번째 작업의 끝 시간이 (i번째 작업의 끝 시간) ~ (i번째 작업의 끝 시간 + 999) 안에 있을 때
                // j번째 작업이 (i번째 작업의 끝 시간) ~ (i번째 작업의 끝 시간 + 999)을 포함하고 있을 때
                if((data[i].end <= data[j].start && data[j].start <= data[i].end + 999) 
                 ||(data[i].end <= data[j].end && data[j].end <= data[i].end + 999)
                 ||(data[j].start <= data[i].end && data[i].end+999 <= data[j].end)) {
                    
                    count2++;

                }
                
            }
            
            if(maxCount < count2) maxCount = count2;
        }
        
        return maxCount;
    }
      
    
    long makeRun(String run) {
        
        long result = 0;
        
        StringTokenizer st = new StringTokenizer(run, ".s");
        
        result += Long.parseLong(st.nextToken()) * 1000; // 초 부분
        
        if(st.hasMoreTokens()) {
            String remain = st.nextToken(); // 나머지 부분

            if(remain.length() == 3) result += Long.parseLong(remain); 

            else if(remain.length() == 2) result += Long.parseLong(remain) * 10; 

            else if(remain.length() == 1) result += Long.parseLong(remain) * 100; 
        }
        
        
        return result;
        
        
    }
    
}
```
