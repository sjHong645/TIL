[문제](https://school.programmers.co.kr/learn/courses/30/lessons/81303)

[정답 출처](https://jangcenter.tistory.com/125)

## 주요 내용
```
이 문제를 보고 `양방향 연결 리스트`를 떠올릴 수 있어야 했다.
```

그리고 삭제된 노드들은 `최신 상태`가 먼저 나올 수 있도록 하는 `스택`에 저장해줘야 한다.

자세한 풀이는 블로그를 보도록 하자. 

tip) 

`(char형 숫자) - '0' = 정수`가 나오는 경우는 `(char형 숫자)`가 `일의 자리`일 때만 가능하다. 

ex) `'9' - '0' = 9` 

그 이상의 숫자일 때는 원하는 정수값을 반환하지 않는다는 걸 꼭 알아두자.


## 정답 코드 

``` java
// 1차 - 8/10(수)
// 2차 - 8/18(목)
// 3차 - 8/24(수)
// 4차 - 8/31(수) - 출처 : https://jangcenter.tistory.com/125

// U X : 현재 선택된 행에서 X칸 위에 있는 행을 선택
// D X : 현재 선택된 행에서 X칸 아래에 있는 행을 선택
// C : 현재 선택된 행 삭제 -> 바로 아래 행 선택 (마지막이 삭제되었다면 윗 행 선택)
// Z : 삭제된 행 복구 (현재 선택된 행은 바뀌지 않음)

import java.util.Deque; 
import java.util.LinkedList;

import java.util.Map;
import java.util.HashMap;

import java.lang.StringBuilder;


class Node {
    
    Node prev; 
    Node next; 
    boolean isDelete;
    
    public Node() {
        prev = null;
        next = null;
        isDelete = false; // 아직 삭제되지 않았다!
    }
        
}

class Stack {
    
    Deque<Node> deq; 
    
    public Stack() { deq = new LinkedList<>(); }
    
    void push(Node e) { deq.offerLast(e); }
    
    Node pop() { return deq.pollLast(); }
    
    Node peek() { return deq.peekLast(); }
    
}

class Solution {
    public String solution(int n, int k, String[] cmd) {       
        
        Node[] list = new Node[1000001]; 
        
        list[0] = new Node();    
        for(int i = 1; i < n; i++) {
            
            list[i] = new Node(); 
            list[i].prev = list[i-1]; // i-1번째 노드는 i번째 노드의 이전 노드가 되도록 함
            list[i-1].next = list[i]; // i번째 노드는 i-1번째 노드의 다음 노드가 되도록 함
            
        }
        
        Stack removeStack = new Stack();
        
        Node now = list[k]; 
        for(int i = 0; i < cmd.length; i++) {
            
            char op = cmd[i].charAt(0); 
            
            // 현재 노드 now를 삭제할 때
            // 삭제 과정은 리스트에서만 열외될 뿐 
            
            // 삭제된 노드 자체가 가리키던 이전 노드와 다음 노드는 남아있기 때문에 
            // 다른 요소들은 고려할 필요가 없다.
            if(op == 'C') {
                
                now.isDelete = true; // true로 설정
                removeStack.push(now); 
                
                Node prevNow = now.prev; // now의 이전 노드
                Node nextNow = now.next; // now의 다음 노드
                                
                // 이전 노드가 존재한다면 
                // prev가 곧바로 next를 가리키도록 한다.
                if(prevNow != null) prevNow.next = nextNow; 
                
                // 다음 노드가 존재한다면 
                // next가 곧바로 prev를 가리키도록 한다.
                if(nextNow != null) {
                    nextNow.prev = prevNow;
                    now = nextNow;
                }
                
                // 다음 노드가 없다는 건 마지막에 위치한 노드라는 걸 의미하기 때문에
                // 현재 노드는 이전 노드를 가리키도록 한다.
                else now = prevNow;
                
            }
            
            // 복구
            else if(op == 'Z') {
                
                Node popNode = removeStack.pop();
                
                Node prevNode = popNode.prev;
                Node nextNode = popNode.next;
                
                popNode.isDelete = false;
                
                // 이전 노드가 존재한다면 
                // prev가 다음 노드로 popNode를 가리키도록 한다.
                if(prevNode != null) prevNode.next = popNode; 
                
                // 다음 노드가 존재한다면 
                // next가 이전 노드로 popNode를 가리키도록 한다.
                if(nextNode != null) nextNode.prev = popNode;
                
                
            }
            
            else if(op == 'U') {
            
                // 주석 내용과 같은 숫자 변환은 한계가 있다!!
                // for(int j = 0; j < (cmd[i].charAt(2) - '0'); j++) now = now.prev;
                
                // 횟수만큼 리스트에서 앞으로 이동
                for(int j = 0; j < Integer.parseInt(cmd[i].substring(2)); j++) now = now.prev;
            }
            
            else if(op == 'D') {
                // for(int j = 0; j < (cmd[i].charAt(2) - '0'); j++) now = now.next;   
                
                // 횟수만큼 리스트에서 로 이동
                for(int j = 0; j < Integer.parseInt(cmd[i].substring(2)); j++) now = now.next;   
            }
            
        }
        
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < n; i++) {
            
            if(list[i].isDelete == true) sb.append("X");
            
            else sb.append("O");
            
        }
        
        
        return sb.toString();
    }
}

```
