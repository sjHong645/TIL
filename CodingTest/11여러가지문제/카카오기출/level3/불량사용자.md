[문제](https://school.programmers.co.kr/learn/courses/30/lessons/64064)

## 주요 내용

1) `불량 사용자`목록을 만든다. 

ex) 
```
<응모자 아이디>
frodo
fradi
crodo
abc123
frodoc
```
응모자 아이디가 위와 같을 때 아래와 같은 불량 사용자 목록을 만든다. 이때 목록은 `Set`을 이용해서 만든다.
``` 
<불량 사용자>
fr*d* - frodo, fradi
*rodo - frodo, crodo
****** - abc123, frodoc
****** - abc123, frodoc
```

2) 목록에 있는 값들을 가지고 `제재 아이디 목록`을 구한다. 단, `순서에 관계가 없`고 같은 아이디가 있으면 안된다.


## 정답 코드
``` java
// 이벤트 응모자 아이디 목록이 담긴 user_id
// 불량 사용자 아이디 목록 = 개인정보 보호를 위해 *으로 표시됨
// * = 임의의 문자 1개

// 이때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇 가지 경우의 수가 가능?

// user_id의 최대 길이 8, banned_id 길이 <= user_id 길이

import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;

import java.util.Map;
import java.util.HashMap;

import java.util.Set;
import java.util.HashSet;

import java.util.Arrays;

import java.util.Collections;

class Solution {
    
    static Set<List<String>> lists = new HashSet<List<String>>();
        
    public int solution(String[] user_id, String[] banned_id) {
        int answer = 1;
                
        // 목록을 만든다.
        Set<String>[] banCount = new HashSet[banned_id.length];
        
        for(int i = 0; i < banCount.length; i++) {
            banCount[i] = new HashSet<>();
        }
        
        // 불량 사용자 값이
        // 사용자 값의 패턴과 일치한다면 목록에 추가한다.
        // ex) banned_id[i] == "fr*d*"
        // userId = "frodo" 
        
        // 사용자 값이 패턴에 일치하니까 목록에 추가한다.
        for(int i = 0; i < banned_id.length; i++) {         
            for(String userId : user_id) {
                if(match(banned_id[i], userId)) banCount[i].add(userId);
            }   
        }
        
        List<String> results = new ArrayList<>();
        userList(banCount, banned_id, 0, results);
        
        
        return lists.size();
    }
    
    // 불량 사용자 목록의 패턴이
    // 사용자 아이디와 맞는지 확인하는 메소드
    boolean match(String ban, String user) {
        
        if(ban.length() != user.length()) return false;
        
        for(int i = 0; i < ban.length(); i++) {
            
            // banned id값과 user id값이 서로 다른 부분이 있다면
            // false를 return한다.
            if(ban.charAt(i) != '*' 
            && ban.charAt(i) != user.charAt(i)) return false;
            
        }
        
        return true;
        
    }
    
    void userList(Set<String>[] banCount, String[] banned_id, int depth, List<String> list) {
        
        // 리스트가 다 차지도 않았는데 depth의 값이 Set의 사이즈보다 커져버린다면
        // 끝낸다. 이 이상 인덱싱할 원소가 없다.
        if(list.size() != banned_id.length && depth > banCount.length) return;
        
        // 리스트가 꽉 찼을 때 원하는 동작을 실행한다.
        else if(list.size() == banned_id.length) {
        
            
            Collections.sort(list); // 똑같은 원소를 가졌다면 순서는 똑같아진다.
                        
            lists.add(list); // Set에다가 저장했기 때문에 중복된 값은 저장되지 않는다. 
            return;
        }
        
        for(String id : banCount[depth]) {
            
            // 제외 아이디 목록에 있는 유저 아이디들을 id로 가리킨다.
            
            // ex) *rodo - frodo, crodo
            // id값은 각각 frodo와 crodo를 가리킨다.
            
            // 그 값이 리스트에 존재하지 않는다면 포함시켜서 재귀동작 유도
            
            // 그러고 나서 그 값을 지운다. 
            // 왜냐하면, 같은 제외 목록에 있는 다른 아이디를 포함시켜야 하기 때문이다.
            if(!list.contains(id)) {
                list.add(id);
                userList(banCount, banned_id, depth+1, list);
                list.remove(id);
            }
            
        }
    }
    
}

```
