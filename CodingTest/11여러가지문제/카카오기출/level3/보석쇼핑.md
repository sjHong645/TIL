[문제](https://school.programmers.co.kr/learn/courses/30/lessons/67258)

[투 포인터 설명](https://gaybee.tistory.com/36)

## 주요 내용 

`투 포인터` 개념을 알고 있다면 쉽게 풀 수 있는 문제였다. 

간단하게 설명하면 

### 준비
1. left와 right라는` 배열의 양 끝`을 `가리키는 변수`를 만든다. (ex. 배열의 인덱스 값 저장)  
2. `left ~ right` 범위에 있는 보석의 개수를 저장할 `Map`을 선언하고 `보석의 개수`를 `Set`을 통해 미리 세놓는다.

### 과정
1) `left ~ right` 범위에 있는 보석의 종류 개수가 `전체 보석 개수`보다 적다면 `right`을 한 칸 옮겨준다 ⇒ 이 과정을 통해 `범위를 확장`시킬 수 있음
2) `left ~ right` 범위에 있는 보석의 종류 개수가 `전체 보석 종류 개수`와 일치한다면  
    - left와 right을 별도의 배열 또는 값에 저장하고
    - left의 값을 1 증가시켜서 더 짧은 범위가 있는지 찾아본다.
3) left를 옮기고 나서 또 새로운 범위를 찾았을 때 `이전 범위`보다 길이가 더 짧은지 확인해서 더 짧은 범위를 저장한다. 
(길이가 같다면 이전에 있던 `left 값`이 더 작을 수 밖에 없기 때문에 이 경우는 굳이 고려하지 않아도 된다)


## 정답 코드 

``` java
// 1차 - 8/10(수)
// 2차
// 3차 
// 4차 - 9/1(목)
// 5차 - 9/7(수) - 카카오 풀이 + 투 포인터 개념을 보고 풀었음

import java.util.Map;
import java.util.HashMap;

import java.util.Set;
import java.util.HashSet;

// 가장 짧은 구간이 여러 개일 수도 있다.
// 그때는 시작 진열대 번호가 가장 작은 구간을 return해야 한다.
class Solution {
    public int[] solution(String[] gems) throws Exception {
                
        int n = gems.length; 

        // Map : 보석 ==> 빈도수
        Map<String, Integer> jewelMap = new HashMap<>();
        
        // 보석 개수 파악하기
        Set<String> jewelSet = new HashSet<>();

        for(int i = 0; i < gems.length; i++) jewelSet.add(gems[i]);
        
        int jewelCount = jewelSet.size(); // 보석 개수

        // 초기값
        int left = 0; int right = 0; 
        
        // 정답 
        int start = 0; int end = 0; 
        
        // 최적값 & 초기화
        int[] best = new int[2]; best[0] = -1;
        
        jewelMap.put(gems[left], 1); 
        
        while(left < n && right < n) {
                        
            // 현재 범위의 보석의 개수가 전체 보석개수보다 작은 경우 
            if(jewelMap.size() < jewelCount) {
                right++; // right를 한 칸 옮겨서 전체 범위를 확장한다
                
                // right가 가리키는 보석의 개수를 하나 추가한다. 없었다면 새로 만든다.
                try{
                    if(jewelMap.containsKey(gems[right])) jewelMap.put(gems[right], jewelMap.get(gems[right]) + 1);
                
                    else jewelMap.put(gems[right], 1);    
                }
                
                catch(Exception e) {
                    break;
                }
                
                
            }
            
            // 현재까지 구한 보석 개수가 전체 보석개수와 같아졌을 때 
            else {
                
                // 지금 left가 가리킨 보석의 개수가 1개 초과일 때
                // 더 짧은 길이를 만들 수 있기 때문에 
                // 개수를 한 개 줄이고 left를 한 칸 오른쪽으로 옮긴다.
                if(jewelMap.get(gems[left]) > 1) {
                    
                    
                    jewelMap.put(gems[left], jewelMap.get(gems[left]) - 1);
                
                    left++; 
                    
                }
                
                // left가 가리키는 보석의 개수가 1개일 때 
                // 최적값을 찾았을 수 있다. 
                else {
                    
                    // 아직 초기값이라면 left와 right을 그대로 대입한다.
                    if(best[0] == -1) {
                        best[0] = left; best[1] = right; 
                    }
                    
                    else {
                        // 지금 구한 길이가 
                        // 이전에 구한 범위보다 더 짧다면 갱신한다
                        if((right - left) < (best[1] - best[0])) {
                            best[0] = left; best[1] = right; 
                        }
                                                
                    }
                    
                    // left에서 한 칸 옮겨야 하니까 
                    // 기존에 gems[left]를 key로 갖던 매핑을 지워버린다
                    jewelMap.remove(gems[left]); left++;    
                }   
            }    
        }
        
        // 인덱스 시작이 0이여서 결과에서는 1을 더해야 함
        best[0]++; best[1]++;
        
        
        return best; 
    }
    
    
}
```
