[문제](https://leetcode.com/problems/shortest-distance-to-a-character/description/)

## 주요 내용

1) 대상이 되는 값(c)이 위치한 인덱스에는 `0`, `나머지`는 `MAX_VALUE`를 넣는다.

2) 왼쪽 ⇒ 오른쪽으로 스캔  
⇒ `i번째 값`이 max가 아니라면 `i+1번째 값`을 갱신한다.  
⇒ 이 과정을 통해 대상 값이 아니면서 `대상 값(c)` 보다 `오른쪽`에 있던 값들의 shortest distance를 구한다. 

3) 오른쪽 ⇒ 왼쪽으로 스캔  
⇒ `i-1번째 값`을 계속 갱신해 나간다.  
⇒ 이제 대상 값이 아니면서 `대상 값(c)` 보다 `왼쪽`에 있던 값들의 shortest distance를 구한다. 

## 정답 코드 
``` java
/** "loveleetcode" "e"
 *  1. put 0 at all position equals to e, and max at all other position
 *     we will get [max, max, max, 0, max, 0, 0, max, max, max, max, 0]
 *  2. scan from left to right, if =max, skip, else dist[i+1] = Math.min(dp[i] + 1, dp[i+1]), 
 *     we can get [max, max, max, 0, 1, 0, 0, 1, 2, 3, 4, 0]
 *  3. scan from right to left, use dp[i-1] = Math.min(dp[i] + 1, dp[i-1])
 *     we will get[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 
 */
class Solution {
    public int[] shortestToChar(String s, char c) {
        int n = s.length();
        int[] dist = new int[n];
        
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == c) continue;
            dist[i] = Integer.MAX_VALUE;
        }
        
        for (int i = 0; i < n-1; i++) {
            if (dist[i] == Integer.MAX_VALUE) continue;
            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);
        }
        
        for (int i = n-1; i > 0; i--) {
            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);
        }
        return dist; 
    }
}
```
