[문제]()

## 정답 코드
``` java
class Solution {
    public List<List<Integer>> largeGroupPositions(String s) {
        
        // 3개 이상의 연속된 문자열 그룹의 시작, 끝 인덱스를 찾아라 

        List<List<Integer>> res = new LinkedList<>(); 
        List<Integer> consec;
        
        int count = 1; 

        int start = 0;
        
        // i-1 번째 값을 조회할 거라서 i값은 1부터 시작한다.
        for(int i = 1; i < s.length(); i++) {

            consec = new LinkedList<>();
            
            // i-1번째 값과 i번째 값이 서로 같다면 count++
            if(s.charAt(i-1) == s.charAt(i)) count++;
            
            // i-1번째 값과 i번째 값이 서로 다른데 
            // count의 개수가 3 이상이면 저장해야 한다. 
            else if(s.charAt(i-1) != s.charAt(i) && count >= 3){
                
                consec.add(start); consec.add(i-1); 
                res.add(consec);   
                start = i; 
                count = 1;              
            }            
            
            // 아무것도 해당되지 않는다면 start와 count를 초기화한다 .
            else {
                start = i; 
                count = 1; 
            }

            // 해당 반복문은 마지막에 있는 값까지 처리하지 못한다는 한계점이 있다. 
            // 이를 보안하기 위해서 아래와 같은 코드를 작성했다. 
            if(count >= 3 && i == s.length() - 1) {
                consec.add(start); consec.add(i); 
                res.add(consec); 
            }
        }
        return res; 
    }
}
```

## 더 나은 코드 
``` java
    public List<List<Integer>> largeGroupPositions(String S) {
        List<List<Integer>> res = new ArrayList<>();
        
        // i와 j를 둘 다 0으로 초기화한다. 
        // i가 범위를 넘지 않도록 하고 
        // 반복문을 시작할 때 마다 i의 값은 j값이 되도록 한다. 
        for (int i = 0, j = 0; i < S.length(); i = j) {
            
            // j가 범위를 넘지 않으면서 
            // i번째 값과 j번째 값이 같을 때 j을 한 칸씩 이동시킨다. 
            while (j < S.length() && S.charAt(j) == S.charAt(i)) ++j;
            
            // 다 이동하고 나서 
            // i와 j가 3칸 이상 벌어졌다면 그 내용을 res에 저장한다. 
            if (j - i >= 3)
                res.add(Arrays.asList(i, j - 1));
        }
        return res;
    }
```
