
[문제](https://leetcode.com/problems/cousins-in-binary-tree/description/)

## 주요 내용

x, y 노드가 각각 `다른 부모`를 가지고 있고 `같은 레벨`에 있는 노드인가. ⇒ `레벨 순회`를 어떻게 하는지 잘 살펴보자.

## 정답 코드
``` java
public boolean isCousins(TreeNode root, int A, int B) {
    if (root == null) return false;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
      int size = queue.size();
      boolean isAexist = false;		
      boolean isBexist = false;	
      
      // 큐의 크기 만큼 반복한다. 
      // 이렇게 해야 트리를 레벨 별로 탐색하기 편하다. 
      for (int i = 0; i < size; i++) {
      
        // 현재 노드의 값이 A라면 isAexist = true
        // 현재 노드의 값이 B라면 isBexist = true
        TreeNode cur = queue.poll();
        if (cur.val == A) isAexist = true;
        if (cur.val == B) isBexist = true;
        
        // 자식 노드가 2개 있을 때 
        // 같은 부모 노드에 두 값이 있다면 false 
        if (cur.left != null && cur.right != null) { 
            if (cur.left.val == A && cur.right.val == B) return false;
            if (cur.left.val == B && cur.right.val == A) return false;
        }
        
        // 왼쪽 자식노드 하나만 있으니까 왼쪽 자식 노드를 que에 넣는다
        if (cur.left != null) queue.offer(cur.left);
        
        // 오른쪽 자식노드 하나만 있으니까 오른쪽 자식 노드를 que에 넣는다
        if (cur.right != null) queue.offer(cur.right);
        
        // 현재 레벨에 A와 B가 둘 다 있다면 true를 return한다. 
        if (isAexist && isBexist)  return true;
      }
    return false;
}
```
