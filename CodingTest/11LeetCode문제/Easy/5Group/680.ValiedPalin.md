[문제](https://leetcode.com/problems/valid-palindrome-ii/description/)

## 주요 내용 

1) i는 `배열의 시작` / j는 `배열의 끝`에서 시작한다. 
2) `palindrome`이라면 기본적으로 `s.charAt(왼쪽) == s.charAt(오른쪽)`가 성립해야 한다.  
  - 그냥 palindrome을 구분하는 문제였다면 `s.charAt(왼쪽) != s.charAt(오른쪽)`가 될 때 `false`를 return한다.  
3) 하지만, `1개의 문자`는 삭제할 수 있다.  
  - 그래서   
    `맨 앞`에서 범위를 1칸 줄이거나 (= `isPalindrome(s, i + 1, j)`)  
    `맨 뒤`에서 범위를 1칸 줄였을때 (= `isPalindrome(s, i, j - 1)`)  
    `palindrome`이 되는지 확인한다.  
    (`s.charAt(왼쪽) == s.charAt(오른쪽)`가 성립하는지 확인한다) 


## 정답 코드 

[쉽게 설명해준 포스트](https://leetcode.com/problems/valid-palindrome-ii/solutions/1904942/java-c-awesome-visuall-explanation/)

``` java
    public boolean validPalindrome(String s) {
        int i = 0, j = s.length() - 1;
        
        
        while (i < j) {
        
            // i번째 값과 j번째 값이 다르다. 
            // 즉, 대칭이 이뤄지지 않은 건데 문자를 1개 줄일 수 있으니까 
            // 아래의 return 코드를 실행한다. 
            if (s.charAt(i) != s.charAt(j)) {
                 
                // 왼쪽에서 1칸 범위를 줄이거나
                // 오른쪽에서 1칸 범위를 줄였을 때 
                
                // 여기서 true가 나왔다면
                // 문자열 1개를 삭제하고 나서 palindrome이 성립한 상황이 나온 것이다. 
                return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);
            }
            i++;
            j--;
        }

        return true;
    }
    
    /* Check is s[i...j] is palindrome. */
    private boolean isPalindrome(String s, int i, int j) {
        
        while (i < j) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
            i++;
            j--;
        }
        
        return true;
    }
```
