[문제](https://leetcode.com/problems/flood-fill/description/)

## 정답 코드 

BFS를 이용했다. 

다음부터는 `이웃한 노드`를 일일이 구할 때 `direction` 배열을 이용해서 구해보자.  - 관련 
``` java
class XY {
    int x; 
    int y; 

    XY(int x, int y) {
        this.x = x; 
        this.y = y; 
    }
}

class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        

        // image[i][j] = 픽셀 값 

        // (sr, sc)와 이웃한 똑같은 픽셀 값을 가진 픽셀들을 color로 바꿔라
        int m = image.length; 
        int n = image[0].length; 

        int start = image[sr][sc]; 

        boolean[][] visited = new boolean[m][n]; 

        Queue<XY> que = new LinkedList<>(); 
        que.add(new XY(sr, sc)); 

        while(!que.isEmpty()) {

            XY curXY = que.poll(); 

            List<XY> nb = new LinkedList<>(); 

            if(curXY.x != 0) nb.add(new XY(curXY.x - 1, curXY.y)); // 왼
            if(curXY.x != m - 1) nb.add(new XY(curXY.x + 1, curXY.y)); 
            if(curXY.y != 0) nb.add(new XY(curXY.x, curXY.y - 1)); 
            if(curXY.y != n - 1) nb.add(new XY(curXY.x, curXY.y + 1)); 

            for(XY xy : nb) {

                if(visited[xy.x][xy.y] == false && image[xy.x][xy.y] == start) {



                    image[xy.x][xy.y] = color; 
                    visited[xy.x][xy.y] = true; 

                    que.offer(new XY(xy.x, xy.y)); 

                }
            }

        }

        // 다 끝나고 나서 마지막에 imgae[sr][sc] = color로 바꾼다. 
        image[sr][sc] = color; 

        return image; 


    }
}
```

## 다른 코드 

- DFS를 이용 
``` java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if (image[sr][sc] == newColor) return image;
        fill(image, sr, sc, image[sr][sc], newColor);
        return image;
    }
    
    private void fill(int[][] image, int sr, int sc, int color, int newColor) {
        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != color) return;
        image[sr][sc] = newColor;
        fill(image, sr + 1, sc, color, newColor);
        fill(image, sr - 1, sc, color, newColor);
        fill(image, sr, sc + 1, color, newColor);
        fill(image, sr, sc - 1, color, newColor);
    }
}
```

- BFS를 이용 

dir라는 배열을 이용해서 이웃한 노드에 접근하는 걸 표현했다. 

``` java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        //BFS to find connected component
        int m = image.length;
        int n = image[0].length;
        int[][] visited = new int[m][n];
        
        // dir라는 배열을 이용해서
        // 왼쪽, 오른쪽, 위, 아래를 표현했다. 
        int dir[][] = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
        
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{sr,sc});
        int color = image[sr][sc];
        visited[sr][sc] = 1;
        image[sr][sc] = newColor;
        
        while(!q.isEmpty()){
            int pos[] = q.poll();
            int pos_x = pos[0];
            int pos_y = pos[1];
            
            // 갈 수 있는 방향의 개수만큼 for문을 반복
            for(int i=0;i<dir.length;i++){
                int cur_x = pos_x + dir[i][0];
                int cur_y = pos_y + dir[i][1];
                if(cur_x<0 || cur_x>=m || cur_y<0 || cur_y>=n || visited[cur_x][cur_y]==1 || image[cur_x][cur_y]!=color) continue;
                q.offer(new int[]{cur_x,cur_y});
                visited[cur_x][cur_y] = 1;
                image[cur_x][cur_y] = newColor;
            }
        }
        return image;
    }
}
```
