[문제](https://leetcode.com/problems/same-tree/solutions/)

## 주요 내용

`트리의 순회`를 통해 문제를 해결하면 된다. 

## 정답 코드 

``` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }

      public boolean preorder(TreeNode p, TreeNode q) {
        
          // p가 null인데 q가 null이 아닌 경우
          // q가 null인데 p가 null이 아닌 경우 
          // 이는 두 트리의 노드가 서로 다른 경우니까 false를 return한다.
          if(p == null && q != null || p != null && q == null) return false; 
          
          // p와 q가 null이 아닌데 
          // 값이 다르다면 false를 return
          else if(p != null && q != null && p.val != q.val) return false; 
          
          // p와 q가 null이 아닌 상황에서 
          // 각 노드의 왼쪽, 오른쪽에 대해서 순회를 반복한다. 
          // return값이 false가 된다면 false를 return한다. 
          if(p != null && q != null && preorder(p.left, q.left) == false) return false; 
          if(p != null && q != null && preorder(p.right, q.right) == false) return false; 
          
          // 위 모든 과정을 다 지났다면 true를 return한다. 
          return true;
          
      }
 }
 
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {

        // 순회로 해결

        TreeNode t = new TreeNode(); 

        return t.preorder(p, q);
        
    }
}
```

## 더 깔끔한 풀이 

[출처](https://leetcode.com/problems/same-tree/solutions/250926/same-tree/)

``` java
class Solution {
  public boolean isSameTree(TreeNode p, TreeNode q) {
  
    // p and q 둘 다 null일 때
    if (p == null && q == null) return true;
    
    // p와 q중 하나가 null일 때
    // 둘 다 null이 아니기 때문에 위 조건문을 지나왔다. 
    if (q == null || p == null) return false;
    
    // 값이 서로 다를 경우 
    if (p.val != q.val) return false;
    
    // 왼쪽에서의 결과와 오른쪽에서의 결과가 같다면 true 
    // 아니라면 false 
    return isSameTree(p.right, q.right) &&
            isSameTree(p.left, q.left);
  }
}
```
