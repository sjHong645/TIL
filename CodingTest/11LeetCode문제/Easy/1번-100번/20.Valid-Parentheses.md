[문제](https://leetcode.com/problems/valid-parentheses/)

## 주요 내용 

1) 기본적으로 `스택`을 사용해서 푸는 문제다. 

처음에는 괄호 규약 상관없이 짝만 맞으면 되는 줄 알았는데 규약을 지키면서 괄호의 짝이 맞아야 되는 걸 알고나서 쉽게 해결했다.

ex) `([)]` ⇒ 분명히 `괄호의 짝`은 맞지만 `()`안에 `[` 하나 있는 건 잘못된 방식이다. 

2) 대략적인 과정 

- open bracket(`(`, `{`, `[`)을 만나면 스택에 넣는다.
- close bracket(`)`, `}`, `]`)을 만났을 때  
  - 스택의 맨 위가 비어있거나
  - 스택의 맨 위에 있는 open bracket과 짝이 안 맞는다면
  - `false`를 반환한다. 

- `false`에 대한 아무런 조건에 걸리지 않는다면 `true`를 반환한다. 

## 정답 코드

``` java
import java.util.Deque; 
import java.util.LinkedList;

import java.util.Queue; 

class _Stack {
    
    Deque<Character> stk; 
    
    _Stack() { stk = new LinkedList<>(); }
    
    boolean isEmpty() { return stk.size() == 0; }
    
    void push(char c) { stk.offerLast(c); }
    
    char pop() { 
        
        if(stk.peekLast() == null) return ' '; 
       
        else return stk.pollLast(); 
    }
    
    char peek() { 
        
        if(stk.peekLast() == null) return ' ';
            
        else return stk.peekLast(); 
        
    }
    
}

// 단순히 짝만 맞는게 아니라
// 괄호 규약에 맞게 괄호가 위치해야 함
// ex) ([)]가 틀린다. 

class Solution {
    
    // 스택을 이용해서 괄호들의 짝이 서로 맞는지 알아내는 문제 
    public boolean isValid(String s) {
        
        _Stack stack = new _Stack(); 
        
        for(int i = 0; i < s.length(); i++) {
            
            char now = s.charAt(i); 
            
            // open bracket을 만나면 스택에 넣는다. 
            if(now == '(' || now == '{' || now == '[') stack.push(now); 
            
            // close bracket을 만났을 때
            // 맨 위가 null이거나
            // 서로 짝이 안맞는다면 false를 반환한다. 
            else if(now == ')') {
                
                if(stack.peek() == ' ' || stack.peek() != '(') return false; 
                                
                else stack.pop(); 
                
             }
            
            else if(now == '}') {
                
                if(stack.peek() == ' ' || stack.peek() != '{') return false; 
                                
                else stack.pop(); 
                
                
            }
            
            else if(now == ']') {
                
                if(stack.peek() == ' ' || stack.peek() != '[') return false; 
                                
                else stack.pop(); 
                
            }
        }
        
        // 모든 과정이 다 끝났는데 남아있는 값이 없다면 
        // 짝이 모두 맞았다는 거니까 true를 반환 
        if(stack.isEmpty()) return true; 
        
        else return false; 
        
    }
}
```

## 더 깔끔한 풀이 

[출처](https://leetcode.com/problems/valid-parentheses/discuss/9178/Short-java-solution)

1. `open bracket`이 올 때 그에 `대응되는 close bracket`을 스택에 넣는다.
2. `close bracket`이 올 때 `스택의 맨 위에 있는 값`이 `지금의 close bracket`과 동일해야 한다. 
3. 그렇지 않으면 false를 반환한다.

``` java
public boolean isValid(String s) {
	Stack<Character> stack = new Stack<Character>();
	for (char c : s.toCharArray()) {
		if (c == '(') stack.push(')');
    
		else if (c == '{') stack.push('}');
    
		else if (c == '[') stack.push(']');
    
		else if (stack.isEmpty() || stack.pop() != c) return false;
	}
	return stack.isEmpty();
}
```











