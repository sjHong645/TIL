[문제](https://leetcode.com/problems/merge-sorted-array/description/)

## 주요 내용

`Quick Sort`의 내용이 떠올랐다. 

1) nums1 배열의 0 ~ (m-1)까지의 값을 `idx1`로 가리킨다.
2) nums2 배열의 0 ~ (n-1)까지의 값을 `idx2`로 가리킨다.

여기서 `nums1` 배열은 함수의 `return 값`이 되야해서 똑같은 원소를 담은 `nums1_tmp`라는 배열을 따로 만들었다. 

3) idx1이 m을 넘지 않고 idx2가 n을 넘지 않은 상황에서  
  - `nums1_tmp[idx1]`와 `nums2[idx2]` 값 중에서 작은 값을 `nums1`배열에 넣어주고 인덱스를 각각 이동한다.
 
4) 나머지 넣지 못한 값들도 마저 `nums1` 배열에 넣어준다. 

## 정답 코드 

``` java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

        if(nums2.length == 0) return; 
        
        // nums1의 0~(m-1)까지 
        // nums2의 0~(n-1)까지 

        int idx1 = 0; 
        int idx2 = 0; 

        int[] nums1_tmp = new int[nums1.length]; 

        for(int i = 0; i < nums1.length; i++) {
            nums1_tmp[i] = nums1[i]; 
        }

        int index = 0; // nums1 배열의 값을 가리키는 인덱스
      
        // idx1이 m을 넘지 않고
        // idx2가 n을 넘지 않는한 계속 반복 
        while(idx1 < m && idx2 < n) {
            
            // 오름차순이니까 둘 중에 작은 값을 넣어주고 
            // 각 배열의 인덱스를 한 칸씩 이동한다. 
            if(nums1_tmp[idx1] < nums2[idx2]) {
                nums1[index++] = nums1_tmp[idx1++];
            }

            else {
                nums1[index++] = nums2[idx2++]; 
            }
        }
         
        // 반복문이 끝났는데 이 조건을 만족한다면
        // nums1_tmp을 m-1까지 접근하지 못했다는 뜻 
        // 그래서 나머지 값을 nums1 배열에 넣어준다.
        if(idx1 < m) {
            for(int i = index; i < nums1.length; i++) nums1[i] = nums1_tmp[idx1++]; 
        }
        
        // 마찬가지
        if(idx2 < n) {
            for(int i = index; i < nums1.length; i++) nums1[i] = nums2[idx2++]; 
        }
    }
}
```
