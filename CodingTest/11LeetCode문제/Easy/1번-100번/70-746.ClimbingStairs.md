[문제](https://leetcode.com/problems/climbing-stairs/description/)

## 주요 내용 

`n번째 계단`에 도달하는 경우는 `2가지`로 나눌 수 있다. 
1) `n-1번째 계단`에서 `1칸` 이동
2) `n-2번째 계단`에서 `2칸` 이동

그렇다면 이렇게 정리해볼 수 있다. 

- n-1번째 계단에 도달한 경우의 수 = $f_{n-1}$
- n-2번째 계단에 도달한 경우의 수 = $f_{n-2}$

따라서, $f_n$ = $f_{n-1}$ + $f_{n-2}$ 라고 정의할 수 있다. 

ex) 3번째 계단에 도달하는 경우의 수  

① `1번째 계단`에 도달하는 경우
```
계단 1개 
```

② `2번째 계단`에 도달하는 경우 
``` 
- 계단 1개 + 계단 1개
- 계단 2개
```

①의 경우에서 `3번째 계단`에 도달하려면 `계단 2개`를 넘어야 한다. 그래서 `계단 2개`를 각각의 경우의 수에 추가한다.
```
계단 1개 + 계단 2개 
```

②의 경우에서 `3번째 계단`에 도달하려면 `계단 1개`를 넘어야 한다. 그래서 `계단 1개`를 각각의 경우의 수에 추가한다.
```
- 계단 1개 + 계단 1개 + 계단 1개
- 계단 2개 + 계단 1개 
```

이들을 모두 합치면 `3번째 계단`에 도달하는 모든 경우가 나온다. 
```
- 계단 1개 + 계단 2개
- 계단 1개 + 계단 1개 + 계단 1개
- 계단 2개 + 계단 1개 
```

## 정답코드 

``` java
class Solution {
    public int climbStairs(int n) {

        if(n == 1) return 1; 
        
        // n번째 계단에 도착하기 위한 경우
        // 1) n-1번째 계단에서 1칸 오른다. 
        // 2) n-2번째 계단에서 2칸 오른다. 


        int[] steps = new int[n+1]; 

        steps[1] = 1; // 1번째 계단은 1칸 올라가는 경우가 있다.
        steps[2] = 2;

        for(int i = 3; i <= n; i++) {

            steps[i] = steps[i-2] + steps[i-1]; 

        }
        return steps[n];    
    }
}
```

[문제2](https://leetcode.com/problems/min-cost-climbing-stairs/description/)

## 정답 코드 
``` java
class Solution {

    // cost[i] = i번째 계단의 cost 
    public int minCostClimbingStairs(int[] cost) {

        // DP 
        for(int i = 2; i < cost.length; i++) {
            cost[i] = Math.min(cost[i] + cost[i-1], cost[i] + cost[i-2]); 
        }

        int end = cost.length - 1; 

        return Math.min(cost[end], cost[end-1]);
        
    }
}
```























