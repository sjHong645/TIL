[문제](https://leetcode.com/problems/ugly-number/description/)

## 주요 내용 

숫자 num이 `2, 3, 5`로만 `소인수분해`되는지 파악하는 문제 

## 정답 코드 
``` java
class Solution {
    public boolean isUgly(int n) {        
        
        if (num == 0) return false;
        if (num == 1) return true;

        // 2, 3, 5로 나눠떨어진다면 
        // num을 2, 3, 5로 나눈 값으로 계속 갱신한다. 
        
        // 만약에 단 한 번이라도 2 또는 3 또는 5로 나눠떨어지지 않는다는 건
        // 2, 3, 5로 이뤄지지 않은 값이라는 걸 의미한다. 
        while (num != 1) {
            if (num % 2 == 0) num /= 2;
            else if (num % 3 == 0) num /= 3;
            else if (num % 5 == 0) num /= 5;
            else return false;
        }
        return true;        
    }
}
```

++ 소수 판별 알고리즘 

숫자 n이 소수인지 판별하는 알고리즘. 

⇒ $\sqrt{n}$ `보다 작은 정수 값`으로 n을 나눴을 때 모두 나눠 떨어지지 않아야한다.  
⇒ 단 하나라도 나눠떨어진다면 `소수`가 아니다. 

``` java
boolean isPrime(int n) { 
  if(n < 2) return false; 
        
  if(n == 2) return true;
        
  for(int i = 2; i <= Math.sqrt(n); i++) { 
            
      if(n % i == 0) return false; 
        
  }
        
  return true;
}
```

++ 에라토스테네스의 체 

k = 2 부터 root N 이하까지 반복적으로 `N 이하의 자연수들` 중 `k의 배수들을 제외`시킨다.  
ex. N = 1000 ⇒ 1000이하의 자연수들 중 2의 배수, 3의 배수, 5의 배수 등등을 제외시켜서 남은 값들은 소수가 된다.

⇒ 이런 방식으로 소수들을 알아내는 방법이 `에라토스테네스의 체`이다.

``` java

void makePrime(int N) { 

  prime = new Boolean[N + 1] // 소수가 아닌 index는 true, 소수인 index는 false가 되도록 할 것임
  
  prime[0] = prime[1] = true; // 0과 1은 소수가 아니니까 true로 지정
  
  if(N < 2) return; // 2 이하일 때는 소수 판별을 할 필요가 없어서 종료
  
  for(int i = 2; i <= Math.sqrt(N); i++) { 
  
    if(prime[i] == true) continue; // 이미 true이면 다음 반복문으로 넘어간다.
    
    for(int j = i * i; j < prime.length; j += i) {
    
      prime[j] = true; 
      
    } 
  
  }

} 

```
















