[문제](https://leetcode.com/problems/ransom-note/description/)

## 내 코드 

흔하게 생각할 수 있는 코드다. 

`기준`이 되는 magazine의 각 알파벳을 매핑해서 그걸 `ransomNote`랑 비교하기 

``` java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        
        Map<Character, Integer> map = new HashMap<>(); 
        
        // magazine의 각 알파벳 매핑 
        // key - 알파벳, value = key의 개수 
        for(int i = 0; i < magazine.length(); i++) {
            char ith = magazine.charAt(i); 

            if(map.containsKey(ith)) map.put(ith, map.get(ith)+1); 

            else map.put(ith, 1); 
        }
        
        
        for(int i = 0; i < ransomNote.length(); i++) {

            char ith = ransomNote.charAt(i);
            
            if(map.containsKey(ith)) {
            
                // i번째 알파벳의 개수가 이미 0개라면 
                // ransomeNote에서 사용해야 할 알파벳 개수를 초과한 거다. 
                // 그래서 false를 return 
                if(map.get(ith) == 0) return false;  
                
                // 보일 때 마다 개수를 1개씩 줄인다. 
                else map.put(ith, map.get(ith) - 1); 
            }

            else return false; 

            
        }

        return true; 
    }
}
```

## 더 짧은 풀이 

`알파벳` 개수를 위한 `별도의 배열`을 선언한다. 알파벳은 `26개`니까 `길이가 26`인 배열을 선언한다. 

그 배열에 `magazine`에 있는 알파벳 개수를 세고 

`ransomNote`에서 알파벳을 하나씩 발견할 때마다 `1씩 감소`시킨다. 

그러다가 `개수가 0개`인 배열 값을 만나면 false를 return

``` java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
		if (ransomNote.length() > magazine.length()) return false;
        int[] alphabets_counter = new int[26];
        
        for (char c : magazine.toCharArray())
            alphabets_counter[c-'a']++;

        for (char c : ransomNote.toCharArray()){
            if (alphabets_counter[c-'a'] == 0) return false;
            alphabets_counter[c-'a']--;
        }
        return true;
    }
}
```
