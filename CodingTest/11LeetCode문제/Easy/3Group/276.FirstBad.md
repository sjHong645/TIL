[문제](https://leetcode.com/problems/first-bad-version/description/)

## 주요 내용 

`이진 탐색`이다. 

다만, 이전에 알던 이진 탐색보다 좀 더 나은 방식을 찾았다. 

## 정답 코드 
``` java
 public int firstBadVersion(int n) {
        int start = 1, end = n;
            while (start < end) {
                // int mid = (start + end) / 2 
                // end, start 둘 다 큰 값일 경우 overflow가 발생할 수 있음 

                // 그리고 계산을 해보면 (start + end) / 2 = start + (end-start) / 2 이다. 
                // 다면, end-start를 하면서 end와 start가 둘 다 큰 값이더라도 뺄셈을 하기 때문에 overflow가 발생하지 않는다. 

                int mid = start + (end-start) / 2;

                if (!isBadVersion(mid)) start = mid + 1;
                
                // end = mid + 1; 이 오면 안되는 이유는 
                // 이 문제에서의 이진 탐색은 원하는 값을 찾기 위한 이진 탐색이 아니다. 
                // isBadVersion(mid)이 true가 되는 최초의 위치를 찾기 위한 탐색이다. 
                
                // 그렇기 때문에 else 조건문에 도달했다는 건 현재 mid번째 값이 bad라는 거다
                // 즉, 범위에서 함부로 제외시킬 수 없는 위치이기 때문에 
                // 해당 범위를 포함해야 하니까 +1을 쓰지 않아야 한다.
                else end = mid;            
            }        
    return start;
    }
```
