[문제](https://leetcode.com/problems/binary-tree-paths/description/)

## 주요 내용 

ex1)  
![image](https://user-images.githubusercontent.com/64796257/194246696-b0d200fa-8164-47c9-b60b-5d1597af20a0.png)

이 그림을 통해 코드를 따라가면서 이해하자. 

## 정답 코드 

- 재귀 
``` java
public class Solution {
// Recursion
public List<String> binaryTreePaths(TreeNode root) {
    
    // s는 string을 의미한다. 
    // return할 전체 리스트
    List<String> sList=new LinkedList<String>(); 
    
    // root가 null이면 sList를 그대로 return하고 
    if (root==null) return sList;
    
    // 왼쪽, 오른쪽 둘 다 없다면 
    // 루트 값만 추가한다. 
    if (root.left==null && root.right==null) {
        sList.add(Integer.toString(root.val));
        return sList;
    }
    
    // 왼쪽 서브 트리를 지나는 경로 추가 
    for (String s: binaryTreePaths(root.left)) {
        sList.add(Integer.toString(root.val)+"->"+s);
    }
    
    // 오른쪽 서브 트리를 지나는 경로 추가 
    for (String s: binaryTreePaths(root.right)) {
        sList.add(Integer.toString(root.val)+"->"+s);
    }
    
    return sList;
}
```

- BFS 
``` java
public class Solution {
//BFS - Queue
public List<String> binaryTreePaths(TreeNode root) {

    List<String> list=new ArrayList<String>();
    
    Queue<TreeNode> qNode=new LinkedList<TreeNode>();
    Queue<String> qStr=new LinkedList<String>();
    
    if (root==null) return list;
    qNode.add(root);
    qStr.add("");
    
    while(!qNode.isEmpty()) {
        // 현재 노드 curNode, 현재 str curStr 
        TreeNode curNode=qNode.remove();
        String curStr=qStr.remove();
         
        // 현재 노드의 왼쪽과 오른쪽이 둘 다 없다면
        // 현재 str에다가 현재 노드의 val을 추가한다. 
        if (curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);
        
        // 왼쪽이 존재한다면 
        // 왼쪽 노드를 qNode에 추가시키고 
        // 왼쪽 노드의 val을 qStr에 추가시킨다. 
        if (curNode.left!=null) {
            qNode.add(curNode.left);
            qStr.add(curStr+curNode.val+"->");
        }
        
        // 오른쪽이 존재한다면 
        // 오른쪽 노드를 qNode에 추가시키고 
        // 오른쪽 노드의 val을 qStr에 추가시킨다. 
        if (curNode.right!=null) {
            qNode.add(curNode.right);
            qStr.add(curStr+curNode.val+"->");
        }
    }
    return list;
}
```

- DFS 
``` java
public class Solution {

// DFS - Stack
public List<String> binaryTreePaths(TreeNode root) {
    List<String> list=new ArrayList<String>();
    Stack<TreeNode> sNode=new Stack<TreeNode>();
    Stack<String> sStr=new Stack<String>();
    
    if(root==null) return list;
    sNode.push(root);
    sStr.push("");
    while(!sNode.isEmpty()) {
        TreeNode curNode=sNode.pop();
        String curStr=sStr.pop();
        
        if(curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);
        if(curNode.left!=null) {
            sNode.push(curNode.left);
            sStr.push(curStr+curNode.val+"->");
        }
        if(curNode.right!=null) {
            sNode.push(curNode.right);
            sStr.push(curStr+curNode.val+"->");
        }
    }
    return list;
}
```
