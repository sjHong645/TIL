[문제](https://leetcode.com/problems/missing-number/description/)

## 주요 내용

ex) nums = [3, 0, 1]

그러면, nums의 길이가 3이니까 `nums`에는 `0~3까지의 숫자`가 있어야 한다. 그 중에서 `하나`가 없는 상황. 

이걸 나는 이렇게 찾아내려 한다. 

실제로 0, 1, 2, 3을 인덱스로 가지는 배열을 하나 만든다. ⇒ `int[] isExist = new int[nums.length+1];`

이때, `nums[i]값`을 인덱스로 가지는 `isExist의 배열값(=isExist[nums[i]])`은 1로 설정한다.   
즉, `isExist[i] = 0`이 되도록 하는 `i값`은 `nums 배열`에 없는 값이 된다. 

```
첫 번째 반복문 
isExist[nums[0]] = isExist[3] = 1; 
isExist[nums[1]] = isExist[0] = 1; 
isExist[nums[2]] = isExist[1] = 1; 

⇒ 이로써 isExist[2] = 0이 된다. 즉, 2는 nums배열에 없는 값
```

## 정답 코드 
``` java
class Solution {
    public int missingNumber(int[] nums) {

        int n = nums.length; 

        int[] isExist = new int[n+1]; 

        for(int i = 0; i < n; i++) {
            isExist[nums[i]] = 1; 
        }

        int result = 0; 
        for(int i = 0; i < isExist.length; i++) {
            if(isExist[i] == 0) {
                result = i; 
                break;
            }
        }
        
        return result; 
    }
}
```

## 다른 풀이 2

`^` 연산을 가지고 풀었다. 

- `^` 연산자 [출처](https://staticclass.tistory.com/25)  
![image](https://user-images.githubusercontent.com/64796257/194265251-759a2951-85e1-434c-bbcc-caabef533462.png)

`두 값의 비트`를 비교하는데  
- 하나가 1 & 다른 하나가 0 => 결과 1   
- 하나가 1 & 다른 하나가 1 => 결과 0  
- 하나가 0 & 다른 하나가 0 => 결과 0  

### 성질
- a^b^b = a

``` java
public int missingNumber(int[] nums) {

    int xor = 0, i = 0;
    for (i = 0; i < nums.length; i++) {
      xor = xor ^ i ^ nums[i];
    }

    return xor ^ i;
}
```

정확히 어떤 과정을 거쳐서 되는지 잘 모르겠다. `nums = [3, 0, 1]`를 가지고 직접 해보겠다. 


```
xor = 0
==========
i = 0일 때 

xor = xor ^ i ^ nums[i] = 0 ^ 0 ^ 3 = 3

-------------------
i = 1일 때 

xor = xor ^ i ^ nums[i] = 3 ^ 1 ^ 0 = 2

-------------------
i = 2일 때 

xor = xor ^ i ^ nums[i] = 2 ^ 2 ^ 1 = 1

-------------------

return xor ^ i = 1 ^ 3 = 2
```

### 다른 풀이 3

nums의 값은 `0~n` 중에서 `1개`만 빠져있다. 

즉, $0 + 1 + 2 + ... + n$ = $n(n+1) \over 2$ 에서 `nums에 있는 값`을 하나씩 빼다보면 없는 값이 나올 것이다. 

return 식 해설 : $n(n+1) \over 2$ - sum = $n(n+1) - 2×sum \over 2$


``` java
public class Solution {
    public int missingNumber(int[] nums) {
        int sum = 0;
        for(int num: nums)
            sum += num;
      
        // 주석 처리된 방식으로 하면 nums.length의 크기가 커졌을 때 overflow가 발생한다. 
        // 그래서 아래와 같이 코드를 바꿨다. 
        // return (nums.length * (nums.length + 1) )/ 2 - sum;    
        
        return ( (nums.length * (nums.length + 1) ) - 2 * sum ) / 2;
    }
}
```








