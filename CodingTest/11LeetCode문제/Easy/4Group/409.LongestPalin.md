[문제](https://leetcode.com/problems/longest-palindrome/description/)

## 주요 내용

palindrome의 절반으로 나눴을 때 `알파벳 개수`를 세는 과정이라 보면 되겠다. 

- palindrome의 경우 2가지
1) xxxOxxx => `홀수 개의 원소`는 `중간 값`을 기준으로 나눌 수 있다.
2) xxx|xxx => `짝수 개의 원소`는 그냥 `중간`을 기준으로 나눌 수 있다.

그래서 한 쪽 부분의 경우의 수를 `count`라고 할 때 

1)의 경우는 `2 * count + 1` / 2)의 경우는 `2 * count`가 palindrome의 길이가 된다. 


## 정답 코드 

``` java
class Solution {
    public int longestPalindrome(String s) {
        if(s==null || s.length()==0) return 0;

        HashSet<Character> hs = new HashSet<Character>();
        int count = 0;

        for(int i=0; i<s.length(); i++){
            if(hs.contains(s.charAt(i))){
                hs.remove(s.charAt(i));
                count++;
            }
            else{
                hs.add(s.charAt(i));
            }
        }
        // 알파벳이 짝수개라면 set에 남아있지 않는다. 
        // 즉, 홀수개라면 남아있다. 

        // 남아있는 값이 존재한다는 건
        // s를 이룬 각각의 알파벳 중에서 홀수개의 알파벳이 있다는 걸 뜻한다. 
        // 그래서 전체 count의 2배를 해준 다음에 
        
        // 중간값에 홀수개를 가진 알파벳 하나 넣어줌으로써 palindrome을 완성시킬 수 있다. 
        // 그래서 +1을 한 것이다. 
        if(!hs.isEmpty()) return count*2+1;
        
        
        // 남아있는 값이 하나도 없다는 건 
        // s를 이룬 각각의 알파벳이 전부 짝수개였다는 것이다. 
        // 그렇기 때문에 count * 2만 해주면 된다. 
        return count*2;
}
}
```
