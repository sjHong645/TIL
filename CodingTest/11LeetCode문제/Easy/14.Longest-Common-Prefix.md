[문제](https://leetcode.com/problems/longest-common-prefix/)

## 주요 내용 

1. 초기값으로 문자열 `배열의 0번째 값`을 `common`이라는 이름으로 저장
2. `배열의 1번째` 부터 탐색 시작 
3. `common`과 `배열의 i번째 값`의 공통된 앞부분을 파악
4. 출력 

그림으로 표현하면 다음과 같다. [출처](https://leetcode.com/problems/longest-common-prefix/solution/)

![image](https://user-images.githubusercontent.com/64796257/192420768-9e1ba033-c30c-456e-b420-5ed128a7420d.png)

``` java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        
        String common = strs[0]; // 초기값
        
        for(int i = 1; i < strs.length; i++) {
            
            String tempCommon = ""; 
                        
            String after = strs[i];            
            
            int range = Math.min(common.length(), after.length()); 
            
            // i번째 값과 i+1번째 값의 공통 앞부분 저장
            for(int j = 0; j < range; j++) {
                if(common.charAt(j) == after.charAt(j)) tempCommon += after.charAt(j); 
                
                else break;
            }
                        
            common = tempCommon; // 앞서 구한 공통 부분을 commom에 저장
        }
        
        return common;
        
        
    }
}
```

위 방법보다 더 좋은 방법이 있다. 

`indexOf` 메소드가 `문자열`을 매개변수로 받는 줄은 몰랐다. 

ex) 
``` java
String myStr = "Hello planet earth, you are a great planet.";

myStr.indexOf("planet") // "planet" 문자열의 시작 인덱스 6을 return한다. 
```

``` java
 public String longestCommonPrefix(String[] strs) {
 
    if (strs.length == 0) return "";
    
    String prefix = strs[0]; // 공통된 앞부분을 저장할 prefix
    
    for (int i = 1; i < strs.length; i++)
    
        // i번째 문자열이 prefix 값을 가지고 있는 경우 계속 반복 
        while (strs[i].indexOf(prefix) != 0) {
            prefix = prefix.substring(0, prefix.length() - 1);
            if (prefix.isEmpty()) return "";
        }        
    return prefix;
}
```


